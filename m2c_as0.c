Warning: missing "jr $ra" in last block (.initial).

Warning: missing "jr $ra" in last block (.initial).

Warning: missing "jr $ra" in last block (.initial).

struct _struct_asm_info_0x8 {
    /* 0x0 */ u8 *unk0;                             /* inferred */
    /* 0x4 */ u32 unk4;                             /* inferred */
};                                                  /* size = 0x8 */

s32 __ll_div(s32, u32, s32, u32);                   /* extern */
s32 __ll_lshift(s32, u32, s32, u32);                /* extern */
s32 __ll_mul(s32, u32, s32, u32);                   /* extern */
s32 __ll_rem(s32, u32, s32, u32);                   /* extern */
s32 __ull_rshift(s32, u32, s32, u32);               /* extern */
u32 atol(? *);                                      /* extern */
? bzero(? *, s32, ? *);                             /* extern */
? *calloc(?, ?);                                    /* extern */
? close(s32);                                       /* extern */
s32 dup(s32);                                       /* extern */
? exit(s32);                                        /* extern */
? fclose(? *);                                      /* extern */
? *fdopen(s32, ? *);                                /* extern */
? fflush(? *);                                      /* extern */
s32 fgetc(? *, u8 *, u8, u8);                       /* extern */
? *fopen(u8 *, ? *, u8 *);                          /* extern */
? fprintf(? *, ? *, s32, s32 *, s32, s32);          /* extern */
? free(? *, ? *);                                   /* extern */
? fseek(? *, s32, ?);                               /* extern */
s32 fstat(u8, ? *);                                 /* extern */
s32 fwrite(? **, s32, u16, ? *);                    /* extern */
? *getcwd(?, s32);                                  /* extern */
s32 gethostname(u8 *, ?);                           /* extern */
s32 lseek(s32, s32, ?);                             /* extern */
? *malloc(s32, ? **);                               /* extern */
? memcpy(? **, ? **, s32, ? **);                    /* extern */
? *memset(? *, ?, s32, s32);                        /* extern */
s32 open(?, ?);                                     /* extern */
s32 pathconf(s32, ?);                               /* extern */
? perror(? *);                                      /* extern */
s32 read(s32, s16 *, s32);                          /* extern */
? *realloc(? *, s32);                               /* extern */
s32 sbrk(? **, s32);                                /* extern */
? sprintf(? *, ? *, u32);                           /* extern */
s32 stat(s32, ? *);                                 /* extern */
? strcat(u8 *, ? *);                                /* extern */
s32 strcmp(? *, ? *, s32, u32);                     /* extern */
u8 *strcpy(u8 *, ? *);                              /* extern */
s32 strlen(? *);                                    /* extern */
s32 strtoll(u8 *, ?, ?);                            /* extern */
s32 strtoull(?, ?);                                 /* extern */
u32 time(?);                                        /* extern */
u8 tolower(u8, s32);                                /* extern */
void func_00403DFC();                               /* static */
s32 func_0041244C(u8 *);                            /* static */
s32 func_00412548(u8 *);                            /* static */
s32 func_00419E30(s32 arg0, s32 arg1, s32 arg2, ? *arg3, s32 arg4); /* static */
extern ? __ctype;
extern ? __iob;
extern s32 errno;
static s32 gform_extn = 0;
static u8 *D_10000004[4] = { (u8 *)0x10004C80, (u8 *)0x10004C84, (u8 *)0x10004C90, (u8 *)0x10004C9C };
static ? *D_10000014 = NULL;
static s32 D_10000020 = 0;
static s32 D_10000024 = 0;
static u8 *sitype[0x3F] = {
    (u8 *)0x10006A40,
    (u8 *)0x10006A48,
    (u8 *)0x10006A50,
    (u8 *)0x10006A58,
    (u8 *)0x10006A60,
    (u8 *)0x10006A68,
    (u8 *)0x10006A70,
    (u8 *)0x10006A78,
    (u8 *)0x10006A80,
    (u8 *)0x10006A88,
    (u8 *)0x10006A90,
    (u8 *)0x10006A98,
    (u8 *)0x10006AA0,
    (u8 *)0x10006AA8,
    (u8 *)0x10006AB0,
    (u8 *)0x10006AB8,
    (u8 *)0x10006AC4,
    (u8 *)0x10006ACC,
    (u8 *)0x10006AD4,
    (u8 *)0x10006AE0,
    (u8 *)0x10006AE8,
    (u8 *)0x10006AF0,
    (u8 *)0x10006AF8,
    (u8 *)0x10006B00,
    (u8 *)0x10006B08,
    (u8 *)0x10006B10,
    (u8 *)0x10006B18,
    (u8 *)0x10006B20,
    (u8 *)0x10006B28,
    (u8 *)0x10006B30,
    (u8 *)0x10006B38,
    (u8 *)0x10006B40,
    (u8 *)0x10006B48,
    (u8 *)0x10006B50,
    (u8 *)0x10006B5C,
    (u8 *)0x10006B64,
    (u8 *)0x10006B6C,
    (u8 *)0x10006B74,
    (u8 *)0x10006B7C,
    (u8 *)0x10006B84,
    (u8 *)0x10006B8C,
    (u8 *)0x10006B94,
    (u8 *)0x10006B9C,
    (u8 *)0x10006BA8,
    (u8 *)0x10006BB0,
    (u8 *)0x10006BBC,
    (u8 *)0x10006BC4,
    (u8 *)0x10006BCC,
    (u8 *)0x10006BD4,
    (u8 *)0x10006BE0,
    (u8 *)0x10006BE8,
    (u8 *)0x10006BF0,
    (u8 *)0x10006BF8,
    (u8 *)0x10006C00,
    (u8 *)0x10006C0C,
    (u8 *)0x10006C18,
    (u8 *)0x10006C24,
    (u8 *)0x10006C30,
    (u8 *)0x10006C40,
    (u8 *)0x10006C4C,
    (u8 *)0x10006C54,
    (u8 *)0x10006C60,
    (u8 *)0x10006C68,
};
static u8 *sregisters[0x49] = {
    (u8 *)0x10006C70,
    (u8 *)0x10006C74,
    (u8 *)0x10006C78,
    (u8 *)0x10006C7C,
    (u8 *)0x10006C80,
    (u8 *)0x10006C84,
    (u8 *)0x10006C88,
    (u8 *)0x10006C8C,
    (u8 *)0x10006C90,
    (u8 *)0x10006C94,
    (u8 *)0x10006C98,
    (u8 *)0x10006C9C,
    (u8 *)0x10006CA0,
    (u8 *)0x10006CA4,
    (u8 *)0x10006CA8,
    (u8 *)0x10006CAC,
    (u8 *)0x10006CB0,
    (u8 *)0x10006CB4,
    (u8 *)0x10006CB8,
    (u8 *)0x10006CBC,
    (u8 *)0x10006CC0,
    (u8 *)0x10006CC4,
    (u8 *)0x10006CC8,
    (u8 *)0x10006CCC,
    (u8 *)0x10006CD0,
    (u8 *)0x10006CD4,
    (u8 *)0x10006CD8,
    (u8 *)0x10006CDC,
    (u8 *)0x10006CE0,
    (u8 *)0x10006CE4,
    (u8 *)0x10006CE8,
    (u8 *)0x10006CEC,
    (u8 *)0x10006CF0,
    (u8 *)0x10006CF4,
    (u8 *)0x10006CF8,
    (u8 *)0x10006CFC,
    (u8 *)0x10006D00,
    (u8 *)0x10006D04,
    (u8 *)0x10006D08,
    (u8 *)0x10006D0C,
    (u8 *)0x10006D10,
    (u8 *)0x10006D14,
    (u8 *)0x10006D18,
    (u8 *)0x10006D20,
    (u8 *)0x10006D28,
    (u8 *)0x10006D30,
    (u8 *)0x10006D38,
    (u8 *)0x10006D40,
    (u8 *)0x10006D48,
    (u8 *)0x10006D50,
    (u8 *)0x10006D58,
    (u8 *)0x10006D60,
    (u8 *)0x10006D68,
    (u8 *)0x10006D70,
    (u8 *)0x10006D78,
    (u8 *)0x10006D80,
    (u8 *)0x10006D88,
    (u8 *)0x10006D90,
    (u8 *)0x10006D98,
    (u8 *)0x10006DA0,
    (u8 *)0x10006DA8,
    (u8 *)0x10006DB0,
    (u8 *)0x10006DB8,
    (u8 *)0x10006DC0,
    (u8 *)0x10006DC8,
    (u8 *)0x10006DD0,
    (u8 *)0x10006DD8,
    (u8 *)0x10006DE0,
    (u8 *)0x10006DE8,
    (u8 *)0x10006DF0,
    (u8 *)0x10006DF8,
    (u8 *)0x10006E00,
    (u8 *)0x10006E08,
};
static ? *sset_value[0x11] = {
    (? *)0x10006E80,
    (? *)0x10006E84,
    (? *)0x10006E8C,
    (? *)0x10006E98,
    (? *)0x10006EA0,
    (? *)0x10006EA8,
    (? *)0x10006EAC,
    (? *)0x10006EB4,
    (? *)0x10006EBC,
    (? *)0x10006EC4,
    (? *)0x10006ECC,
    (? *)0x10006ED4,
    (? *)0x10006EE0,
    (? *)0x10006EEC,
    (? *)0x10006EF8,
    (? *)0x10006F04,
    (? *)0x10006F10,
};
static u8 *sframereg = (u8 *)0x10006F48;
static ? *sframesize = (? *)0x10006F54;
static struct _struct_asm_info_0x8 asm_info[0x1AF] = {
    { (u8 *)0x10006F60, 0x08000420 },
    { (u8 *)0x10006F64, 0x060A0421 },
    { (u8 *)0x10006F68, 0x060A8421 },
    { (u8 *)0x10006F70, 0x060C0421 },
    { (u8 *)0x10006F74, 0x10000000 },
    { (u8 *)0x10006F78, 0x101C8000 },
    { (u8 *)0x10006F80, 0x101D0000 },
    { (u8 *)0x10006F88, 0x101DB000 },
    { (u8 *)0x10006F90, 0x101E3000 },
    { (u8 *)0x10006F98, 0x101E8000 },
    { (u8 *)0x10006FA0, 0x101F0000 },
    { (u8 *)0x10006FA8, 0 },
    { (u8 *)0x10006FAC, 0 },
    { (u8 *)0x10006FB0, 0x0C258420 },
    { (u8 *)0x10006FB4, 0x0C000420 },
    { (u8 *)0x10006FB8, 0x0C000420 },
    { (u8 *)0x10006FC0, 0x0E1B0400 },
    { (u8 *)0x10006FC8, 0x0C000420 },
    { (u8 *)0x10006FCC, 0x0C000420 },
    { (u8 *)0x10006FD4, 0x0E270400 },
    { (u8 *)0x10006FDC, 0x0C000420 },
    { (u8 *)0x10006FE0, 0x0C000420 },
    { (u8 *)0x10006FE8, 0x0E268400 },
    { (u8 *)0x10006FF0, 0x0C000420 },
    { (u8 *)0x10006FF4, 0x0C000420 },
    { (u8 *)0x10006FFC, 0x0E1A8400 },
    { (u8 *)0x10007004, 0x0C260420 },
    { (u8 *)0x10007008, 0x58000 },
    { (u8 *)0x10007010, 0x12318000 },
    { (u8 *)0x10007014, 0x12320000 },
    { (u8 *)0x10007018, 0x12328000 },
    { (u8 *)0x1000701C, 0 },
    { (u8 *)0x10007020, 0x06090421 },
    { (u8 *)0x10007024, 0x06098421 },
    { (u8 *)0x1000702C, 0x0A248400 },
    { (u8 *)0x10007030, 0x0A250400 },
    { (u8 *)0x10007034, 0x02000400 },
    { (u8 *)0x10007038, 0x02330460 },
    { (u8 *)0x1000703C, 0x02350460 },
    { (u8 *)0x10007040, 0x02338460 },
    { (u8 *)0x10007044, 0x02358460 },
    { (u8 *)0x10007048, 0x04000400 },
    { (u8 *)0x1000704C, 0x02348460 },
    { (u8 *)0x10007050, 0x0A040400 },
    { (u8 *)0x10007054, 0x02399060 },
    { (u8 *)0x1000705C, 0x023A0460 },
    { (u8 *)0x10007064, 0x1E9E0460 },
    { (u8 *)0x1000706C, 0x14060400 },
    { (u8 *)0x10007074, 0x14070400 },
    { (u8 *)0x1000707C, 0x08000420 },
    { (u8 *)0x10007084, 0x0A048400 },
    { (u8 *)0x1000708C, 0x023B1060 },
    { (u8 *)0x10007094, 0x023B8460 },
    { (u8 *)0x1000709C, 0 },
    { (u8 *)0x100070A0, 0x14068400 },
    { (u8 *)0x100070A8, 0x14078400 },
    { (u8 *)0x100070B0, 0x06000421 },
    { (u8 *)0x100070B4, 0x06000421 },
    { (u8 *)0x100070BC, 0x06000421 },
    { (u8 *)0x100070C4, 0x08080420 },
    { (u8 *)0x100070CC, 0x08088420 },
    { (u8 *)0x100070D4, 0x08000420 },
    { (u8 *)0x100070D8, 0x8000 },
    { (u8 *)0x100070DC, 0x060D8421 },
    { (u8 *)0x100070E0, 0x060C8421 },
    { (u8 *)0x100070E4, 0x06090421 },
    { (u8 *)0x100070E8, 0x06098421 },
    { (u8 *)0x100070F0, 0x498000 },
    { (u8 *)0x100070F4, 0x06000421 },
    { (u8 *)0x100070F8, 0x06000421 },
    { (u8 *)0x100070FC, 0x02368460 },
    { (u8 *)0x10007100, 0x06000421 },
    { (u8 *)0x10007104, 0x06000421 },
    { (u8 *)0x10007108, 0x06000421 },
    { (u8 *)0x10007110, 0x06000421 },
    { (u8 *)0x10007114, 0x06000421 },
    { (u8 *)0x1000711C, 0x02370460 },
    { (u8 *)0x10007120, 0x06000421 },
    { (u8 *)0x10007124, 0x06000421 },
    { (u8 *)0x1000712C, 0x06010421 },
    { (u8 *)0x10007130, 0x06000421 },
    { (u8 *)0x10007134, 0x06000421 },
    { (u8 *)0x1000713C, 0x06000421 },
    { (u8 *)0x10007140, 0x06020421 },
    { (u8 *)0x10007144, 0x06018421 },
    { (u8 *)0x10007148, 0x060B0421 },
    { (u8 *)0x1000714C, 0x060B8421 },
    { (u8 *)0x10007154, 0x02380460 },
    { (u8 *)0x10007158, 0x50000 },
    { (u8 *)0x10007160, 0x060D0421 },
    { (u8 *)0x10007164, 0x08000420 },
    { (u8 *)0x10007168, 0x02340460 },
    { (u8 *)0x1000716C, 0x02360460 },
    { (u8 *)0x10007170, 0x02378460 },
    { (u8 *)0x10007174, 0x02388460 },
    { (u8 *)0x10007178, 0 },
    { (u8 *)0x1000717C, 0x084584E0 },
    { (u8 *)0x10007184, 0x08460480 },
    { (u8 *)0x1000718C, 0x084684E0 },
    { (u8 *)0x10007194, 0 },
    { (u8 *)0x10007198, 0x084784E0 },
    { (u8 *)0x100071A0, 0x08480480 },
    { (u8 *)0x100071A8, 0x084884E0 },
    { (u8 *)0x100071B0, 0x4C0000 },
    { (u8 *)0x100071B8, 0x4A0000 },
    { (u8 *)0x100071C0, 0x4A8000 },
    { (u8 *)0x100071C8, 0x4B0000 },
    { (u8 *)0x100071D0, 0x4B8000 },
    { (u8 *)0x100071D8, 0x023C8860 },
    { (u8 *)0x100071DC, 0x023D0860 },
    { (u8 *)0x100071E0, 0 },
    { (u8 *)0x100071E4, 0x023D9460 },
    { (u8 *)0x100071EC, 0x023E2060 },
    { (u8 *)0x100071F4, 0x9E8000 },
    { (u8 *)0x100071FC, 0x9F0000 },
    { (u8 *)0x10007204, 0x023E9460 },
    { (u8 *)0x1000720C, 0x023F2060 },
    { (u8 *)0x10007214, 0 },
    { (u8 *)0x10007218, 0x02001460 },
    { (u8 *)0x1000721C, 0x02001460 },
    { (u8 *)0x10007220, 0x02001860 },
    { (u8 *)0x10007224, 0x02001460 },
    { (u8 *)0x10007228, 0x02001460 },
    { (u8 *)0x1000722C, 0x02001860 },
    { (u8 *)0x10007230, 0x065014A5 },
    { (u8 *)0x10007238, 0x065094A5 },
    { (u8 *)0x10007240, 0x065118C6 },
    { (u8 *)0x10007248, 0x065194A5 },
    { (u8 *)0x10007250, 0x065214A5 },
    { (u8 *)0x10007258, 0x065298C6 },
    { (u8 *)0x10007260, 0x065314A5 },
    { (u8 *)0x10007268, 0x065394A5 },
    { (u8 *)0x10007270, 0x065418C6 },
    { (u8 *)0x10007278, 0x065494A5 },
    { (u8 *)0x10007280, 0x065514A5 },
    { (u8 *)0x10007288, 0x065598C6 },
    { (u8 *)0x10007290, 0x080014A0 },
    { (u8 *)0x10007298, 0x080014A0 },
    { (u8 *)0x100072A0, 0x080018C0 },
    { (u8 *)0x100072A8, 0x080014A0 },
    { (u8 *)0x100072B0, 0x080014A0 },
    { (u8 *)0x100072B8, 0x080018C0 },
    { (u8 *)0x100072C0, 0x080014A0 },
    { (u8 *)0x100072C8, 0x080014A0 },
    { (u8 *)0x100072D0, 0x080018C0 },
    { (u8 *)0x100072D8, 0x080014A0 },
    { (u8 *)0x100072E0, 0x080014C0 },
    { (u8 *)0x100072E8, 0x080014A0 },
    { (u8 *)0x100072F0, 0x080014A0 },
    { (u8 *)0x100072F8, 0x080014C0 },
    { (u8 *)0x10007300, 0x080014A0 },
    { (u8 *)0x10007308, 0x080018A0 },
    { (u8 *)0x10007310, 0x080018A0 },
    { (u8 *)0x10007318, 0x080018A0 },
    { (u8 *)0x10007320, 0x080014A0 },
    { (u8 *)0x10007328, 0x080014A0 },
    { (u8 *)0x10007330, 0x080014C0 },
    { (u8 *)0x10007338, 0x080030A5 },
    { (u8 *)0x10007340, 0x080030A5 },
    { (u8 *)0x10007348, 0x080030C6 },
    { (u8 *)0x10007350, 0x080030A5 },
    { (u8 *)0x10007358, 0x080030A5 },
    { (u8 *)0x10007360, 0x080030C6 },
    { (u8 *)0x10007368, 0x080030A5 },
    { (u8 *)0x10007370, 0x080030A5 },
    { (u8 *)0x10007378, 0x080030C6 },
    { (u8 *)0x10007380, 0x080030A5 },
    { (u8 *)0x10007388, 0x080030A5 },
    { (u8 *)0x10007390, 0x080030C6 },
    { (u8 *)0x10007398, 0x080030A5 },
    { (u8 *)0x100073A0, 0x080030A5 },
    { (u8 *)0x100073A8, 0x080030C6 },
    { (u8 *)0x100073B0, 0x080030A5 },
    { (u8 *)0x100073B8, 0x080030A5 },
    { (u8 *)0x100073C0, 0x080030C6 },
    { (u8 *)0x100073C8, 0x080030A5 },
    { (u8 *)0x100073D0, 0x080030A5 },
    { (u8 *)0x100073D8, 0x080030C6 },
    { (u8 *)0x100073E0, 0x080030A5 },
    { (u8 *)0x100073E8, 0x080030A5 },
    { (u8 *)0x100073F0, 0x080030C6 },
    { (u8 *)0x100073F8, 0x080030A5 },
    { (u8 *)0x10007400, 0x080030A5 },
    { (u8 *)0x10007408, 0x080030C6 },
    { (u8 *)0x10007410, 0x080030A5 },
    { (u8 *)0x1000741C, 0x080030A5 },
    { (u8 *)0x10007428, 0x080030C6 },
    { (u8 *)0x10007434, 0x080030A5 },
    { (u8 *)0x1000743C, 0x080030A5 },
    { (u8 *)0x10007444, 0x080030C6 },
    { (u8 *)0x1000744C, 0x080030A5 },
    { (u8 *)0x10007454, 0x080030A5 },
    { (u8 *)0x1000745C, 0x080030C6 },
    { (u8 *)0x10007464, 0x080030A5 },
    { (u8 *)0x1000746C, 0x080030A5 },
    { (u8 *)0x10007474, 0x080030C6 },
    { (u8 *)0x1000747C, 0x080030A5 },
    { (u8 *)0x10007484, 0x080030A5 },
    { (u8 *)0x1000748C, 0x080030C6 },
    { (u8 *)0x10007494, 0x080030A5 },
    { (u8 *)0x1000749C, 0x080030A5 },
    { (u8 *)0x100074A4, 0x080030C6 },
    { (u8 *)0x100074AC, 0x080030A5 },
    { (u8 *)0x100074B4, 0x080030A5 },
    { (u8 *)0x100074BC, 0x080030C6 },
    { (u8 *)0x100074C4, 0x042D0400 },
    { (u8 *)0x100074C8, 0x02000460 },
    { (u8 *)0x100074CC, 0x02000460 },
    { (u8 *)0x100074D0, 0x02000460 },
    { (u8 *)0x100074D8, 0x02000460 },
    { (u8 *)0x100074DC, 0x02000460 },
    { (u8 *)0x100074E0, 0x06298420 },
    { (u8 *)0x100074E8, 0x062A0420 },
    { (u8 *)0x100074F0, 0x062A8420 },
    { (u8 *)0x100074F8, 0x062B0420 },
    { (u8 *)0x10007500, 0x062B8420 },
    { (u8 *)0x10007508, 0x062C0420 },
    { (u8 *)0x1000750C, 0x062C8420 },
    { (u8 *)0x10007514, 0 },
    { (u8 *)0x10007518, 0x08000420 },
    { (u8 *)0x10007520, 0x0E258400 },
    { (u8 *)0x10007528, 0x0E260400 },
    { (u8 *)0x10007530, 0x080014A0 },
    { (u8 *)0x10007538, 0x080014A0 },
    { (u8 *)0x10007540, 0x080018C0 },
    { (u8 *)0x10007548, 0x084704E0 },
    { (u8 *)0x10007550, 0x084904E0 },
    { (u8 *)0x10007558, 0x0E1C0000 },
    { (u8 *)0x1000755C, 0x0E1C0400 },
    { (u8 *)0x10007564, 0x0E1B8400 },
    { (u8 *)0x1000756C, 0x084808A0 },
    { (u8 *)0x10007574, 0x084608A0 },
    { (u8 *)0x1000757C, 0x060014A1 },
    { (u8 *)0x10007588, 0x060014A1 },
    { (u8 *)0x10007594, 0x060018C1 },
    { (u8 *)0x100075A0, 0x060014A1 },
    { (u8 *)0x100075AC, 0x060014A1 },
    { (u8 *)0x100075B8, 0x060018C1 },
    { (u8 *)0x100075C4, 0x060A8421 },
    { (u8 *)0x100075CC, 0x060B8421 },
    { (u8 *)0x100075D4, 0x060014A1 },
    { (u8 *)0x100075E0, 0x060014A1 },
    { (u8 *)0x100075EC, 0x060018C1 },
    { (u8 *)0x100075F8, 0x060014A1 },
    { (u8 *)0x10007604, 0x060014A1 },
    { (u8 *)0x10007610, 0x060018C1 },
    { (u8 *)0x1000761C, 0x087A04E0 },
    { (u8 *)0x10007624, 0x087A84E0 },
    { (u8 *)0x1000762C, 0 },
    { (u8 *)0x10007630, 0x087B04E0 },
    { (u8 *)0x10007638, 0x087B84E0 },
    { (u8 *)0x10007640, 0 },
    { (u8 *)0x10007644, 0x167C2400 },
    { (u8 *)0x1000764C, 0x167CA800 },
    { (u8 *)0x10007654, 0x167D2C00 },
    { (u8 *)0x1000765C, 0x1A0F0420 },
    { (u8 *)0x10007660, 0x1A0F8420 },
    { (u8 *)0x10007668, 0x1A100420 },
    { (u8 *)0x1000766C, 0x1A108420 },
    { (u8 *)0x10007674, 0x1A110420 },
    { (u8 *)0x10007678, 0x1A118420 },
    { (u8 *)0x1000767C, 0x02390460 },
    { (u8 *)0x10007680, 0x023A8460 },
    { (u8 *)0x10007684, 0x060014A1 },
    { (u8 *)0x10007690, 0x060014A1 },
    { (u8 *)0x1000769C, 0x060018C1 },
    { (u8 *)0x100076A8, 0x060014A1 },
    { (u8 *)0x100076B4, 0x060014A1 },
    { (u8 *)0x100076C0, 0x060018C1 },
    { (u8 *)0x100076CC, 0x060014A1 },
    { (u8 *)0x100076D8, 0x060014A1 },
    { (u8 *)0x100076E4, 0x060018C1 },
    { (u8 *)0x100076F0, 0x060014A1 },
    { (u8 *)0x100076FC, 0x060014A1 },
    { (u8 *)0x10007708, 0x060018C1 },
    { (u8 *)0x10007714, 0x0C278420 },
    { (u8 *)0x1000771C, 0x0E278400 },
    { (u8 *)0x10007724, 0x0C280420 },
    { (u8 *)0x1000772C, 0x0E280400 },
    { (u8 *)0x10007734, 0x0C000420 },
    { (u8 *)0x1000773C, 0x0C000420 },
    { (u8 *)0x10007744, 0x0E288400 },
    { (u8 *)0x1000774C, 0x0C000420 },
    { (u8 *)0x10007754, 0x0C000420 },
    { (u8 *)0x1000775C, 0x0E290400 },
    { (u8 *)0x10007764, 0x0C000420 },
    { (u8 *)0x1000776C, 0x0C000420 },
    { (u8 *)0x10007774, 0x0E1F8400 },
    { (u8 *)0x1000777C, 0x0E208400 },
    { (u8 *)0x10007784, 0x0C000420 },
    { (u8 *)0x1000778C, 0x0C000420 },
    { (u8 *)0x10007794, 0x0E200400 },
    { (u8 *)0x1000779C, 0x0E210400 },
    { (u8 *)0x100077A4, 0x10218000 },
    { (u8 *)0x100077AC, 0x10220000 },
    { (u8 *)0x100077B4, 0x1022B000 },
    { (u8 *)0x100077BC, 0x10233000 },
    { (u8 *)0x100077C4, 0x10238000 },
    { (u8 *)0x100077CC, 0x10240000 },
    { (u8 *)0x100077D4, 0 },
    { (u8 *)0x100077D8, 0 },
    { (u8 *)0x100077DC, 0x023F8460 },
    { (u8 *)0x100077E0, 0x02400460 },
    { (u8 *)0x100077E4, 0x02408460 },
    { (u8 *)0x100077E8, 0x023C0460 },
    { (u8 *)0x100077EC, 0x02410460 },
    { (u8 *)0x100077F0, 0x02418460 },
    { (u8 *)0x100077F4, 0x02420460 },
    { (u8 *)0x100077F8, 0x06308420 },
    { (u8 *)0x10007800, 0x06310420 },
    { (u8 *)0x10007808, 0x06120421 },
    { (u8 *)0x10007810, 0x06128421 },
    { (u8 *)0x10007818, 0x06130421 },
    { (u8 *)0x10007820, 0x06138421 },
    { (u8 *)0x10007828, 0x06140421 },
    { (u8 *)0x10007830, 0x06148421 },
    { (u8 *)0x10007838, 0x06150421 },
    { (u8 *)0x10007840, 0x06170421 },
    { (u8 *)0x10007848, 0x06178421 },
    { (u8 *)0x10007850, 0x06180421 },
    { (u8 *)0x10007858, 0x08188420 },
    { (u8 *)0x10007860, 0x08190420 },
    { (u8 *)0x10007868, 0x06000421 },
    { (u8 *)0x10007870, 0x06000421 },
    { (u8 *)0x10007878, 0 },
    { (u8 *)0x1000787C, 0 },
    { (u8 *)0x10007880, 0x084C8480 },
    { (u8 *)0x10007888, 0x084D0480 },
    { (u8 *)0x10007890, 0x084D84E0 },
    { (u8 *)0x10007898, 0x084E04E0 },
    { (u8 *)0x100078A0, 0x084E84E0 },
    { (u8 *)0x100078A8, 0x084F04E0 },
    { (u8 *)0x100078B0, 0x1C000400 },
    { (u8 *)0x100078B4, 0x02000400 },
    { (u8 *)0x100078B8, 0x8D8000 },
    { (u8 *)0x100078C0, 0x06001081 },
    { (u8 *)0x100078CC, 0x06001081 },
    { (u8 *)0x100078D8, 0x06001081 },
    { (u8 *)0x100078E4, 0x06001081 },
    { (u8 *)0x100078F0, 0x06001081 },
    { (u8 *)0x100078FC, 0x06001081 },
    { (u8 *)0x10007908, 0x06001081 },
    { (u8 *)0x10007914, 0x06001081 },
    { (u8 *)0x10007920, 0x060010A1 },
    { (u8 *)0x1000792C, 0x060010A1 },
    { (u8 *)0x10007938, 0x060010A1 },
    { (u8 *)0x10007944, 0x060010A1 },
    { (u8 *)0x10007950, 0x08001080 },
    { (u8 *)0x10007958, 0x08001080 },
    { (u8 *)0x10007960, 0x080010A0 },
    { (u8 *)0x10007968, 0x08001080 },
    { (u8 *)0x10007970, 0x08001080 },
    { (u8 *)0x10007978, 0x08001080 },
    { (u8 *)0x10007980, 0x08001480 },
    { (u8 *)0x10007988, 0x08001080 },
    { (u8 *)0x10007990, 0x1E4F8460 },
    { (u8 *)0x10007998, 0x04000000 },
    { (u8 *)0x1000799C, 0x02000460 },
    { (u8 *)0x100079A0, 0x02000460 },
    { (u8 *)0x100079A4, 0x08000420 },
    { (u8 *)0x100079AC, 0x08000420 },
    { (u8 *)0x100079B4, 0x08000420 },
    { (u8 *)0x100079BC, 0x06000421 },
    { (u8 *)0x100079C4, 0x06000421 },
    { (u8 *)0x100079CC, 0x06000421 },
    { (u8 *)0x100079D4, 0x06000421 },
    { (u8 *)0x100079DC, 0x06000421 },
    { (u8 *)0x100079E4, 0x06000421 },
    { (u8 *)0x100079EC, 0x06000421 },
    { (u8 *)0x100079F4, 0x06128421 },
    { (u8 *)0x100079FC, 0x06138421 },
    { (u8 *)0x10007A04, 0x02000460 },
    { (u8 *)0x10007A0C, 0x0600042C },
    { (u8 *)0x10007A14, 0x0600042C },
    { (u8 *)0x10007A1C, 0x06000421 },
    { (u8 *)0x10007A24, 0x06000421 },
    { (u8 *)0x10007A2C, 0x20001084 },
    { (u8 *)0x10007A34, 0x20001084 },
    { (u8 *)0x10007A3C, 0x200018C6 },
    { (u8 *)0x10007A44, 0x20001084 },
    { (u8 *)0x10007A4C, 0x20001084 },
    { (u8 *)0x10007A54, 0x200018C6 },
    { (u8 *)0x10007A5C, 0x20001084 },
    { (u8 *)0x10007A64, 0x20001084 },
    { (u8 *)0x10007A6C, 0x200018C6 },
    { (u8 *)0x10007A74, 0x20001084 },
    { (u8 *)0x10007A7C, 0x20001084 },
    { (u8 *)0x10007A84, 0x200018C6 },
    { (u8 *)0x10007A8C, 0x08001080 },
    { (u8 *)0x10007A94, 0x08001080 },
    { (u8 *)0x10007A9C, 0x08001080 },
    { (u8 *)0x10007AA4, 0x08001080 },
    { (u8 *)0x10007AAC, 0x0600108C },
    { (u8 *)0x10007AB4, 0x0600108C },
    { (u8 *)0x10007ABC, 0x0600108C },
    { (u8 *)0x10007AC4, 0x0600108C },
    { (u8 *)0x10007ACC, 0x06001081 },
    { (u8 *)0x10007AD4, 0x06001081 },
    { (u8 *)0x10007ADC, 0x06001081 },
    { (u8 *)0x10007AE4, 0x06001081 },
    { (u8 *)0x10007AEC, 0x22001021 },
    { (u8 *)0x10007AF4, 0x22001021 },
    { (u8 *)0x10007AFC, 0x22001021 },
    { (u8 *)0x10007B04, 0x22001021 },
    { (u8 *)0x10007B0C, 0x22000421 },
    { (u8 *)0x10007B14, 0 },
    { (u8 *)0x10007B1C, 0 },
    { (u8 *)0x10007B24, 0 },
    { (u8 *)0x10007B2C, 0 },
    { (u8 *)0x10007B34, 0 },
    { (u8 *)0x10007B3C, 0x06140421 },
    { (u8 *)0x10007B44, 0x06148421 },
    { (u8 *)0x10007B4C, 0x06150421 },
    { (u8 *)0x10007B54, 0x109F8000 },
    { (u8 *)0x10007B5C, 0x10A00000 },
    { (u8 *)0x10007B64, 0x12A08000 },
    { (u8 *)0x10007B68, 0x02A10460 },
    { (u8 *)0x10007B70, 0x02A18460 },
    { (u8 *)0x10007B78, 0x08A204E0 },
    { (u8 *)0x10007B80, 0x08A284E0 },
    { (u8 *)0x10007B88, 0x08A304E0 },
    { (u8 *)0x10007B90, 0x08A384E0 },
    { (u8 *)0x10007B98, 0x06028421 },
    { (u8 *)0x10007BA0, 0x06030421 },
    { (u8 *)0x10007BA8, 0x06038421 },
    { (u8 *)0x10007BB0, 0x08A404E0 },
    { (u8 *)0x10007BB8, 0x08A404E0 },
    { (u8 *)0x10007BC0, 0x08A404E0 },
    { (u8 *)0x10007BC8, 0x08A404E0 },
    { (u8 *)0x10007BD0, 0 },
    { NULL, 0 },
};
static s32 map_glevel[4] = { 2, 1, 0, 3 };
static s32 D_10001090 = 0;
static s32 D_10001094 = 0;
static s32 D_10001098[5] = { 0x10007C20, 0x10007C2C, 0x10007C34, 0x10007C3C, 0x10007C44 };
static ? *opt_strings[0x6D] = {
    (? *)0x10007CBC,
    (? *)0x10007CC0,
    (? *)0x10007CC4,
    (? *)0x10007CC8,
    (? *)0x10007CCC,
    (? *)0x10007CD0,
    (? *)0x10007CD4,
    (? *)0x10007CD8,
    (? *)0x10007CDC,
    (? *)0x10007CE0,
    (? *)0x10007CE4,
    (? *)0x10007CE8,
    (? *)0x10007CEC,
    (? *)0x10007CF4,
    (? *)0x10007CF8,
    (? *)0x10007CFC,
    (? *)0x10007D00,
    (? *)0x10007D04,
    (? *)0x10007D0C,
    (? *)0x10007D10,
    (? *)0x10007D14,
    (? *)0x10007D18,
    (? *)0x10007D1C,
    (? *)0x10007D20,
    (? *)0x10007D24,
    (? *)0x10007D28,
    (? *)0x10007D2C,
    (? *)0x10007D30,
    (? *)0x10007D34,
    (? *)0x10007D38,
    (? *)0x10007D3C,
    (? *)0x10007D40,
    (? *)0x10007D44,
    (? *)0x10007D48,
    (? *)0x10007D4C,
    (? *)0x10007D50,
    (? *)0x10007D54,
    (? *)0x10007D58,
    (? *)0x10007D5C,
    (? *)0x10007D60,
    (? *)0x10007D64,
    (? *)0x10007D68,
    (? *)0x10007D6C,
    (? *)0x10007D70,
    (? *)0x10007D80,
    (? *)0x10007D90,
    (? *)0x10007DA4,
    (? *)0x10007DB8,
    (? *)0x10007DCC,
    (? *)0x10007DD4,
    (? *)0x10007DDC,
    (? *)0x10007DE4,
    (? *)0x10007DEC,
    (? *)0x10007DF4,
    (? *)0x10007DFC,
    (? *)0x10007E08,
    (? *)0x10007E14,
    (? *)0x10007E20,
    (? *)0x10007E30,
    (? *)0x10007E3C,
    (? *)0x10007E48,
    (? *)0x10007E50,
    (? *)0x10007E58,
    (? *)0x10007E60,
    (? *)0x10007E6C,
    (? *)0x10007E78,
    (? *)0x10007E80,
    (? *)0x10007E88,
    (? *)0x10007E94,
    (? *)0x10007EA0,
    (? *)0x10007EA8,
    (? *)0x10007EB4,
    (? *)0x10007EBC,
    (? *)0x10007EC8,
    (? *)0x10007ED0,
    (? *)0x10007EDC,
    (? *)0x10007EE4,
    (? *)0x10007EF4,
    (? *)0x10007F00,
    (? *)0x10007F08,
    (? *)0x10007F14,
    (? *)0x10007F1C,
    (? *)0x10007F24,
    (? *)0x10007F2C,
    (? *)0x10007F38,
    (? *)0x10007F40,
    (? *)0x10007F4C,
    (? *)0x10007F58,
    (? *)0x10007F60,
    (? *)0x10007F68,
    (? *)0x10007F70,
    (? *)0x10007F7C,
    (? *)0x10007F84,
    (? *)0x10007F8C,
    (? *)0x10007F94,
    (? *)0x10007FA0,
    (? *)0x10007FB0,
    (? *)0x10007FC4,
    (? *)0x10007FD0,
    (? *)0x10007FD8,
    (? *)0x10007FE4,
    (? *)0x10007FF8,
    (? *)0x10008000,
    (? *)0x10008008,
    (? *)0x10008010,
    (? *)0x1000801C,
    NULL,
    NULL,
    NULL,
};
static ? D_10001260;                                /* unable to generate initializer */
static ? D_1000129C;                                /* unable to generate initializer */
static ? D_100012D0;                                /* unable to generate initializer */
static ? D_10001310;                                /* unable to generate initializer */
static ? D_1000134C;                                /* unable to generate initializer */
static s32 __sgi_common_dummy_file = 0;
static u32 D_10001384 = 0;
static ? D_10001390;                                /* unable to generate initializer */
static ? D_100013CC;                                /* unable to generate initializer */
static ? D_10001400;                                /* unable to generate initializer */
static s8 D_1000143C = 0;
static s32 D_10001440 = 0;
static s32 st_errname = 0x100087FC;
static s16 stmagic = 0x7009;
static ? msg_werr;                                  /* unable to generate initializer */
static ? msg_err;                                   /* unable to generate initializer */
static ? *alloc_anchor[0xD78] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x403DF0,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x18,
    (? *)0x1D0000,
    (? *)0x20,
    NULL,
    NULL,
    (? *)0x403EF8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x3E,
    NULL,
    NULL,
    (? *)0x403F10,
    (? *)0x907F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x404008,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x404108,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4041A8,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x404234,
    (? *)0x90FF0000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x60,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x404A0C,
    (? *)0x90010000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x39,
    NULL,
    NULL,
    (? *)0x404B80,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405178,
    (? *)0x90010000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4054E8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405574,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4055D4,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4056DC,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405884,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4058F0,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405A80,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405B54,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405C28,
    (? *)0x900F0000,
    (? *)0xFFFFFFD4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x405DE4,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x406034,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4061F8,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x406340,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x406684,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x406728,
    (? *)0x90000000,
    (? *)0xFFFFFFD4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x406C48,
    (? *)0x90000000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x406FE8,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x407334,
    (? *)0x907F0000,
    (? *)0xFFFFFBE4,
    NULL,
    NULL,
    (? *)0x460,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4075CC,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4076A0,
    (? *)0x90000000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x407A20,
    (? *)0x90000000,
    (? *)0xFFFFFFCC,
    NULL,
    NULL,
    (? *)0x60,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40848C,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4085D8,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4086EC,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x48,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4088B8,
    (? *)0x90000000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x408C80,
    (? *)0x90010000,
    (? *)0xFFFFFFD4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x409118,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4092FC,
    (? *)0x90000000,
    (? *)0xFFFFFFCC,
    NULL,
    NULL,
    (? *)0x60,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x409850,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x409B10,
    (? *)0x90000000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x409ECC,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x409FD0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A044,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A0D4,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A160,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A208,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A280,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A4B0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A530,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A5D4,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A6B8,
    (? *)0x900F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A79C,
    (? *)0x90FF0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40A958,
    (? *)0x90FF0000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40AAD4,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40ADFC,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40AF00,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40B0F4,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40B340,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40B3DC,
    (? *)0x900F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0xD1,
    NULL,
    NULL,
    (? *)0x40B554,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40B5F0,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40B984,
    (? *)0x901F0000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40BC84,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40BEBC,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C048,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C218,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C2E0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C360,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C3E0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C460,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C4CC,
    (? *)0x90010000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C5E8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C66C,
    (? *)0x903F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C830,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C928,
    (? *)0x90010000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40C9D0,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40CC44,
    (? *)0x900F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40CCCC,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40CDE4,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40CEB4,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40CF9C,
    (? *)0x90FF0000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40D110,
    (? *)0x90FF0000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40D284,
    (? *)0x90010000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40D3EC,
    (? *)0x90000000,
    (? *)0xFFFFFBE4,
    NULL,
    NULL,
    (? *)0x438,
    (? *)0x1D001F,
    (? *)0xC7,
    NULL,
    NULL,
    (? *)0x40E180,
    (? *)0x90000000,
    (? *)0xFFFFFEFC,
    NULL,
    NULL,
    (? *)0x120,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40E1E0,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x198,
    NULL,
    NULL,
    (? *)0x40E230,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40E3F0,
    (? *)0x90010000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40E554,
    (? *)0x90010000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x48,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40E760,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40E7D0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x9D,
    NULL,
    NULL,
    (? *)0x40E814,
    (? *)0x90FF0000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x68,
    (? *)0x1D001F,
    (? *)0xDC,
    NULL,
    NULL,
    (? *)0x40EA24,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x110,
    NULL,
    NULL,
    (? *)0x40EA98,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x12C,
    NULL,
    NULL,
    (? *)0x40F180,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x2FD,
    NULL,
    NULL,
    (? *)0x40F188,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x307,
    NULL,
    NULL,
    (? *)0x40F1D0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x14A,
    NULL,
    NULL,
    (? *)0x40F234,
    (? *)0x90010000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x1E3,
    NULL,
    NULL,
    (? *)0x40F514,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x31E,
    NULL,
    NULL,
    (? *)0x40F580,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0xAC,
    NULL,
    NULL,
    (? *)0x40F5D8,
    (? *)0x903F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40F77C,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40F868,
    (? *)0x90010000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x46,
    NULL,
    NULL,
    (? *)0x40F9CC,
    (? *)0x90030000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0xF8,
    NULL,
    NULL,
    (? *)0x40FA7C,
    (? *)0x90030000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x1DA,
    NULL,
    NULL,
    (? *)0x40FB2C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40FBBC,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x343,
    NULL,
    NULL,
    (? *)0x40FC20,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x48,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x40FD98,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4100C8,
    (? *)0x90070000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4101AC,
    (? *)0x90070000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x410270,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4102F4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x34B,
    NULL,
    NULL,
    (? *)0x410380,
    (? *)0x903F0000,
    (? *)0xFFFFFFCC,
    NULL,
    NULL,
    (? *)0x68,
    (? *)0x1D001F,
    (? *)0x11A,
    NULL,
    NULL,
    (? *)0x410E80,
    (? *)0x907F0000,
    (? *)0xFFFFFBE4,
    NULL,
    NULL,
    (? *)0x450,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x41125C,
    (? *)0x900F0000,
    (? *)0xFFFFFBBC,
    NULL,
    NULL,
    (? *)0x470,
    (? *)0x1D001F,
    (? *)0xBC,
    NULL,
    NULL,
    (? *)0x411530,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x4B,
    NULL,
    NULL,
    (? *)0x4115A8,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0xFF,
    NULL,
    NULL,
    (? *)0x411630,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x155,
    NULL,
    NULL,
    (? *)0x411778,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x170,
    NULL,
    NULL,
    (? *)0x411898,
    (? *)0x90000000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x411B84,
    (? *)0x90000000,
    (? *)0xFFFFFFD4,
    NULL,
    NULL,
    (? *)0x48,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x411ECC,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x41213C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x412144,
    (? *)0x90070000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x41244C,
    (? *)0x903F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x412548,
    (? *)0x900F0000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x412698,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x124,
    NULL,
    NULL,
    (? *)0x412794,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x165,
    NULL,
    NULL,
    (? *)0x412904,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x183,
    NULL,
    NULL,
    (? *)0x412A54,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x137,
    NULL,
    NULL,
    (? *)0x412AF0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x13F,
    NULL,
    NULL,
    (? *)0x412B84,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x8E,
    NULL,
    NULL,
    (? *)0x412CB0,
    (? *)0x90000000,
    (? *)0xFFFFFF6C,
    NULL,
    NULL,
    (? *)0xB0,
    (? *)0x1D001F,
    (? *)0x3A8,
    NULL,
    NULL,
    (? *)0x412D18,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x319,
    NULL,
    NULL,
    (? *)0x412D58,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x3B7,
    NULL,
    NULL,
    (? *)0x412E28,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x3C0,
    NULL,
    NULL,
    (? *)0x412EE0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x3CB,
    NULL,
    NULL,
    (? *)0x412F24,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x3D7,
    NULL,
    NULL,
    (? *)0x412F70,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x3E3,
    NULL,
    NULL,
    (? *)0x413040,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x3EF,
    NULL,
    NULL,
    (? *)0x413048,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x3F6,
    NULL,
    NULL,
    (? *)0x413050,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x3FD,
    NULL,
    NULL,
    (? *)0x413060,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x413224,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x4132C8,
    (? *)0x90000000,
    (? *)0xFFFFFBFC,
    NULL,
    NULL,
    (? *)0x420,
    (? *)0x1D001F,
    (? *)0x1C7,
    NULL,
    NULL,
    (? *)0x413320,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x82,
    NULL,
    NULL,
    (? *)0x413388,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x1BD,
    NULL,
    NULL,
    (? *)0x4133DC,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x72,
    NULL,
    NULL,
    (? *)0x413548,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x1FC,
    NULL,
    NULL,
    (? *)0x4135B0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0xE7,
    NULL,
    NULL,
    (? *)0x413670,
    (? *)0x900F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x59,
    NULL,
    NULL,
    (? *)0x4136F8,
    (? *)0x90010000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x396,
    NULL,
    NULL,
    (? *)0x413870,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x27B,
    NULL,
    NULL,
    (? *)0x4138F0,
    (? *)0x90010000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x2CC,
    NULL,
    NULL,
    (? *)0x413B00,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x21D,
    NULL,
    NULL,
    (? *)0x413B88,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x2BA,
    NULL,
    NULL,
    (? *)0x413CF8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x212,
    NULL,
    NULL,
    (? *)0x413D90,
    (? *)0x90010000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x252,
    NULL,
    NULL,
    (? *)0x413FDC,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x476,
    NULL,
    NULL,
    (? *)0x414088,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x464,
    NULL,
    NULL,
    (? *)0x414148,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x482,
    NULL,
    NULL,
    (? *)0x41428C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x493,
    NULL,
    NULL,
    (? *)0x414394,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x4A0,
    NULL,
    NULL,
    (? *)0x414468,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x4C1,
    NULL,
    NULL,
    (? *)0x414540,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x434,
    NULL,
    NULL,
    (? *)0x414600,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x427,
    NULL,
    NULL,
    (? *)0x4146C0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x4AF,
    NULL,
    NULL,
    (? *)0x41470C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x4D1,
    NULL,
    NULL,
    (? *)0x4147E4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x4E0,
    NULL,
    NULL,
    (? *)0x41480C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x452,
    NULL,
    NULL,
    (? *)0x414860,
    (? *)0x90030000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x444,
    NULL,
    NULL,
    (? *)0x4149C0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x4F7,
    NULL,
    NULL,
    (? *)0x4149E8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x505,
    NULL,
    NULL,
    (? *)0x414A74,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x512,
    NULL,
    NULL,
    (? *)0x414AB8,
    (? *)0x90070000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x325,
    NULL,
    NULL,
    (? *)0x414DA4,
    (? *)0x901F0000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x48,
    (? *)0x1D001F,
    (? *)0x29C,
    NULL,
    NULL,
    (? *)0x414F80,
    (? *)0x90000000,
    (? *)0xFFFFFFD4,
    NULL,
    NULL,
    (? *)0x50,
    (? *)0x1D001F,
    (? *)0x551,
    NULL,
    NULL,
    (? *)0x415130,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x566,
    NULL,
    NULL,
    (? *)0x41523C,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x573,
    NULL,
    NULL,
    (? *)0x415394,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x586,
    NULL,
    NULL,
    (? *)0x4154E4,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x594,
    NULL,
    NULL,
    (? *)0x4156A0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x5A0,
    NULL,
    NULL,
    (? *)0x4156CC,
    (? *)0x90010000,
    (? *)0xFFFFFFCC,
    NULL,
    NULL,
    (? *)0x58,
    (? *)0x1D001F,
    (? *)0x1A6,
    NULL,
    NULL,
    (? *)0x415948,
    (? *)0x90010000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x2E3,
    NULL,
    NULL,
    (? *)0x415B78,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x207,
    NULL,
    NULL,
    (? *)0x415C64,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x404,
    NULL,
    NULL,
    (? *)0x415CFC,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x5C5,
    NULL,
    NULL,
    (? *)0x415DA8,
    (? *)0xD0FF0000,
    (? *)0xFFFFFFD4,
    NULL,
    NULL,
    (? *)0x68,
    (? *)0x1D001F,
    (? *)0x5D4,
    NULL,
    NULL,
    (? *)0x415FE4,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x5F8,
    NULL,
    NULL,
    (? *)0x4160A4,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x607,
    NULL,
    NULL,
    (? *)0x416124,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x2F0,
    NULL,
    NULL,
    (? *)0x4161B0,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x61C,
    NULL,
    NULL,
    (? *)0x416240,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x626,
    NULL,
    NULL,
    (? *)0x416290,
    (? *)0x900F0000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x632,
    NULL,
    NULL,
    (? *)0x416444,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x63E,
    NULL,
    NULL,
    (? *)0x416564,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x64D,
    NULL,
    NULL,
    (? *)0x416620,
    (? *)0x90070000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x5B6,
    NULL,
    NULL,
    (? *)0x416948,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x662,
    NULL,
    NULL,
    (? *)0x41698C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x66F,
    NULL,
    NULL,
    (? *)0x416A98,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x678,
    NULL,
    NULL,
    (? *)0x416BA0,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x246,
    NULL,
    NULL,
    (? *)0x416C10,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x22A,
    NULL,
    NULL,
    (? *)0x416C48,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x689,
    NULL,
    NULL,
    (? *)0x416CDC,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x697,
    NULL,
    NULL,
    (? *)0x416D30,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x6A4,
    NULL,
    NULL,
    (? *)0x416D78,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x6B6,
    NULL,
    NULL,
    (? *)0x416DC4,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x238,
    NULL,
    NULL,
    (? *)0x416E18,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x52B,
    NULL,
    NULL,
    (? *)0x416E40,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x535,
    NULL,
    NULL,
    (? *)0x416EC8,
    (? *)0x90000000,
    (? *)0xFFFFFF2C,
    NULL,
    NULL,
    (? *)0xF0,
    (? *)0x1D001F,
    (? *)0x53E,
    NULL,
    NULL,
    (? *)0x4175D4,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x658,
    NULL,
    NULL,
    (? *)0x417754,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x613,
    NULL,
    NULL,
    (? *)0x417934,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x6F7,
    NULL,
    NULL,
    (? *)0x417AB0,
    (? *)0x90070000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x25C,
    NULL,
    NULL,
    (? *)0x417C70,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x702,
    NULL,
    NULL,
    (? *)0x417C98,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x70C,
    NULL,
    NULL,
    (? *)0x417CB0,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x5E7,
    NULL,
    NULL,
    (? *)0x417DBC,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x71A,
    NULL,
    NULL,
    (? *)0x417EC8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x72D,
    NULL,
    NULL,
    (? *)0x417FA0,
    (? *)0x90030000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x547,
    NULL,
    NULL,
    (? *)0x418104,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x738,
    NULL,
    NULL,
    (? *)0x41811C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x28C,
    NULL,
    NULL,
    (? *)0x41813C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x743,
    NULL,
    NULL,
    (? *)0x4184E8,
    (? *)0x90070000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x2D6,
    NULL,
    NULL,
    (? *)0x41861C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x266,
    NULL,
    NULL,
    (? *)0x418668,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x55C,
    NULL,
    NULL,
    (? *)0x4187A8,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x74B,
    NULL,
    NULL,
    (? *)0x4188F0,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x757,
    NULL,
    NULL,
    (? *)0x418A1C,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x5AC,
    NULL,
    NULL,
    (? *)0x418AD8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x763,
    NULL,
    NULL,
    (? *)0x418BA0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x76E,
    NULL,
    NULL,
    (? *)0x418BC8,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x779,
    NULL,
    NULL,
    (? *)0x418C84,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x787,
    NULL,
    NULL,
    (? *)0x418D18,
    (? *)0x900F0000,
    (? *)0xFFFFFF14,
    NULL,
    NULL,
    (? *)0x120,
    (? *)0x1D001F,
    (? *)0x79A,
    NULL,
    NULL,
    (? *)0x419E30,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    NULL,
    NULL,
    NULL,
    (? *)0x419F0C,
    (? *)0x90000000,
    (? *)0xFFFFFFF4,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x2AB,
    NULL,
    NULL,
    (? *)0x419FA0,
    (? *)0xD0FF0000,
    (? *)0xFFFFFE64,
    NULL,
    NULL,
    (? *)0x1D8,
    (? *)0x1D001F,
    (? *)0x805,
    NULL,
    NULL,
    (? *)0x41AFA4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x822,
    NULL,
    NULL,
    (? *)0x41AFC4,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)8,
    (? *)0x1D001F,
    (? *)0x6C6,
    NULL,
    NULL,
    (? *)0x41AFF4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x830,
    NULL,
    NULL,
    (? *)0x41B0D8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x83D,
    NULL,
    NULL,
    (? *)0x41B350,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x84A,
    NULL,
    NULL,
    (? *)0x41B4B8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x856,
    NULL,
    NULL,
    (? *)0x41B624,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x7B5,
    NULL,
    NULL,
    (? *)0x41BA54,
    (? *)0x903F0000,
    (? *)0xFFFFFFA4,
    NULL,
    NULL,
    (? *)0x90,
    (? *)0x1D001F,
    (? *)0x7E4,
    NULL,
    NULL,
    (? *)0x41C050,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x7EC,
    NULL,
    NULL,
    (? *)0x41C184,
    (? *)0x90030000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x7D2,
    NULL,
    NULL,
    (? *)0x41C41C,
    (? *)0x90030000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x48,
    (? *)0x1D001F,
    (? *)0x7F4,
    NULL,
    NULL,
    (? *)0x41C830,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x7CA,
    NULL,
    NULL,
    (? *)0x41CA9C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x7FD,
    NULL,
    NULL,
    (? *)0x41CBE8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x862,
    NULL,
    NULL,
    (? *)0x41CDA0,
    (? *)0x90030000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x7DB,
    NULL,
    NULL,
    (? *)0x41D030,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x86B,
    NULL,
    NULL,
    (? *)0x41D29C,
    (? *)0x90030000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x874,
    NULL,
    NULL,
    (? *)0x41D4C0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x87F,
    NULL,
    NULL,
    (? *)0x41D53C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x88B,
    NULL,
    NULL,
    (? *)0x41D5BC,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x894,
    NULL,
    NULL,
    (? *)0x41D64C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8A1,
    NULL,
    NULL,
    (? *)0x41D6B0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8AE,
    NULL,
    NULL,
    (? *)0x41D7C8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8BB,
    NULL,
    NULL,
    (? *)0x41D86C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8C7,
    NULL,
    NULL,
    (? *)0x41D8A4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8D5,
    NULL,
    NULL,
    (? *)0x41D8DC,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8DE,
    NULL,
    NULL,
    (? *)0x41D9C4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8EB,
    NULL,
    NULL,
    (? *)0x41DA28,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8F5,
    NULL,
    NULL,
    (? *)0x41DBB0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x8FF,
    NULL,
    NULL,
    (? *)0x41DD18,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x909,
    NULL,
    NULL,
    (? *)0x41DEE4,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x7BE,
    NULL,
    NULL,
    (? *)0x41E2A4,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x417,
    NULL,
    NULL,
    (? *)0x41E2D8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x920,
    NULL,
    NULL,
    (? *)0x41E2EC,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x926,
    NULL,
    NULL,
    (? *)0x41E5CC,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x40F,
    NULL,
    NULL,
    (? *)0x41E5E8,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x934,
    NULL,
    NULL,
    (? *)0x41E764,
    (? *)0x90000000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x96B,
    NULL,
    NULL,
    (? *)0x41E81C,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x1D001F,
    (? *)0x976,
    NULL,
    NULL,
    (? *)0x41E850,
    (? *)0x90000000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x20,
    (? *)0x1D001F,
    (? *)0x981,
    NULL,
    NULL,
    (? *)0x41E8E8,
    (? *)0x90000000,
    (? *)0xFFFFFFDC,
    NULL,
    NULL,
    (? *)0x40,
    (? *)0x1D001F,
    (? *)0x94D,
    NULL,
    NULL,
    (? *)0x41E9FC,
    (? *)0x90030000,
    (? *)0xFFFFFFFC,
    NULL,
    NULL,
    (? *)0x28,
    (? *)0x1D001F,
    (? *)0x958,
    NULL,
    NULL,
    (? *)0x41EAD4,
    (? *)0x90000000,
    (? *)0xFFFFFFE4,
    NULL,
    NULL,
    (? *)0x38,
    (? *)0x1D001F,
    (? *)0x93E,
    NULL,
    NULL,
    (? *)0x41EBC8,
    (? *)0x90010000,
    (? *)0xFFFFFFEC,
    NULL,
    NULL,
    (? *)0x30,
    (? *)0x1D001F,
    (? *)0x913,
    NULL,
    NULL,
    (? *)0xFFFFFFFF,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (? *)0x73746174,
    (? *)0x69632070,
    (? *)0x726F6365,
    (? *)0x64757265,
    (? *)0x20286E6F,
    (? *)0x206E616D,
    (? *)0x65290065,
    (? *)0x78697400,
    (? *)0x5F5F7374,
    (? *)0x61727400,
    (? *)0x5F5F7265,
    (? *)0x6164656E,
    (? *)0x765F7369,
    (? *)0x67667065,
    (? *)0x6D6169,
    (? *)0x6E005F6D,
    (? *)0x636F756E,
    (? *)0x74006861,
    (? *)0x73680061,
    (? *)0x6C6C6F63,
    (? *)0x5F6E6577,
    (? *)0x5F73796D,
    (? *)0x776869,
    (? *)0x63685F6F,
    (? *)0x70740066,
    (? *)0x7072696E,
    (? *)0x74660066,
    (? *)0x666C7573,
    (? *)0x6800706F,
    (? *)0x73746572,
    (? *)0x726F7200,
    (? *)0x666F7065,
    (? *)0x6E006361,
    (? *)0x6C6C5F70,
    (? *)0x6572726F,
    (? *)0x72007075,
    (? *)0x745F6269,
    (? *)0x6E61736D,
    (? *)0x66796C65,
    (? *)0x73796D,
    (? *)0x5F696E69,
    (? *)0x74006667,
    (? *)0x65746300,
    (? *)0x6D616B65,
    (? *)0x5F66696C,
    (? *)0x65006673,
    (? *)0x65656B00,
    (? *)0x72656164,
    (? *)0x696E6C69,
    (? *)0x6E650050,
    (? *)0x61727365,
    (? *)0x73746D74,
    (? *)0x646F5F,
    (? *)0x646F745F,
    (? *)0x656E6400,
    (? *)0x73796D5F,
    (? *)0x66696E69,
    (? *)0x73680061,
    (? *)0x73736572,
    (? *)0x74696F6E,
    (? *)0x5F666169,
    (? *)0x6C656400,
    (? *)0x4C6F6F6B,
    (? *)0x55700061,
    (? *)0x6C6C6F63,
    (? *)0x5F6E6577,
    (? *)0x5F737472,
    (? *)0x696E6700,
    (? *)0x73796D5F,
    (? *)0x656E7465,
    (? *)0x72006E65,
    (? *)0x7874746F,
    (? *)0x6B656E00,
    (? *)0x47657445,
    (? *)0x78707200,
    (? *)0x73796D5F,
    (? *)0x64656669,
    (? *)0x6E650047,
    (? *)0x65744974,
    (? *)0x656D0064,
    (? *)0x775F4765,
    (? *)0x74497465,
    (? *)0x6D006865,
    (? *)0x785F746F,
    (? *)0x5F6E756D,
    (? *)0x456E74,
    (? *)0x65725379,
    (? *)0x6D007374,
    (? *)0x726C656E,
    (? *)0x64775F,
    (? *)0x47657445,
    (? *)0x78707200,
    (? *)0x47657452,
    (? *)0x65676973,
    (? *)0x74657200,
    (? *)0x73747263,
    (? *)0x6D700047,
    (? *)0x65744261,
    (? *)0x73654F72,
    (? *)0x45787072,
    (? *)0x737472,
    (? *)0x63707900,
    (? *)0x73796D5F,
    (? *)0x756E6465,
    (? *)0x66696E65,
    (? *)0x64007374,
    (? *)0x5F70726F,
    (? *)0x63656E64,
    (? *)0x667265,
    (? *)0x65006D61,
    (? *)0x6C6C6F63,
    (? *)0x6E6577,
    (? *)0x5F657272,
    (? *)0x6F720063,
    (? *)0x616C6C5F,
    (? *)0x6E616D65,
    (? *)0x5F616E64,
    (? *)0x5F6C696E,
    (? *)0x65006F70,
    (? *)0x4C6F6F6B,
    (? *)0x5570006D,
    (? *)0x616B655F,
    (? *)0x6C6F6361,
    (? *)0x6C5F6C61,
    (? *)0x62656C00,
    (? *)0x73707269,
    (? *)0x6E746600,
    (? *)0x706F7374,
    (? *)0x63657272,
    (? *)0x6F720073,
    (? *)0x745F7379,
    (? *)0x6D5F6964,
    (? *)0x6E007374,
    (? *)0x5F70646E,
    (? *)0x5F69646E,
    (? *)0x73745F,
    (? *)0x70657874,
    (? *)0x5F696578,
    (? *)0x74007374,
    (? *)0x5F617578,
    (? *)0x6973796D,
    (? *)0x61646400,
    (? *)0x73745F63,
    (? *)0x75727265,
    (? *)0x6E746966,
    (? *)0x64007374,
    (? *)0x5F617578,
    (? *)0x62746164,
    (? *)0x64007374,
    (? *)0x5F73796D,
    (? *)0x61646400,
    (? *)0x73745F73,
    (? *)0x74726164,
    (? *)0x64007374,
    (? *)0x5F737472,
    (? *)0x5F657874,
    (? *)0x69737300,
    (? *)0x70657272,
    (? *)0x6F720073,
    (? *)0x745F6375,
    (? *)0x696E6974,
    (? *)0x737472,
    (? *)0x63617400,
    (? *)0x73745F63,
    (? *)0x75727265,
    (? *)0x6E747063,
    (? *)0x68647200,
    (? *)0x73745F65,
    (? *)0x6E64616C,
    (? *)0x6C66696C,
    (? *)0x65730073,
    (? *)0x745F7772,
    (? *)0x69746562,
    (? *)0x696E6172,
    (? *)0x79007374,
    (? *)0x5F69646E,
    (? *)0x5F696E64,
    (? *)0x65785F66,
    (? *)0x65787400,
    (? *)0x73745F65,
    (? *)0x78746164,
    (? *)0x64007374,
    (? *)0x5F657874,
    (? *)0x73747261,
    (? *)0x64640073,
    (? *)0x745F7072,
    (? *)0x6F636265,
    (? *)0x67696E00,
    (? *)0x73745F70,
    (? *)0x64616464,
    (? *)0x5F69646E,
    (? *)0x73745F,
    (? *)0x6665696E,
    (? *)0x69740069,
    (? *)0x746F6100,
    (? *)0x746F6C6F,
    (? *)0x77657200,
    (? *)0x61746F6C,
    (? *)0x6C746F,
    (? *)0x6100756E,
    (? *)0x7363616E,
    (? *)0x73745F,
    (? *)0x66696C65,
    (? *)0x62656769,
    (? *)0x6E007374,
    (? *)0x72746F75,
    (? *)0x6C6C0073,
    (? *)0x7472746F,
    (? *)0x6C6C0063,
    (? *)0x6F6E7375,
    (? *)0x6D650064,
    (? *)0x6F745F73,
    (? *)0x6F6F6E00,
    (? *)0x6D656D63,
    (? *)0x7079006D,
    (? *)0x656D7365,
    (? *)0x74005F5F,
    (? *)0x6C6C5F6D,
    (? *)0x756C005F,
    (? *)0x5F6C6C5F,
    (? *)0x64697600,
    (? *)0x5F5F6C6C,
    (? *)0x5F72656D,
    (? *)0x5F5F6C,
    (? *)0x6C5F6C73,
    (? *)0x68696674,
    (? *)0x5F5F75,
    (? *)0x6C6C5F72,
    (? *)0x73686966,
    (? *)0x74006772,
    (? *)0x6F775F61,
    (? *)0x72726179,
    (? *)0x667772,
    (? *)0x69746500,
    (? *)0x66696C65,
    (? *)0x73697A65,
    (? *)0x667374,
    (? *)0x61740073,
    (? *)0x745F6572,
    (? *)0x726F7200,
    (? *)0x73745F77,
    (? *)0x61726E69,
    (? *)0x6E670073,
    (? *)0x745F7072,
    (? *)0x696E7466,
    (? *)0x5F320073,
    (? *)0x745F7072,
    (? *)0x696E7466,
    (? *)0x5F330073,
    (? *)0x745F696E,
    (? *)0x7465726E,
    (? *)0x616C006C,
    (? *)0x5F616464,
    (? *)0x7200655F,
    (? *)0x61646472,
    (? *)0x735F61,
    (? *)0x64647200,
    (? *)0x73745F73,
    (? *)0x74725F69,
    (? *)0x646E0078,
    (? *)0x6D616C6C,
    (? *)0x6F630078,
    (? *)0x7265616C,
    (? *)0x6C6F6300,
    (? *)0x63616C6C,
    (? *)0x6F63005F,
    (? *)0x6D645F73,
    (? *)0x745F6572,
    (? *)0x726F7200,
    (? *)0x5F6D645F,
    (? *)0x73745F69,
    (? *)0x6E746572,
    (? *)0x6E616C00,
    (? *)0x5F6D645F,
    (? *)0x73745F6D,
    (? *)0x616C6C6F,
    (? *)0x63005F6D,
    (? *)0x645F7374,
    (? *)0x5F637572,
    (? *)0x72656E74,
    (? *)0x69666400,
    (? *)0x73745F70,
    (? *)0x6366645F,
    (? *)0x69666400,
    (? *)0x627A6572,
    (? *)0x6F007374,
    (? *)0x5F696664,
    (? *)0x5F706366,
    (? *)0x64007374,
    (? *)0x5F707379,
    (? *)0x6D5F6966,
    (? *)0x645F6973,
    (? *)0x796D0073,
    (? *)0x745F7061,
    (? *)0x75785F69,
    (? *)0x61757800,
    (? *)0x73745F73,
    (? *)0x74725F69,
    (? *)0x66645F69,
    (? *)0x7373005F,
    (? *)0x6D645F73,
    (? *)0x745F7374,
    (? *)0x725F6578,
    (? *)0x74697373,
    (? *)0x73745F,
    (? *)0x7070645F,
    (? *)0x6966645F,
    (? *)0x6973796D,
    (? *)0x5F6D64,
    (? *)0x5F73745F,
    (? *)0x7374725F,
    (? *)0x69737300,
    (? *)0x5F6D645F,
    (? *)0x73745F69,
    (? *)0x6578746D,
    (? *)0x61780072,
    (? *)0x65616C6C,
    (? *)0x6F63005F,
    (? *)0x6D645F73,
    (? *)0x745F6966,
    (? *)0x646D6178,
    (? *)0x5F6D64,
    (? *)0x5F73745F,
    (? *)0x73657466,
    (? *)0x64005F5F,
    (? *)0x7367695F,
    (? *)0x6D6C645F,
    (? *)0x73745F63,
    (? *)0x6F6D6D6F,
    (? *)0x6E626567,
    (? *)0x696E0073,
    (? *)0x745F6966,
    (? *)0x646D6178,
    (? *)0x73745F,
    (? *)0x73657466,
    (? *)0x64007374,
    (? *)0x5F666461,
    (? *)0x64640073,
    (? *)0x745F6D61,
    (? *)0x6C6C6F63,
    (? *)0x73745F,
    (? *)0x66696C65,
    (? *)0x656E6400,
    (? *)0x73745F69,
    (? *)0x646E5F64,
    (? *)0x6E007374,
    (? *)0x5F746578,
    (? *)0x74626C6F,
    (? *)0x636B005F,
    (? *)0x7367695F,
    (? *)0x73745F62,
    (? *)0x6C6F636B,
    (? *)0x62656769,
    (? *)0x6E007374,
    (? *)0x5F626C6F,
    (? *)0x636B6265,
    (? *)0x67696E00,
    (? *)0x73745F62,
    (? *)0x6C6F636B,
    (? *)0x656E6400,
    (? *)0x73745F62,
    (? *)0x6C6F636B,
    (? *)0x706F7000,
    (? *)0x73745F73,
    (? *)0x65746964,
    (? *)0x6E007374,
    (? *)0x5F696175,
    (? *)0x785F636F,
    (? *)0x70797479,
    (? *)0x73745F,
    (? *)0x66676C6F,
    (? *)0x62616C5F,
    (? *)0x69646E00,
    (? *)0x73745F70,
    (? *)0x73796D5F,
    (? *)0x69646E5F,
    (? *)0x6F666673,
    (? *)0x65740073,
    (? *)0x745F7061,
    (? *)0x75785F69,
    (? *)0x66645F69,
    (? *)0x61757800,
    (? *)0x73745F66,
    (? *)0x69786578,
    (? *)0x74696E64,
    (? *)0x65780073,
    (? *)0x745F6669,
    (? *)0x78657874,
    (? *)0x73630073,
    (? *)0x745F7064,
    (? *)0x61646400,
    (? *)0x73745F66,
    (? *)0x69786973,
    (? *)0x73007374,
    (? *)0x5F636861,
    (? *)0x6E676564,
    (? *)0x6E007374,
    (? *)0x5F66696C,
    (? *)0x655F6964,
    (? *)0x6E007374,
    (? *)0x5F747168,
    (? *)0x6967685F,
    (? *)0x69617578,
    (? *)0x73745F,
    (? *)0x73686966,
    (? *)0x74747100,
    (? *)0x73745F61,
    (? *)0x75786164,
    (? *)0x64007374,
    (? *)0x5F636861,
    (? *)0x6E676561,
    (? *)0x75780073,
    (? *)0x745F6164,
    (? *)0x64747100,
    (? *)0x73745F63,
    (? *)0x68616E67,
    (? *)0x65617578,
    (? *)0x726E6478,
    (? *)0x73745F,
    (? *)0x61757872,
    (? *)0x6E647861,
    (? *)0x64640073,
    (? *)0x745F6175,
    (? *)0x78627473,
    (? *)0x697A6500,
    (? *)0x73745F61,
    (? *)0x7578726E,
    (? *)0x64786164,
    (? *)0x645F6964,
    (? *)0x6E007374,
    (? *)0x5F616464,
    (? *)0x636F6E74,
    (? *)0x696E7565,
    (? *)0x64006765,
    (? *)0x74686F73,
    (? *)0x74736578,
    (? *)0x676574,
    (? *)0x686F7374,
    (? *)0x6E616D65,
    (? *)0x706174,
    (? *)0x68636F6E,
    (? *)0x66006765,
    (? *)0x74637764,
    (? *)0x74696D,
    (? *)0x65007374,
    (? *)0x61740073,
    (? *)0x745F6C69,
    (? *)0x6E656164,
    (? *)0x64007374,
    (? *)0x5F6E6F6E,
    (? *)0x5F677000,
    (? *)0x73745F73,
    (? *)0x65745F6E,
    (? *)0x6F6E5F67,
    (? *)0x70007374,
    (? *)0x5F706C69,
    (? *)0x6E655F69,
    (? *)0x66645F69,
    (? *)0x6C696E65,
    (? *)0x73745F,
    (? *)0x7374725F,
    (? *)0x69737300,
    (? *)0x73745F73,
    (? *)0x65746368,
    (? *)0x64720073,
    (? *)0x745F6672,
    (? *)0x65650073,
    (? *)0x745F6964,
    (? *)0x6E5F726E,
    (? *)0x64780073,
    (? *)0x745F726E,
    (? *)0x64785F69,
    (? *)0x646E0073,
    (? *)0x745F7065,
    (? *)0x78745F64,
    (? *)0x6E007374,
    (? *)0x5F696578,
    (? *)0x746D6178,
    (? *)0x73745F,
    (? *)0x7365746D,
    (? *)0x73676E61,
    (? *)0x6D650073,
    (? *)0x745F7265,
    (? *)0x61646269,
    (? *)0x6E617279,
    (? *)0x6F7065,
    (? *)0x6E007374,
    (? *)0x5F726561,
    (? *)0x64737400,
    (? *)0x636C6F73,
    (? *)0x65006C73,
    (? *)0x65656B00,
    (? *)0x72656164,
    (? *)0x737761,
    (? *)0x705F6864,
    (? *)0x72006C64,
    (? *)0x6673796D,
    (? *)0x6F726465,
    (? *)0x72007377,
    (? *)0x61705F70,
    (? *)0x64007377,
    (? *)0x61705F73,
    (? *)0x796D0073,
    (? *)0x7761705F,
    (? *)0x6F707400,
    (? *)0x73776170,
    (? *)0x5F666400,
    (? *)0x73776170,
    (? *)0x5F666900,
    (? *)0x73776170,
    (? *)0x5F657874,
    (? *)0x737761,
    (? *)0x705F646E,
    (? *)0x73745F,
    (? *)0x77726974,
    (? *)0x65737400,
    (? *)0x66646F70,
    (? *)0x656E0064,
    (? *)0x75700066,
    (? *)0x636C6F73,
    (? *)0x65007374,
    (? *)0x5F736574,
    (? *)0x73746D61,
    (? *)0x67696300,
    (? *)0x73776170,
    (? *)0x5F66696C,
    (? *)0x65686472,
    (? *)0x737761,
    (? *)0x705F616F,
    (? *)0x75746864,
    (? *)0x72007377,
    (? *)0x61705F73,
    (? *)0x636E6864,
    (? *)0x72007377,
    (? *)0x61705F6C,
    (? *)0x69627363,
    (? *)0x6E007377,
    (? *)0x61705F72,
    (? *)0x70640073,
    (? *)0x7761705F,
    (? *)0x61757800,
    (? *)0x73776170,
    (? *)0x5F72656C,
    (? *)0x6F630073,
    (? *)0x7761705F,
    (? *)0x72616E6C,
    (? *)0x69620073,
    (? *)0x7761705F,
    (? *)0x67707400,
    (? *)0x73776170,
    (? *)0x5F64796E,
    (? *)0x616D6963,
    (? *)0x737761,
    (? *)0x705F7265,
    (? *)0x6C5F6479,
    (? *)0x6E007377,
    (? *)0x61705F72,
    (? *)0x6567696E,
    (? *)0x666F0073,
    (? *)0x7761705F,
    (? *)0x64796E73,
    (? *)0x796D0073,
    (? *)0x7761705F,
    (? *)0x636F6E66,
    (? *)0x6C696374,
    (? *)0x737761,
    (? *)0x705F676F,
    (? *)0x74007377,
    (? *)0x61705F6C,
    (? *)0x69626C69,
    (? *)0x73740073,
    (? *)0x7761705F,
    (? *)0x6D73796D,
    (? *)0x737761,
    (? *)0x705F6568,
    (? *)0x64720073,
    (? *)0x7761705F,
    (? *)0x70686472,
    (? *)0x737761,
    (? *)0x705F7368,
    (? *)0x64720061,
    (? *)0x6C6C6F63,
    (? *)0x5F726573,
    (? *)0x697A6500,
    (? *)0x78667265,
    (? *)0x6500616C,
    (? *)0x6C6F635F,
    (? *)0x64697370,
    (? *)0x6F736500,
    (? *)0x616C6C6F,
    (? *)0x635F6E65,
    (? *)0x7700616C,
    (? *)0x6C6F635F,
    (? *)0x6E657874,
    (? *)0x5F736362,
    (? *)0x616C6C,
    (? *)0x6F635F6D,
    (? *)0x61726B00,
    (? *)0x616C6C6F,
    (? *)0x635F7265,
    (? *)0x6C656173,
    (? *)0x65007362,
    (? *)0x726B0061,
    (? *)0x6C6C6F63,
    (? *)0x5F706167,
    (? *)0x6500616C,
    (? *)0x6C6F635F,
    (? *)0x66726565,
    (? *)0x616C6C,
    (? *)0x6F635F73,
    (? *)0x63620000,
    NULL,
};
static s32 binasm_count;
static s32 nowarnflag;
static s32 warnexitflag;
static u8 isa;
static s32 CurrentSegment;
static s32 verbose;
static s32 debugflag;
static s32 atflag;
static s32 isStruct;
static s32 StructOrg;
static ? *LastLabel;
static s32 in_repeat_block;
static s32 rep_count;
static u32 rep_size;
static ? *rep_buffer;
static s32 invent_locs;
static s32 gp_warn;
static s32 linelength;
static s32 nextinline;
static u8 line[0x420];
static s32 CurrentFile;
static s32 CurrentLine;
static ? save;
static u8 Tokench;
static ? *Tstring[0x100];
static s32 Tstringlength;
static ? *token_tmp[0x100];
static s32 printedline;
static s32 severity;
static ? *reg_ptr[0x20];
static ? *hashtable[0x80];
static ? *ophashtable[0x80];
static s32 local_label[0x100];
static ? *binasm_rec;
static ? *binasmfyle;
static ? *in_file;
static s32 mednat;
static s32 diag_flag;
static s32 shftaddr;
static ? *extsyms_file;
static s32 list_extsyms;
static u8 *B_1000A7EC;
static u8 *B_1000A7F0;
static u8 *B_1000A7F4;
static u8 *B_1000A7F8;
static s32 freg4;
static s32 B_1000A810;
static ? *B_1000A820;
static s32 B_1000A824;
static s32 B_1000A828;
static ? *B_1000A82C;
static s32 B_1000A830;
static s32 B_1000A834;
static ? B_1000A840;
static ? B_1000A888;
static u8 B_1000A8C8[0x44];
static ? *B_1000A90C;
static ? *B_1000A910;
static ? *B_1000A914;
static ? *B_1000A918[8];
static u32 B_1000A938;
static ? B_1000A940;
static ? *B_1000A980[8];
static ? *st_pchdr;
static void **pcfdcur;
static ? *malloc_scb;

void _ftext(void) {

}

void __start(void) {
    func_00403DFC();
}

void func_00403DFC(void) {
    s32 sp14;
    ? sp4;
    void *temp_a2;
    void *temp_gp;

    temp_gp = saved_reg_ra + 0x0FC0CCC4;
    temp_a2 = &sp4 + 4 + (sp0 * 4);
    *temp_gp->unk-7F80 = temp_a2;
    *temp_gp->unk-7C3C = sp0;
    unksp10 = temp_gp;
    sp14 = 0;
    *temp_gp->unk-7C38 = &sp4;
    temp_gp->unk-7D24(sp0, &sp4, temp_a2);
    unksp10->unk-7F00();
    unksp10->unk-7F0C(unksp10->unk-7ECC(*unksp10->unk-7C3C, *unksp10->unk-7C38, *unksp10->unk-7F80));
    M2C_BREAK();
}

void _mcount(void) {

}

void func_00403F10(void) {
    ? **temp_v1;
    ? *temp_v0;
    s32 temp_s3;
    s32 var_s1;
    struct _struct_asm_info_0x8 *var_s2;
    u8 *temp_s0;

    var_s2 = asm_info;
    var_s1 = 0;
    do {
        temp_s0 = var_s2->unk0;
        if (*temp_s0 != 0) {
            temp_s3 = hash(temp_s0);
            temp_v0 = alloc_new_sym();
            temp_v1 = &ophashtable[temp_s3];
            temp_v0->unk4 = temp_s0;
            temp_v0->unkC = 0;
            temp_v0->unk8 = 0;
            temp_v0->unk10 = 1;
            temp_v0->unk14 = var_s1;
            temp_v0->unk0 = *temp_v1;
            temp_v0->unk18 = (u32) ((u32) var_s2->unk4 >> 0x19);
            *temp_v1 = temp_v0;
        }
        var_s1 += 1;
        var_s2 += 8;
    } while (var_s1 != 0x1AE);
}

void func_00404008(void) {
    ? **temp_v1;
    ? *temp_v0_2;
    s32 temp_s3;
    s32 var_s1;
    u8 **var_s2;
    u8 *temp_v0;

    var_s2 = sitype;
    var_s1 = 0;
    do {
        temp_v0 = *var_s2;
        if (*temp_v0 == 0x2E) {
            temp_s3 = hash(temp_v0);
            temp_v0_2 = alloc_new_sym();
            temp_v1 = &ophashtable[temp_s3];
            temp_v0_2->unk4 = temp_v0;
            temp_v0_2->unkC = 0;
            temp_v0_2->unk8 = -1;
            temp_v0_2->unk10 = 2;
            temp_v0_2->unk14 = var_s1;
            temp_v0_2->unk0 = *temp_v1;
            *temp_v1 = temp_v0_2;
        }
        var_s1 += 1;
        var_s2 += 4;
    } while (var_s1 != 0x3F);
}

void func_00404108(s32 arg0, u8 *arg1, s32 arg2) {
    s32 sp20;
    ? **temp_v1;
    ? *temp_v0;

    sp20 = hash(arg1);
    temp_v0 = alloc_new_sym();
    temp_v1 = &hashtable[sp20];
    temp_v0->unk0 = *temp_v1;
    temp_v0->unkC = 0;
    temp_v0->unk10 = 0;
    temp_v0->unk4 = arg1;
    temp_v0->unk8 = arg2;
    temp_v0->unk14 = arg0;
    *temp_v1 = temp_v0;
}

void func_004041A8(? *arg0, s32 arg1) {
    s32 sp20;
    ? **temp_v1;
    ? *temp_v0;

    sp20 = hash();
    temp_v0 = alloc_new_sym();
    temp_v1 = &hashtable[sp20];
    temp_v0->unk0 = *temp_v1;
    temp_v0->unkC = 0;
    temp_v0->unk10 = 4;
    temp_v0->unk4 = arg0;
    temp_v0->unk8 = arg1;
    *temp_v1 = temp_v0;
}

void func_00404234(s32 arg0, s32 arg1) {
    ? **sp44;
    u32 sp40;
    ? **var_v1;
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *temp_v0_4;
    ? *var_a0;
    s32 *var_v0;
    s32 temp_v0;
    s32 temp_v0_5;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s0_3;
    s32 var_s3;
    u8 **var_s1_2;
    u8 **var_s1_3;
    u8 **var_s1_4;
    u8 *temp_a1;
    u8 *temp_a2;
    u8 *temp_t5;
    u8 *temp_t6;
    u8 *temp_t7;
    void *var_s1;

    B_1000A7EC = NULL;
    B_1000A7F0 = "binasm";
    B_1000A7F4 = NULL;
    B_1000A7F8 = NULL;
    list_extsyms = 0;
    CurrentSegment = 1;
    CurrentLine = 0;
    CurrentFile = -1;
    linelength = 0;
    severity = 4;
    verbose = 0;
    atflag = 1;
    debugflag = 0;
    isStruct = 0;
    LastLabel = NULL;
    in_repeat_block = 0;
    invent_locs = 1;
    gp_warn = 0;
    mednat = 0;
    var_s3 = 1;
    if (arg0 >= 2) {
        sp40 = (arg0 * 4) + arg1;
        var_s1 = arg1 + 4;
        do {
            temp_a1 = var_s1->unk0;
            if (*temp_a1 == 0x2D) {
                temp_v0 = which_opt(temp_a1, temp_a1);
                switch (temp_v0) {
                case 0x19:
                    debugflag = 0;
                    break;
                case 0x1A:
                    debugflag = 1;
                    break;
                case 0x18:
                case 0x1B:
                    debugflag = 2;
                    break;
                case 0x1C:
                    debugflag = 3;
                    break;
                case 0x20:
                    var_s3 = 0;
                    break;
                case 0x21:
                    var_s3 = 1;
                    break;
                case 0x1F:
                case 0x22:
                    var_s3 = 2;
                    break;
                case 0x23:
                    var_s3 = 3;
                    break;
                case 0x27:
                case 0x28:
                    nowarnflag = 1;
                    warnexitflag = 0;
                    break;
                case 0x29:
                    nowarnflag = 0;
                    warnexitflag = 1;
                    break;
                case 0x2A:
                    nowarnflag = 1;
                    warnexitflag = 1;
                    break;
                case 0x26:
                    verbose = 1;
                    fprintf(&__iob + 0x20, "as0: ");
                    fflush(&__iob + 0x20);
                    break;
                case 0x25:
                    temp_t5 = var_s1->unk4;
                    var_s1 += 4;
                    B_1000A7F4 = temp_t5;
                    break;
                case 0x56:
                    temp_t6 = var_s1->unk4;
                    var_s1 += 4;
                    B_1000A7F8 = temp_t6;
                    list_extsyms = 1;
                    break;
                case 0x2:
                case 0xC:
                case 0x45:
                case 0x49:
                case 0x5F:
                    var_s1 += 4;
                    break;
                case 0x1E:
                    temp_t7 = var_s1->unk4;
                    var_s1 += 4;
                    B_1000A7F0 = temp_t7;
                    break;
                case 0x3A:
                    gp_warn = 1;
                    break;
                case 0x69:
                    posterror("Unknown option", temp_a1, 2);
                    break;
                case 0x30:
                    isa = 1;
                    break;
                case 0x31:
                    isa = 2;
                    break;
                case 0x32:
                    isa = 3;
                    break;
                case 0x33:
                    isa = 4;
                    break;
                case 0x52:
                    mednat = 1;
                    break;
                case 0x51:
                    diag_flag = 1;
                    break;
                }
            } else if (B_1000A7EC == NULL) {
                B_1000A7EC = temp_a1;
            } else {
                posterror("Extra filename on command line", temp_a1, 2);
            }
            var_s1 += 4;
        } while ((u32) var_s1 < sp40);
    }
    if (isa == 0) {
        isa = 1;
    }
    if (var_s3 >= 2) {
        debugflag = 2;
    }
    temp_v0_2 = fopen(B_1000A7F0, "w");
    binasmfyle = temp_v0_2;
    if (temp_v0_2 == NULL) {
        call_perror(1, B_1000A7F0);
        exit(1);
    }
    binasm_count = 1;
    if (list_extsyms != 0) {
        temp_a2 = B_1000A7F8;
        if (temp_a2 != NULL) {
            temp_v0_3 = fopen(temp_a2, "w", temp_a2);
            extsyms_file = temp_v0_3;
            if (temp_v0_3 == NULL) {
                goto block_44;
            }
        } else {
block_44:
            call_perror(1, temp_a2, temp_a2);
            exit(1);
        }
    }
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x2A);
    binasm_rec.unk0 = NULL;
    binasm_rec.unk8 = 3;
    binasm_rec.unkC = 0x13;
    put_binasmfyle();
    sym_init(debugflag);
    if (B_1000A7EC != NULL) {
        temp_v0_4 = fopen(B_1000A7EC, "r");
        var_a0 = temp_v0_4;
        in_file = temp_v0_4;
        if (temp_v0_4 == NULL) {
            call_perror(1, B_1000A7EC);
            exit(1);
            var_a0 = in_file;
        }
    } else {
        var_a0 = &__iob;
        in_file = &__iob;
    }
    if (fgetc(var_a0) != 0x23) {
        make_file(B_1000A7EC);
    }
    fseek(in_file, 0, 0);
    var_s0 = 0;
    var_s1_2 = sregisters;
    var_v1 = reg_ptr;
    do {
        sp44 = var_v1;
        temp_v0_5 = func_00404108(var_s0, *var_s1_2, var_s0);
        var_s0 += 1;
        var_s1_2 += 4;
        var_v1 += 4;
        var_v1->unk-4 = temp_v0_5;
    } while (var_s0 < 0x20);
    var_s0_2 = 0x20;
    var_s1_3 = sregisters + 0x80;
    do {
        func_00404108(var_s0_2, *var_s1_3, var_s0_2 - 0x20);
        var_s0_2 += 1;
        var_s1_3 += 4;
    } while (var_s0_2 < 0x40);
    var_s0_3 = 0x40;
    var_s1_4 = sregisters + 0x100;
    do {
        func_00404108(var_s0_3, *var_s1_4, var_s0_3 - 0x40);
        var_s0_3 += 1;
        var_s1_4 += 4;
    } while (var_s0_3 != 0x48);
    func_00404108(1, "$at", 1);
    func_00404108(0x1A, "$kt0", 0x1B);
    func_00404108(0x1B, "$kt1", 0x1C);
    func_00404108(0x1C, "$gp", 0x1D);
    func_00404108(0x1D, "$sp", 0x1E);
    func_00404108(0x1E, "$fp", 0x1F);
    func_00404108(0x1D, sframereg, 0x1D);
    func_004041A8(sframesize, 0);
    func_00404008();
    func_00403F10();
    var_v0 = local_label;
    do {
        var_v0 += 0x10;
        var_v0->unk-10 = 0;
        var_v0->unk-C = 0;
        var_v0->unk-8 = 0;
        var_v0->unk-4 = 0;
    } while (var_v0 != (local_label + 0x400));
}

? main(void) {
    func_00404234();
    if (!(in_file->unkC & 0x10)) {
        do {
            readinline();
            Parsestmt();
        } while (!(in_file->unkC & 0x10));
    }
    if (verbose != 0) {
        fprintf(&__iob + 0x20, "\n");
    }
    if ((severity < 2) || ((warnexitflag != 0) && (severity < 3))) {
        exit(1);
    }
    do_dot_end(1);
    sym_finish(B_1000A7F0, B_1000A7F4);
    return 0;
}

void func_00404B80(s32 arg0, s32 arg1, u32 arg2) {
    u32 var_v0;

    switch (arg0) {                                 /* switch 1; irregular */
    default:                                        /* switch 1 */
    case 1:                                         /* switch 1 */
        var_v0 = (u32) (asm_info[arg2].unk4 << 0x11) >> 0x1B;
        break;
    case 2:                                         /* switch 1 */
        var_v0 = (u32) (asm_info[arg2].unk4 << 0x16) >> 0x1B;
        break;
    case 3:                                         /* switch 1 */
        var_v0 = asm_info[arg2].unk4 & 0x1F;
        break;
    }
    switch (var_v0) {
    case 1:
        if ((atflag != 0) && (arg1 == 1)) {
            posterror("Used $at without .set noat", D_10000004[arg0], 2, arg0);
        } else if ((arg1 < 0) || (arg1 >= 0x20)) {
            posterror("Should be gp register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 2:
        if (((s32) isa < 3) && ((arg1 < 0) || (arg1 >= 0x20) || (arg1 & 1))) {
            posterror("Should be even gp register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 3:
        if (((arg1 < 0) || (arg1 >= 0x20)) && (arg1 != 0x48)) {
            posterror("Should be gp register", D_10000004[arg0], 1, arg0);
        } else if (atflag != 0) {
            if (arg1 == 1) {
                posterror("Used $at without .set noat", D_10000004[arg0], 2, arg0);
            }
        }
        break;
    case 7:
        if ((arg1 < 0) || (arg1 >= 0x20)) {
            posterror("Should be coprocessor register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 8:
        if (((s32) isa < 3) && ((arg1 < 0) || (arg1 >= 0x20) || (arg1 & 1))) {
            posterror("Should be even coprocessor register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 4:
        if ((arg1 < 0x20) || (arg1 >= 0x40)) {
            posterror("Should be floating point register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 5:
        if ((s32) isa < 3) {
            if ((arg1 < 0x20) || (arg1 >= 0x40) || (arg1 & 1)) {
                posterror("Should be even floating point register", D_10000004[arg0], 1, arg0);
            }
        }
        break;
    case 6:
        if ((s32) isa >= 3) {
            if ((arg1 < 0x20) || (arg1 >= 0x40) || (arg1 & 1)) {
                posterror("Should be even floating point register", D_10000004[arg0], 1, arg0);
            }
        } else if ((arg1 < 0x20) || (arg1 >= 0x40) || (arg1 & 3)) {
            posterror("Should be multiple-of-4 floating point register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 9:
        if (((s32) isa < 3) && (arg1 >= 0x20) && (arg1 & 1)) {
            posterror("Should be fp double or gp single register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 10:
        if ((s32) isa < 3) {
            if (arg1 & 1) {
                posterror("Should be multiple-of-2 register", D_10000004[arg0], 1, arg0);
            }
        }
        break;
    case 11:
        if ((s32) isa >= 3) {
            if (arg1 & 1) {
                posterror("Should be multiple-of-2 register", D_10000004[arg0], 1, arg0);
            }
        } else if (arg1 & 3) {
            posterror("Should be multiple-of-4 register", D_10000004[arg0], 1, arg0);
        }
        break;
    case 12:
        if ((arg1 < 0x40) || (arg1 >= 0x48)) {
            posterror("Should be floating point condition code register", D_10000004[arg0], 1, arg0);
        }
        break;
    }
}

void func_00405178(? *arg0, u32 arg1, s32 arg2, s32 arg3, u32 arg4, s32 arg5, s32 arg6) {
    binasm_rec.unk8 = (u8) ((arg2 * 2) | (binasm_rec.unk8 & 0xFF01));
    binasm_rec.unk6 = (u16) (((arg1 * 2) & 0x3FE) | (binasm_rec.unk6 & 0xFC01));
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x17);
    binasm_rec.unk8 = (s16) (((arg3 * 4) & 0x1FC) | ((u16) binasm_rec.unk8 & 0xFE03));
    binasm_rec.unk0 = arg0;
    binasm_rec.unk8 = (s32) (((u32) ((arg4 ^ ((u32) binasm_rec.unk8 >> 0xE)) << 0x1C) >> 0xE) ^ (u32) binasm_rec.unk8);
    binasm_rec.unk4 = (u16) (((gform_extn << 6) & 0x1C0) | (binasm_rec.unk4 & 0xFE3F));
    if (gform_extn != 0) {
        binasm_rec.unkC = arg6;
    }
    switch (arg4) {
    case 15:
        binasm_rec.unkB = (u8) ((freg4 & 0x7F) | (binasm_rec.unkB & 0xFF80));
        func_00404B80(3, freg4, arg1);
        /* fallthrough */
    case 3:
        binasm_rec.unkA = (u16) (((arg5 << 7) & 0x3F80) | (binasm_rec.unkA & 0xC07F));
        func_00404B80(1, arg2, arg1, arg3);
        func_00404B80(2, arg3, arg1);
        func_00404B80(3, arg5, arg1);
        break;
    case 6:
        binasm_rec.unkC = arg6;
        break;
    case 2:
        if (arg2 != 0x48) {
            func_00404B80(1, arg2, arg1);
        }
        binasm_rec.unkC = arg6;
        break;
    case 14:
        if (arg3 != 0x48) {
            func_00404B80(2, arg3, arg1);
        }
        binasm_rec.unkC = arg6;
        break;
    case 0:
    case 1:
    case 4:
        func_00404B80(1, arg2, arg1);
        func_00404B80(2, arg3, arg1);
        binasm_rec.unkC = arg6;
        break;
    case 12:
        func_00404B80(1, arg2, arg1);
        binasm_rec.unkC = arg6;
        break;
    case 7:
    case 9:
        func_00404B80(1, arg2, arg1);
        break;
    case 5:
    case 8:
        func_00404B80(1, arg2, arg1);
        func_00404B80(2, arg3, arg1);
        break;
    case 13:
        binasm_rec.unkC = arg6;
        break;
    default:
        assertion_failed("false", "as0parse.c", (s32 *)0xED);
        break;
    }
    put_binasmfyle();
}

void func_004054E8(s32 *arg0, ? *arg1) {
    ? *var_a2;

    fprintf(extsyms_file, "%1d %1d", binasm_count, arg0);
    if (arg1 != NULL) {
        var_a2 = arg1;
    } else {
        var_a2 = "";
    }
    fprintf(extsyms_file, " %s\n", (s32) var_a2);
}

void func_00405574(s32 arg0) {
    ? *var_v0;

    var_v0 = LastLabel;
    StructOrg = ((s32) ((StructOrg + (1 << arg0)) - 1) >> arg0) << arg0;
    if (var_v0 != NULL) {
        do {
            var_v0->unk8 = (s32) StructOrg;
            var_v0 = var_v0->unkC;
        } while (var_v0 != NULL);
    }
    LastLabel = NULL;
}

void func_004055D4(u8 *arg0) {
    ? *sp2C;
    s32 sp28;
    ? **sp24;
    ? **temp_v1;
    ? *temp_v0;

    if (LookUp(&sp2C) != 0) {
        posterror("can not redefine symbol", arg0, 2);
        return;
    }
    sp28 = hash(arg0);
    temp_v0 = alloc_new_sym();
    temp_v1 = &hashtable[sp28];
    sp2C = temp_v0;
    *temp_v0 = *temp_v1;
    sp24 = temp_v1;
    sp2C->unk4 = alloc_new_string(arg0);
    sp2C->unkC = (? *) LastLabel;
    LastLabel = sp2C;
    sp2C->unk10 = 4;
    sp2C->unk8 = 0;
    *temp_v1 = sp2C;
}

void func_004056DC(u8 *arg0) {
    ? *sp2C;
    s32 sp28;
    s32 sp24;
    ? **sp20;
    ? **temp_v1;
    ? *temp_v0_2;
    s32 temp_v0;

    temp_v0 = LookUp(&sp2C);
    sp24 = temp_v0;
    if (temp_v0 == 0) {
        sp28 = hash(arg0);
        temp_v0_2 = alloc_new_sym();
        temp_v1 = &hashtable[sp28];
        sp2C = temp_v0_2;
        *temp_v0_2 = *temp_v1;
        sp20 = temp_v1;
        sp2C->unk4 = alloc_new_string(arg0);
        sp2C->unk10 = 4;
        sp2C->unk14 = 1;
        sp2C->unk18 = sym_enter(arg0, 0);
        *sp20 = sp2C;
    }
    sp2C->unkC = 0;
    sp2C->unk10 = 4;
    nexttoken();
    sp2C->unk8 = GetExpr();
    sym_define(sp2C->unk18, 5, sp2C->unk8);
    if (sp24 != 0) {
        binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x29);
        binasm_rec.unk0 = (? *) sp2C->unk18;
        binasm_rec.unk8 = (s32) sp2C->unk8;
        put_binasmfyle();
    }
}

s32 func_00405884(void) {
    s32 temp_v0;
    s32 var_v0;

    temp_v0 = GetExpr();
    if ((temp_v0 < 0) || (var_v0 = temp_v0, ((temp_v0 < 0x400) == 0))) {
        posterror("break operand out of range", NULL, 1);
        var_v0 = 0;
    }
    return var_v0;
}

void func_004058F0(u32 arg0) {
    s32 sp34;
    s32 temp_t0;
    s32 var_v1;

    if (arg0 != 0x1B) {
        if (arg0 == 0x198) {
            func_00405178(NULL, 2U, 0, 0, 3U, 0, 0);
            return;
        }
        if (arg0 == 0x199) {
            func_00405178(NULL, 0x4FU, 0, 0, 4U, 0x48, 1);
            return;
        }
        func_00405178(NULL, arg0, 0x48, 0x48, 2U, 0x48, 0);
        return;
    }
    temp_t0 = func_00405884(arg0);
    if (Tokench == 0x23) {
        var_v1 = 0;
    } else {
        sp34 = temp_t0;
        var_v1 = func_00405884();
    }
    func_00405178(NULL, arg0, 0x48, 0x48, 0xDU, 0x48, (var_v1 << 0xA) + temp_t0);
}

void func_00405A80(s32 *arg1) {
    if (Tokench == 0x3A) {
        nexttoken();
        *arg1 = GetExpr();
        return;
    }
    if ((Tokench == 0x2B) || (Tokench == 0x2D)) {
        GetItem(arg1);
        return;
    }
    if ((Tokench != 0x23) && (Tokench != 0x2C)) {
        posterror("ill-formed symbolic expression", NULL, 1);
    }
}

void func_00405B54(s32 *arg2) {
    if (Tokench == 0x3A) {
        nexttoken();
        *arg2 = GetExpr();
        return;
    }
    if ((Tokench == 0x2B) || (Tokench == 0x2D)) {
        dw_GetItem(arg2);
        return;
    }
    if ((Tokench != 0x23) && (Tokench != 0x2C)) {
        posterror("ill-formed symbolic expression", NULL, 1);
    }
}

void func_00405C28(u8 *arg0, s32 arg1, s32 *arg2, s32 *arg3) {
    u8 sp50;
    u8 sp48;
    s32 temp_a1;
    s32 temp_a2;
    s32 temp_v0;
    s32 var_a0;
    s32 var_s0;
    u32 temp_v0_2;
    u32 temp_v0_3;
    u8 *var_s0_2;
    u8 *var_s0_3;
    u8 *var_s0_4;
    u8 *var_s0_5;
    u8 *var_v0;
    u8 *var_v0_2;
    u8 *var_v1;
    u8 temp_t5;
    u8 temp_t9;
    void *var_v1_2;

    var_s0 = arg1;
    if (arg1 >= 0x11) {
        var_s0 = 0x10;
    }
    var_a0 = 0;
    if (var_s0 > 0) {
        temp_a2 = var_s0 & 3;
        if (temp_a2 != 0) {
            var_v0 = &(&sp48)[-var_s0];
            var_v1 = arg0;
            do {
                temp_t9 = *var_v1;
                var_a0 += 1;
                var_v0 += 1;
                var_v1 += 1;
                var_v0->unkF = temp_t9;
            } while (temp_a2 != var_a0);
            if (var_a0 != var_s0) {
                goto block_7;
            }
        } else {
block_7:
            var_v0_2 = &(&sp48)[var_a0 + -var_s0];
            var_v1_2 = arg0 + var_a0;
            do {
                var_a0 += 4;
                var_v0_2->unk10 = (u8) var_v1_2->unk0;
                var_v0_2 += 4;
                var_v0_2->unkD = (u8) var_v1_2->unk1;
                temp_t5 = var_v1_2->unk2;
                var_v1_2 += 4;
                var_v0_2->unkE = temp_t5;
                var_v0_2->unkF = (u8) var_v1_2->unk-1;
            } while (var_a0 != var_s0);
        }
        var_a0 = 0;
    }
    temp_a1 = 0x10 - var_s0;
    if (temp_a1 > 0) {
        temp_v0 = temp_a1 & 3;
        if (temp_v0 != 0) {
            var_s0_2 = &sp48;
            do {
                var_a0 += 1;
                *var_s0_2 = 0x30;
                var_s0_2 += 1;
            } while (temp_v0 != var_a0);
            if (var_a0 != temp_a1) {
                goto block_15;
            }
        } else {
block_15:
            var_s0_3 = &(&sp48)[var_a0];
            do {
                var_s0_3 += 4;
                var_s0_3->unk-3 = 0x30;
                var_s0_3->unk-2 = 0x30;
                var_s0_3->unk-1 = 0x30;
                var_s0_3->unk-4 = 0x30;
            } while (var_s0_3 != &(&sp48)[temp_a1]);
        }
    }
    *arg2 = 0;
    *arg3 = 0;
    var_s0_4 = &sp48;
    do {
        temp_v0_2 = hex_to_num(*var_s0_4);
        var_s0_4 += 1;
        *arg2 = temp_v0_2 + (*arg2 * 0x10);
    } while ((u32) var_s0_4 < (u32) &sp50);
    var_s0_5 = &sp50;
    do {
        temp_v0_3 = hex_to_num(*var_s0_5);
        var_s0_5 += 1;
        *arg3 = temp_v0_3 + (*arg3 * 0x10);
    } while (var_s0_5 != &arg0);
}

s32 func_00405DE4(? **arg0, s32 *arg1, s32 *arg2, s32 *arg3) {
    ? *sp2C;
    s32 temp_v0;

    if (Tokench == 0x69) {
        if (LookUp(Tstring, &sp2C) == 0) {
            EnterSym(Tstring, &sp2C, 1);
        }
        temp_v0 = sp2C->unk10;
        if (temp_v0 == 4) {
            dw_GetItem(arg1, arg2, arg3);
            goto block_16;
        }
        if (temp_v0 == 3) {
            *arg0 = sp2C->unk18;
            nexttoken(arg1, NULL);
            func_00405B54(arg1, arg2, arg3);
            goto block_16;
        }
        posterror("Bad id in expression", NULL, 1);
        nexttoken();
        return 0;
    }
    if (Tokench == 0x22) {
        func_00405C28((u8 *) Tstring, strlen(Tstring), arg1, arg2);
        nexttoken();
    } else {
        dw_GetExpr(arg1, arg2);
    }
    if (Tokench == 0x3A) {
        nexttoken();
        *arg3 = GetExpr();
    } else {
        *arg3 = 1;
    }
block_16:
    if (Tokench == 0x2C) {
        nexttoken();
    }
    return 1;
}

void func_00406034(void) {
    ? *sp54;
    s32 sp50;
    s32 sp4C;
    s32 sp48;
    s32 temp_t9;
    s32 var_v1;

    if (LastLabel != NULL) {
        func_00405574(2);
    }
loop_3:
    sp4C = 0;
    sp48 = 0;
    sp50 = 1;
    sp54 = NULL;
    if (func_00405DE4(&sp54, &sp4C, &sp48, &sp50) != 0) {
        if (isStruct != 0) {
            temp_t9 = sp50 * 4;
            if (temp_t9 < 4) {
                var_v1 = 4;
            } else {
                var_v1 = temp_t9;
            }
            StructOrg += var_v1;
        } else {
            binasm_rec.unk0 = sp54;
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x3B);
            binasm_rec.unk8 = sp4C;
            binasm_rec.unkC = sp50;
            put_binasmfyle();
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x3B);
            binasm_rec.unk0 = sp54;
            binasm_rec.unk8 = sp48;
            binasm_rec.unkC = sp50;
            put_binasmfyle();
        }
        if (Tokench == 0x23) {

        } else {
            goto loop_3;
        }
    }
}

void func_004061F8(u32 arg0) {
    ? *sp3C;
    s32 sp38;
    s32 sp34;
    ? *temp_v0;

    sp38 = 0;
    sp34 = 0;
    temp_v0 = GetRegister();
    sp3C = temp_v0;
    if (temp_v0 != NULL) {
        if (Tokench == 0x22) {
            func_00405C28((u8 *) Tstring, strlen(Tstring), &sp38, &sp34);
        } else {
            dw_GetExpr(&sp38, &sp34);
        }
        func_00405178(NULL, arg0, sp3C->unk14, 0x48, 2U, 0x48, sp38);
        func_00405178(NULL, arg0, sp3C->unk14, 0x48, 2U, 0x48, sp34);
        nexttoken();
    }
}

void func_00406340(? **arg0, s32 *arg1) {
    s32 temp_v0;
    u8 temp_v1;

    *arg0 = NULL;
    *arg1 = 0;
    nexttoken();
    if (strcmp(Tstring, "hi") == 0) {
        gform_extn = 1;
        goto block_9;
    }
    if (strcmp(Tstring, "lo") == 0) {
        gform_extn = 2;
        goto block_9;
    }
    if (strcmp(Tstring, "gprel") == 0) {
        gform_extn = 5;
        goto block_9;
    }
    if (strcmp(Tstring, "half") == 0) {
        gform_extn = 6;
block_9:
        nexttoken();
        if (Tokench != 0x28) {
            posterror("%hi/%lo/%gprel not followed by (", NULL, 1);
            return;
        }
        nexttoken();
        if (Tokench == 0x69) {
            if (LookUp(Tstring, arg0) == 0) {
                EnterSym(Tstring, arg0, 1);
                if (gp_warn != 0) {
                    posterror("Load/Store of undefined symbol", (*arg0)->unk4, 2);
                }
            }
            temp_v0 = (*arg0)->unk10;
            if (temp_v0 == 4) {
                *arg0 = NULL;
                goto block_23;
            }
            if (temp_v0 == 3) {
                nexttoken();
                if ((Tokench != 0x2B) && (Tokench != 0x2D) && (Tokench != 0x29)) {
                    posterror("invalid expression with %hi/%lo", (u8 *) Tstring, 1);
                    return;
                }
            }
            goto block_23;
        }
block_23:
        temp_v1 = Tokench;
        if ((temp_v1 == 0x2B) || (temp_v1 == 0x2D) || (temp_v1 == 0x69)) {
            *arg1 = GetExpr();
        }
        if (temp_v1 != 0x29) {
            posterror("')' expected", (u8 *) Tstring, 1);
            return;
        }
        nexttoken();
        return;
    }
    posterror("% not followed by hi/lo/gprel", NULL, 1);
}

void func_00406684(void) {
    nexttoken();
    if (Tokench != 0x64) {
        posterror("invalid memory tag", NULL, 1);
        return;
    }
    binasm_rec.unkA = (u16) ((GetExpr() & 0x3FFF) | (binasm_rec.unkA & 0xC000));
}

void func_00406728(u32 arg0) {
    ? *sp50;
    s32 sp4C;
    s32 sp48;
    ? *sp44;
    s32 sp40;
    ? *temp_v0;
    ? *temp_v0_3;
    s32 temp_v0_2;
    u8 temp_v1;
    u8 temp_v1_2;

    sp4C = 0;
    sp50 = NULL;
    temp_v0 = GetRegister();
    if (temp_v0 != NULL) {
        sp44 = NULL;
        sp40 = temp_v0->unk14;
        if (Tokench == 0x22) {
            sp48 = 0;
            func_00405C28((u8 *) Tstring, strlen(Tstring), &sp4C, &sp48);
            func_00405178(NULL, arg0, sp40, 0x48, 2U, 0x48, sp4C);
            func_00405178(NULL, arg0, sp40, 0x48, 2U, 0x48, sp48);
            nexttoken();
            return;
        }
        if (Tokench == 0x69) {
            if (LookUp(Tstring, &sp44) == 0) {
                EnterSym(Tstring, &sp44, 1);
                if (gp_warn != 0) {
                    posterror("Load/store of an undefined symbol", sp44->unk4, 2);
                }
            }
            temp_v0_2 = sp44->unk10;
            if (temp_v0_2 == 4) {
                sp44 = NULL;
                goto block_19;
            }
            if (temp_v0_2 == 3) {
                nexttoken();
                temp_v1 = Tokench;
                if (temp_v1 == 0x2C) {
                    func_00406684();
                }
                if ((temp_v1 != 0x2B) && (temp_v1 != 0x2D) && (temp_v1 != 0x28) && (temp_v1 != 0x23)) {
                    posterror("invalid external expression", NULL, 1);
                    return;
                }
                goto block_19;
            }
            goto block_19;
        }
block_19:
        temp_v1_2 = Tokench;
        if (temp_v1_2 == 0x25) {
            func_00406340(&sp44, &sp4C);
        }
        if (((temp_v1_2 == 0x69) || (temp_v1_2 == 0x64) || (temp_v1_2 == 0x68) || (temp_v1_2 == 0x2B) || (temp_v1_2 == 0x2D) || (temp_v1_2 == 0x7E) || (temp_v1_2 == 0x22) || (temp_v1_2 == 0x28)) && (GetBaseOrExpr(&sp50, &sp4C), (sp50 == NULL)) && (Tokench == 0x28)) {
            nexttoken();
            temp_v0_3 = GetRegister();
            sp50 = temp_v0_3;
            if (temp_v0_3 != NULL) {
                if (Tokench != 0x29) {
                    posterror("')' expected", (u8 *) Tstring, 1);
                    return;
                }
                nexttoken();
                if (Tokench == 0x2C) {
                    func_00406684();
                }
                goto block_36;
            }
        } else {
block_36:
            if (sp44 == NULL) {
                if (sp50 == NULL) {
                    sp50 = *reg_ptr;
                }
            }
            if (sp44 != NULL) {
                if (list_extsyms != 0) {
                    func_004054E8(sp44->unk18, (s32) Tstring);
                }
                if (sp50 == NULL) {
                    func_00405178(sp44->unk18, arg0, sp40, 0x48, 1U, 0x48, sp4C);
                } else {
                    func_00405178(sp44->unk18, arg0, sp40, sp50->unk14, 1U, 0x48, sp4C);
                }
            } else {
                func_00405178(NULL, arg0, sp40, sp50->unk14, 0U, 0x48, sp4C);
            }
            gform_extn = 0;
        }
    }
}

void func_00406C48(u32 arg0) {
    ? *sp48;
    s32 sp44;
    s32 sp40;
    ? *sp3C;
    ? *temp_v0_3;
    s32 temp_t7;
    s32 temp_v0;
    s32 temp_v0_2;

    sp40 = 0;
    sp48 = NULL;
    sp3C = NULL;
    temp_v0 = GetExpr();
    sp44 = temp_v0;
    if ((temp_v0 < 0) || (temp_v0 >= 0x20)) {
        posterror("Cache/Pref instruction has invalid value", NULL, 1);
    }
    if (Tokench == 0x69) {
        if (LookUp(Tstring, &sp3C) == 0) {
            EnterSym(Tstring, &sp3C, 1);
            if (gp_warn != 0) {
                posterror("Load/store of an undefined symbol", sp3C->unk4, 2);
            }
        }
        temp_v0_2 = sp3C->unk10;
        if (temp_v0_2 == 4) {
            sp3C = NULL;
            goto block_17;
        }
        if (temp_v0_2 == 3) {
            nexttoken();
            if ((Tokench != 0x2B) && (Tokench != 0x2D) && (Tokench != 0x28) && (Tokench != 0x23)) {
                posterror("invalid external expression", NULL, 1);
                return;
            }
        }
        goto block_17;
    }
block_17:
    if (((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D) || (Tokench == 0x7E) || (Tokench == 0x22) || (Tokench == 0x28)) && (GetBaseOrExpr(&sp48, &sp40), (sp48 == NULL)) && (Tokench == 0x28)) {
        nexttoken();
        temp_v0_3 = GetRegister();
        sp48 = temp_v0_3;
        if (temp_v0_3 != NULL) {
            if (Tokench != 0x29) {
                posterror("')' expected", (u8 *) Tstring, 1);
                return;
            }
            nexttoken();
            goto block_31;
        }
    } else {
block_31:
        if (sp3C == NULL) {
            if (sp48 == NULL) {
                sp48 = *reg_ptr;
            }
        }
        temp_t7 = sp40 & 0xFFFF;
        sp40 = temp_t7;
        if (sp3C != NULL) {
            if (sp48 == NULL) {
                func_00405178(sp3C->unk18, arg0, sp44, 0x48, 0xEU, 0x48, temp_t7);
                return;
            }
            func_00405178(sp3C->unk18, arg0, sp44, sp48->unk14, 0xEU, 0x48, sp40);
            return;
        }
        func_00405178(NULL, arg0, sp44, sp48->unk14, 0xEU, 0x48, sp40);
    }
}

void func_00406FE8(u32 arg0) {
    ? *sp3C;
    s32 sp38;
    ? *sp34;
    ? *temp_v0_2;
    s32 temp_v0;

    sp38 = 0;
    sp3C = NULL;
    sp34 = NULL;
    if (Tokench == 0x69) {
        if (LookUp(Tstring, &sp34) == 0) {
            EnterSym(Tstring, &sp34, 1);
            if (gp_warn != 0) {
                posterror("Load/store of an undefined symbol", sp34->unk4, 2);
            }
        }
        temp_v0 = sp34->unk10;
        if (temp_v0 == 4) {
            sp34 = NULL;
            goto block_14;
        }
        if (temp_v0 == 3) {
            nexttoken();
            if ((Tokench != 0x2B) && (Tokench != 0x2D) && (Tokench != 0x28) && (Tokench != 0x23)) {
                posterror("invalid external expression", NULL, 1);
                return;
            }
        }
        goto block_14;
    }
block_14:
    switch (Tokench) {                              /* irregular */
    default:
        GetBaseOrExpr(&sp3C, &sp38);
        if ((sp3C == NULL) && (Tokench == 0x28)) {
            nexttoken();
            temp_v0_2 = GetRegister();
            sp3C = temp_v0_2;
            if (temp_v0_2 != NULL) {
                if (Tokench != 0x29) {
                    posterror("')' expected", (u8 *) Tstring, 1);
                    return;
                }
                nexttoken();
            case 0x69:
            case 0x64:
            case 0x68:
            case 0x2B:
            case 0x2D:
            case 0x7E:
            case 0x22:
                goto block_29;
            }
        } else {
        case 0x28:
block_29:
            if (sp34 == NULL) {
                if (sp3C == NULL) {
                    sp3C = *reg_ptr;
                }
            }
            if (sp34 != NULL) {
                if (sp3C == NULL) {
                    func_00405178(sp34->unk18, arg0, 0x48, 0x48, 1U, 0x48, sp38);
                    return;
                }
                func_00405178(sp34->unk18, arg0, 0x48, sp3C->unk14, 1U, 0x48, sp38);
                return;
            }
            func_00405178(NULL, arg0, 0x48, sp3C->unk14, 0U, 0x48, sp38);
            return;
        }
        break;
    }
}

void func_00407334(void) {
    u8 sp50;
    s32 temp_s6;
    s32 var_s1;
    s32 var_s5;
    s32 var_v0;
    u8 *temp_t9;
    u8 *var_s0;
    u8 temp_t8;
    u8 temp_v0;

    temp_v0 = Tokench;
    var_s5 = 0;
    if (temp_v0 == 0x2D) {
        var_s5 = 1;
        nexttoken();
    } else if (temp_v0 == 0x2B) {
        nexttoken();
    }
    if (temp_v0 != 0x66) {
        posterror("floating point constant expected", NULL, 1);
        if (Tokench != 0x23) {
            nexttoken();
        }
    } else {
        temp_s6 = Tstringlength;
        strcpy(&sp50, Tstring);
        nexttoken();
        if ((binasm_rec.unk4 & 0x3F) == 0x17) {
            func_00405178(NULL, (u32) ((s32) binasm_rec.unk4 << 0x16) >> 0x17, (s32) ((u32) binasm_rec.unk8 >> 0x19), 0x48, 2U, 0x48, var_s5 + temp_s6);
        } else {
            binasm_rec.unk8 = (u32) (var_s5 + temp_s6);
            if (Tokench == 0x3A) {
                nexttoken(NULL);
                binasm_rec.unkC = GetExpr();
            } else {
                binasm_rec.unkC = 1;
            }
            put_binasmfyle();
        }
        var_v0 = 0x10;
        var_s1 = 0;
        if (temp_s6 != 0) {
            var_s0 = &sp50;
            do {
                if (var_v0 == 0x10) {
                    if (var_s1 != 0) {
                        put_binasmfyle();
                    }
                    var_v0 = 0;
                    if (var_s5 != 0) {
                        binasm_rec.unk0 = 0x2D;
                        var_s5 = 0;
                        var_v0 = 1;
                    }
                }
                temp_t8 = *var_s0;
                var_s1 += 1;
                temp_t9 = &binasm_rec + var_v0;
                var_s0 += 1;
                var_v0 += 1;
                *temp_t9 = temp_t8;
            } while (var_s1 != temp_s6);
        }
        put_binasmfyle();
    }
}

void func_004075CC(u32 arg0) {
    ? *temp_v0;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x17);
    binasm_rec.unk6 = (u16) (((arg0 * 2) & 0x3FE) | (binasm_rec.unk6 & 0xFC01));
    temp_v0 = GetRegister();
    if (temp_v0 != NULL) {
        binasm_rec.unk8 = (u8) ((temp_v0->unk14 * 2) | (binasm_rec.unk8 & 0xFF01));
    }
    binasm_rec.unk8 = (s16) (((u16) binasm_rec.unk8 & 0xFE03) | 0x120);
    binasm_rec.unk8 = (s32) (((u32) ((((u32) binasm_rec.unk8 >> 0xE) ^ 2) << 0x1C) >> 0xE) ^ (u32) binasm_rec.unk8);
    func_00407334();
}

void func_004076A0(u32 arg0) {
    s32 sp48;
    ? *sp44;
    s32 sp40;
    s32 sp38;
    s32 sp34;
    ? *sp30;
    ? *temp_v0;
    s32 *var_a0;

    sp40 = 0;
    sp44 = NULL;
    sp30 = NULL;
    temp_v0 = GetRegister();
    if (temp_v0 != NULL) {
        sp48 = temp_v0->unk14;
        if ((diag_flag != 0) && (arg0 == 0xCD) && (Tokench == 0x69)) {
            if (LookUp(Tstring, &sp30) != 0) {
                if (sp30->unk10 == 0) {
                    nexttoken();
                    if (Tokench == 0x2C) {
                        nexttoken();
                    }
                } else {
                    goto block_9;
                }
            } else {
block_9:
                sp30 = NULL;
            }
        }
        if (Tokench == 0x25) {
            func_00406340(&sp44, &sp40);
            goto block_22;
        }
        if ((s32) isa < 3) {
            sp40 = GetExpr();
            goto block_22;
        }
        if (dw_GetExpr(&sp38, &sp34) != 0) {
            if (arg0 == 0xCD) {
                posterror("lui expression not in 0..65535", NULL, 1);
            }
            if (arg0 != 0x29) {
                assertion_failed("fasm == zli", "as0parse.c", (s32 *)0x446);
            }
            func_00405178(NULL, 0x14CU, sp48, 0x48, 2U, 0x48, sp38);
            func_00405178(NULL, 0x14CU, sp48, 0x48, 2U, 0x48, sp34);
        } else {
            sp40 = sp34;
block_22:
            if (arg0 == 0xCD) {
                if (sp44 == NULL) {
                    if (((u32) sp40 >> 0x10) != 0) {
                        posterror("lui expression not in 0..65535", NULL, 1);
                    }
                    sp40 <<= 0x10;
                }
            }
            if (sp44 != NULL) {
                var_a0 = sp44->unk18;
            } else {
                var_a0 = NULL;
            }
            if ((arg0 == 0xCD) && (sp30 != NULL)) {
                func_00405178(var_a0, arg0, sp48, sp30->unk14, 4U, 0x48, sp40);
            } else {
                func_00405178(var_a0, arg0, sp48, 0x48, 2U, 0x48, sp40);
            }
            gform_extn = 0;
        }
    }
}

void func_00407A20(u32 arg0) {
    ? *sp5C;
    ? *sp58;
    ? *sp54;
    ? *sp50;
    ? *sp4C;
    s32 sp48;
    s32 sp44;
    s32 sp40;
    s32 sp3C;
    s32 sp38;
    ? *temp_v0;
    s32 *var_a0;
    s32 var_a3;
    u8 temp_v0_2;

    sp44 = 0;
    sp54 = NULL;
    sp50 = NULL;
    sp3C = 0;
    temp_v0 = GetRegister();
    sp5C = temp_v0;
    if (temp_v0 != NULL) {
        if ((Tokench == 0x69) && (LookUp(Tstring, &sp58) != 0) && (sp58->unk10 == 0)) {
            sp54 = sp58;
            nexttoken();
            temp_v0_2 = Tokench;
            if (temp_v0_2 == 0x2C) {
                nexttoken();
            }
            if ((temp_v0_2 == 0x69) && (LookUp(Tstring, &sp58) != 0) && (sp58->unk10 == 0)) {
                sp50 = sp58;
                nexttoken();
            }
        }
        var_a3 = 0;
        if (sp50 == NULL) {
            if (Tokench == 0x25) {
                if (sp54 == NULL) {
                    posterror("invalid syntax in statement", NULL, 1, 0);
                    return;
                }
                func_00406340(&sp4C, &sp44);
                if (sp4C != NULL) {
                    var_a0 = sp4C->unk18;
                } else {
                    var_a0 = NULL;
                }
                func_00405178(var_a0, arg0, sp5C->unk14, sp54->unk14, 4U, 0x48, sp44);
                gform_extn = 0;
                return;
            }
            if ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D) || (Tokench == 0x7E) || (Tokench == 0x22) || (Tokench == 0x28)) {
                if ((s32) isa < 3) {
                    sp44 = GetExpr();
                } else {
                    sp3C = dw_GetExpr(&sp40, &sp44);
                }
                if (sp54 == NULL) {
                    sp54 = sp5C;
                }
                var_a3 = 1;
                goto block_49;
            }
            if ((s32) isa >= 2) {
                switch ((s32) arg0) {               /* switch 12; irregular */
                case 0x174:                         /* switch 12 */
                case 0x175:                         /* switch 12 */
                case 0x188:                         /* switch 12 */
                case 0x189:                         /* switch 12 */
                case 0x18A:                         /* switch 12 */
                case 0x18B:                         /* switch 12 */
                    func_00405178(NULL, arg0, sp5C->unk14, sp54->unk14, 3U, 0x40, 0);
                    return;
                case 0xE8:                          /* switch 12 */
                case 0xE9:                          /* switch 12 */
                case 0xEA:                          /* switch 12 */
                case 0xEB:                          /* switch 12 */
                case 0xEC:                          /* switch 12 */
                case 0xED:                          /* switch 12 */
                case 0x107:                         /* switch 12 */
                case 0x108:                         /* switch 12 */
                case 0x109:                         /* switch 12 */
                case 0x10D:                         /* switch 12 */
                case 0x10E:                         /* switch 12 */
                case 0x10F:                         /* switch 12 */
                case 0x14F:                         /* switch 12 */
                case 0x150:                         /* switch 12 */
                case 0x151:                         /* switch 12 */
                case 0x152:                         /* switch 12 */
                case 0x153:                         /* switch 12 */
                case 0x154:                         /* switch 12 */
                case 0x155:                         /* switch 12 */
                case 0x156:                         /* switch 12 */
                case 0x157:                         /* switch 12 */
                case 0x158:                         /* switch 12 */
                case 0x159:                         /* switch 12 */
                case 0x15A:                         /* switch 12 */
                    func_00405178(NULL, arg0, sp5C->unk14, sp54->unk14, 5U, 0x48, 0);
                    return;
                }
            } else {
            case 0x10A:                             /* switch 12 */
            case 0x10B:                             /* switch 12 */
            case 0x10C:                             /* switch 12 */
            case 0x176:                             /* switch 12 */
            case 0x177:                             /* switch 12 */
            case 0x178:                             /* switch 12 */
            case 0x179:                             /* switch 12 */
            case 0x17A:                             /* switch 12 */
            case 0x17B:                             /* switch 12 */
            case 0x17C:                             /* switch 12 */
            case 0x17D:                             /* switch 12 */
            case 0x17E:                             /* switch 12 */
            case 0x17F:                             /* switch 12 */
            case 0x180:                             /* switch 12 */
            case 0x181:                             /* switch 12 */
            case 0x182:                             /* switch 12 */
            case 0x183:                             /* switch 12 */
            case 0x184:                             /* switch 12 */
            case 0x185:                             /* switch 12 */
            case 0x186:                             /* switch 12 */
            case 0x187:                             /* switch 12 */
                sp50 = sp54;
                sp54 = sp5C;
block_49:
                goto block_50;
            }
        } else {
block_50:
            if ((sp54 == NULL) || ((sp50 == NULL) && (var_a3 == 0))) {
                posterror("invalid syntax in statement", NULL, 1, var_a3);
                return;
            }
            switch ((s32) arg0) {                   /* switch 11; irregular */
            case 0x44:                              /* switch 11 */
            case 0x45:                              /* switch 11 */
            case 0x4F:                              /* switch 11 */
            case 0x53:                              /* switch 11 */
            case 0x54:                              /* switch 11 */
                if ((var_a3 != 0) && ((sp44 < 0) || (sp44 >= 0x20) || (sp3C != 0))) {
                    posterror("shift amount not 0..31", NULL, 1, var_a3);
                    return;
                }
            default:                                /* switch 11 */
block_115:
                if (var_a3 != 0) {
                    sp38 = atflag;
                    if (sp3C != 0) {
                        if ((s32) arg0 >= 3) {
                            switch (arg0);          /* switch 10; jump table: jtbl_10005EA4 */
                        } else if ((arg0 == 1) || (arg0 == 2)) {
                        case 0x20:                  /* switch 10 */
                        case 0x21:                  /* switch 10 */
                        case 0x38:                  /* switch 10 */
                        case 0x39:                  /* switch 10 */
                        case 0x3A:                  /* switch 10 */
                        case 0x41:                  /* switch 10 */
                        case 0x42:                  /* switch 10 */
                        case 0x55:                  /* switch 10 */
                        case 0x56:                  /* switch 10 */
                            posterror("Immediate value out of range", NULL, 1, var_a3);
                        }
                        if (sp38 == 0) {
                            posterror("macro expansion needs at register after .set noat", NULL, 1);
                        }
                        atflag = 0;
                        func_00405178(NULL, 0x14CU, 1, 0x48, 2U, 0x48, sp40);
                        func_00405178(NULL, 0x14CU, 1, 0x48, 2U, 0x48, sp44);
                        func_00405178(NULL, arg0, sp5C->unk14, sp54->unk14, 3U, 1, 0);
                        atflag = sp38;
                        return;
                    }
                    func_00405178(NULL, arg0, sp5C->unk14, sp54->unk14, 4U, 0x48, sp44);
                    return;
                }
                func_00405178(NULL, arg0, sp5C->unk14, sp54->unk14, 3U, sp50->unk14, 0);
                break;
            case 0x13A:                             /* switch 11 */
            case 0x13B:                             /* switch 11 */
            case 0x13C:                             /* switch 11 */
            case 0x16F:                             /* switch 11 */
            case 0x170:                             /* switch 11 */
                if ((var_a3 != 0) && ((sp44 < 0) || (sp44 >= 0x40) || (sp3C != 0))) {
                    posterror("shift amount not 0..63", NULL, 1, var_a3);
                    return;
                }
                goto block_115;
            case 0x19A:                             /* switch 11 */
            case 0x19B:                             /* switch 11 */
            case 0x19C:                             /* switch 11 */
                if ((var_a3 != 0) && ((sp44 < 0) || (sp44 >= 0x20) || (sp3C != 0))) {
                    posterror("shift amount not 0..31", NULL, 1, var_a3);
                    return;
                }
                sp44 += 0x20;
                if (arg0 == 0x19A) {
                    arg0 = 0x13AU;
                } else if (arg0 == 0x19B) {
                    arg0 = 0x13BU;
                } else {
                    arg0 = 0x13CU;
                }
                goto block_115;
            case 0xD3:                              /* switch 11 */
            case 0xD4:                              /* switch 11 */
            case 0xD5:                              /* switch 11 */
            case 0xD6:                              /* switch 11 */
            case 0xD7:                              /* switch 11 */
            case 0xD8:                              /* switch 11 */
            case 0xD9:                              /* switch 11 */
            case 0x134:                             /* switch 11 */
            case 0x135:                             /* switch 11 */
                if (var_a3 == 0) {
                    posterror("operation needs immed operand", NULL, 1, var_a3);
                    return;
                }
                if ((arg0 == 0xD7) || (arg0 == 0xD8) || (arg0 == 0xD9)) {
                    if ((sp44 >= 0x10000) || (sp44 < 0) || (sp3C != 0)) {
                        sp48 = var_a3;
                        posterror("immed operand not -0..65535", NULL, 1, var_a3);
                    }
                } else {
                    if ((sp44 < 0x10000) && (sp44 >= 0x8000)) {
                        sp44 += 0xFFFF0000;
                    }
                    if ((sp44 >= 0x8000) || (sp44 < -0x8000) || (sp3C != 0)) {
                        sp48 = var_a3;
                        posterror("immed operand not -32768..32767", NULL, 1, var_a3);
                    }
                }
                goto block_115;
            case 0x7C:                              /* switch 11 */
            case 0x7D:                              /* switch 11 */
            case 0x7E:                              /* switch 11 */
            case 0x7F:                              /* switch 11 */
            case 0x80:                              /* switch 11 */
            case 0x81:                              /* switch 11 */
            case 0x82:                              /* switch 11 */
            case 0x83:                              /* switch 11 */
            case 0x84:                              /* switch 11 */
            case 0x85:                              /* switch 11 */
            case 0x86:                              /* switch 11 */
            case 0x87:                              /* switch 11 */
            case 0xE8:                              /* switch 11 */
            case 0xE9:                              /* switch 11 */
            case 0xEA:                              /* switch 11 */
            case 0xEB:                              /* switch 11 */
            case 0xEC:                              /* switch 11 */
            case 0xED:                              /* switch 11 */
            case 0x107:                             /* switch 11 */
            case 0x108:                             /* switch 11 */
            case 0x109:                             /* switch 11 */
            case 0x10D:                             /* switch 11 */
            case 0x10E:                             /* switch 11 */
            case 0x10F:                             /* switch 11 */
                if (var_a3 != 0) {
                    sp48 = var_a3;
                    posterror("immed operand not allowed on fp ", NULL, 1, var_a3);
                }
                goto block_115;
            }
        }
    }
}

void func_0040848C(s32 arg0) {
    ? *sp3C;
    s32 sp30;
    ? *temp_v0;
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *var_t0;
    ? *var_v1;
    s32 temp_a2;
    s32 var_a2;

    temp_v0 = GetRegister();
    var_t0 = temp_v0;
    if (temp_v0 != NULL) {
        var_v1 = temp_v0;
        if (Tokench != 0x23) {
            sp3C = var_t0;
            temp_v0_2 = GetRegister();
            var_v1 = temp_v0_2;
            if (temp_v0_2 == NULL) {
                return;
            }
        }
        if ((arg0 >= 0x9D) && (arg0 < 0xCD)) {
            var_a2 = 0x40;
            if ((Tokench == 0x23) || (temp_a2 = var_t0->unk14, sp3C = var_v1, sp30 = temp_a2, temp_v0_3 = GetRegister(NULL, arg0, temp_a2), var_a2 = temp_a2, var_t0 = sp3C, var_v1 = temp_v0_3, (temp_v0_3 != NULL))) {
                func_00405178(NULL, (u32) arg0, var_a2, var_t0->unk14, 3U, var_v1->unk14, 0);
            }
        } else {
            func_00405178(NULL, (u32) arg0, var_t0->unk14, var_v1->unk14, 5U, 0x48, 0);
        }
    }
}

void func_004085D8(u32 arg0) {
    ? *sp3C;
    ? *sp38;
    ? *sp34;
    ? *temp_v0;
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *temp_v0_4;
    ? *var_t0;
    ? *var_t1;
    ? *var_v1;

    temp_v0 = GetRegister();
    sp3C = temp_v0;
    if (temp_v0 != NULL) {
        temp_v0_2 = GetRegister();
        if (temp_v0_2 != NULL) {
            sp38 = temp_v0_2;
            temp_v0_3 = GetRegister();
            if (temp_v0_3 != NULL) {
                if (Tokench != 0x23) {
                    sp34 = temp_v0_3;
                    temp_v0_4 = GetRegister();
                    var_t0 = sp38;
                    var_t1 = temp_v0_3;
                    var_v1 = temp_v0_4;
                    if (temp_v0_4 == NULL) {

                    } else {
                        goto block_7;
                    }
                } else {
                    var_t1 = sp38;
                    var_t0 = sp3C;
                    var_v1 = temp_v0_3;
block_7:
                    freg4 = var_v1->unk14;
                    func_00405178(NULL, arg0, sp3C->unk14, var_t0->unk14, 0xFU, var_t1->unk14, 0);
                }
            }
        }
    }
}

void func_004086EC(u32 arg0) {
    ? *sp40;
    ? *sp3C;
    s32 sp38;
    s32 sp34;
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *temp_v0_4;
    s32 temp_v0;
    s32 var_t7;

    if (arg0 == 0x194) {
        temp_v0 = GetExpr();
        if ((temp_v0 < 0) || (var_t7 = temp_v0 & 0x1F, ((temp_v0 < 0x20) == 0))) {
            sp38 = temp_v0;
            posterror("hint field not in range 0..31", NULL, 2);
            var_t7 = temp_v0 & 0x1F;
        }
        sp34 = var_t7;
        goto block_7;
    }
    temp_v0_2 = GetRegister();
    if (temp_v0_2 != NULL) {
        sp34 = temp_v0_2->unk14;
block_7:
        temp_v0_3 = GetRegister();
        sp40 = temp_v0_3;
        if (temp_v0_3 != NULL) {
            if (Tokench != 0x28) {
                posterror("expecting '(' before base register", NULL, 1);
            } else {
                nexttoken();
                temp_v0_4 = GetRegister();
                if (temp_v0_4 != NULL) {
                    if (Tokench != 0x29) {
                        posterror("expecting ')' after base register", NULL, 1);
                    } else {
                        sp3C = temp_v0_4;
                        nexttoken();
                        func_00405178(NULL, arg0, sp34, temp_v0_4->unk14, 3U, sp40->unk14, 0);
                    }
                }
            }
        }
    }
}

void func_004088B8(u32 arg0) {
    ? *sp4C;
    ? *sp48;
    ? *sp44;
    s32 sp40;
    s32 sp3C;
    s32 sp38;
    s32 sp34;
    ? *temp_v0;
    s32 var_v1;

    temp_v0 = GetRegister();
    sp4C = temp_v0;
    if (temp_v0 != NULL) {
        sp48 = NULL;
        if ((Tokench == 0x69) && (LookUp(Tstring, &sp44) != 0) && (sp44->unk10 == 0)) {
            sp48 = sp44;
            nexttoken();
            if (Tokench == 0x2C) {
                nexttoken();
            }
        }
        if ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D) || (Tokench == 0x7E) || (Tokench == 0x22) || (Tokench == 0x28)) {
            if ((s32) isa < 3) {
                sp38 = 0;
                var_v1 = sp38;
                sp40 = GetExpr();
            } else {
                var_v1 = dw_GetExpr(&sp3C, &sp40);
            }
            if ((sp48 != NULL) && ((sp40 < 0) || (sp40 >= 0x401) || (var_v1 != 0))) {
                sp38 = var_v1;
                posterror("code field in trap instruction not in 0..1023", NULL, 2);
            }
            if (var_v1 != 0) {
                sp34 = atflag;
                if (atflag == 0) {
                    posterror("macro expansion needs at register after .set noat", NULL, 1);
                }
                atflag = 0;
                func_00405178(NULL, 0x14CU, 1, 0x48, 2U, 0x48, sp3C);
                func_00405178(NULL, 0x14CU, 1, 0x48, 2U, 0x48, sp40);
                func_00405178(NULL, arg0, sp4C->unk14, 1, 4U, 0x48, 8);
                atflag = sp34;
                return;
            }
            if (sp48 != NULL) {
                func_00405178(NULL, arg0, sp4C->unk14, sp48->unk14, 4U, 0x48, sp40);
                return;
            }
            func_00405178(NULL, arg0, sp4C->unk14, 0x48, 2U, 0x48, sp40);
            return;
        }
        if (sp48 == NULL) {
            posterror("invalid syntax in statement", NULL, 1);
            return;
        }
        func_00405178(NULL, arg0, sp4C->unk14, sp48->unk14, 4U, 0x48, 8);
    }
}

void func_00408C80(u32 arg0) {
    ? *sp54;
    ? *sp50;
    s32 sp4C;
    s32 sp48;
    ? sp44;
    ? *sp40;
    ? *sp3C;
    ? *sp38;
    ? **var_s0;
    ? *temp_t3;
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *temp_v0_4;
    s32 temp_t8;
    s32 temp_v0;
    s32 var_v0;
    u32 var_a2;
    u8 temp_v1;

    var_a2 = arg0;
    if (arg0 == 0x2B) {
        var_a2 = 0x22;
    } else if (var_a2 == 0x32) {
        var_a2 = 0x23;
    }
    sp4C = 0;
    sp54 = NULL;
    sp48 = 0x48;
    sp50 = NULL;
    if (Tokench == 0x69) {
        arg0 = var_a2;
        if (LookUp(Tstring, &sp50, var_a2) == 0) {
            EnterSym(Tstring, &sp50, 1);
        }
        temp_v0 = sp50->unk10;
        if (temp_v0 == 3) {
            if (list_extsyms != 0) {
                func_004054E8(sp50->unk18, (s32) Tstring);
            }
            nexttoken();
            sp3C = NULL;
            temp_v1 = Tokench;
            if ((temp_v1 != 0x2B) && (temp_v1 != 0x2D) && (temp_v1 != 0x23) && (temp_v1 != 0x2C)) {
                posterror("invalid external expression", NULL, 1);
            } else if (temp_v1 != 0x23) {
                if (temp_v1 != 0x2C) {
                    sp4C = GetExpr();
                }
                if (temp_v1 != 0x23) {
                    if (temp_v1 == 0x2C) {
                        nexttoken();
                    }
                    temp_v0_2 = GetRegister();
                    sp3C = temp_v0_2;
                    if ((temp_v0_2 == NULL) || (Tokench == 0x23)) {
                        if (Tokench == 0x23) {
                            posterror("stmt extends past logical end", NULL, 1);
                        }
                    } else {
                        temp_v0_3 = GetRegister();
                        sp40 = temp_v0_3;
                        if (temp_v0_3 != NULL) {
                            if (Tokench != 0x23) {

                            } else {
                                goto block_46;
                            }
                        }
                    }
                } else {
                    goto block_46;
                }
            } else {
                goto block_45;
            }
        } else if (temp_v0 == 0) {
            nexttoken();
            temp_t3 = sp50;
            sp50 = NULL;
            sp54 = temp_t3;
            if (arg0 == 0x23) {
                if (Tokench != (u8) 0x23U) {
                    if (Tokench == 0x2C) {
                        nexttoken();
                        var_s0 = &sp38;
loop_33:
                        var_s0 += 4;
                        temp_v0_4 = GetRegister();
                        *var_s0 = temp_v0_4;
                        if (temp_v0_4 != NULL) {
                            if (var_s0 != &sp44) {
                                if (Tokench == 0x23) {
                                    goto block_37;
                                }
                                goto loop_33;
                            }
block_37:
                            if (var_s0 != &sp40) {
                                temp_t8 = sp54->unk14;
                                sp54 = sp3C;
                                sp48 = temp_t8;
                                if (temp_t8 == sp3C->unk14) {
                                    posterror("JAL should not use same register twice", (u8 *) Tstring, 2);
                                }
                            }
                            goto block_46;
                        }
                    }
                } else {
                    goto block_46;
                }
            } else {
                goto block_45;
            }
        } else {
            if (temp_v0 == 4) {
                sp50 = NULL;
                var_v0 = GetExpr();
                goto block_44;
            }
            posterror("invalid symbol for address", (u8 *) Tstring, 1);
        }
    } else {
        arg0 = var_a2;
        var_v0 = GetExpr(var_a2);
block_44:
        sp4C = var_v0;
block_45:
block_46:
        if (sp54 != NULL) {
            func_00405178(NULL, arg0, sp54->unk14, sp48, 7U, 0x48, 0);
        } else if (sp50 != NULL) {
            func_00405178(sp50->unk18, arg0, 0x48, 0x48, 6U, 0x48, sp4C);
        } else {
            func_00405178(NULL, arg0, 0x48, 0x48, 6U, 0x48, sp4C);
        }
    }
}

s32 func_00409118(s32 *arg0) {
    s32 sp24;
    s32 temp_v0;
    s32 var_v1;
    s32 var_v1_2;

    if ((Tstringlength != 1) || (*Tstring != 0x2E)) {
        return 0;
    }
    nexttoken();
    var_v1 = 0;
    if (Tokench == 0x2D) {
        var_v1 = 1;
        goto block_8;
    }
    if (Tokench != 0x2B) {
        posterror("+/- expected after .", NULL, 1);
        return 1;
    }
block_8:
    sp24 = var_v1;
    nexttoken();
    if (Tokench != 0x64) {
        posterror("branch offset not specified", NULL, 1);
        return 1;
    }
    sp24 = var_v1;
    temp_v0 = GetExpr();
    if (temp_v0 & 3) {
        posterror("relative offset not multiple of 4", NULL, 1);
        return 1;
    }
    if (temp_v0 >= 0x8001) {
        posterror("relative offset beyond 32768", NULL, 1);
        return 1;
    }
    if ((var_v1 != 0) || (temp_v0 == 0)) {
        gform_extn = 4;
        var_v1_2 = temp_v0 / 4;
    } else {
        gform_extn = 3;
        var_v1_2 = (s32) (temp_v0 - 4) / 4;
    }
    *arg0 = var_v1_2;
    return 1;
}

void func_004092FC(u32 arg0) {
    ? *sp5C;
    ? *sp58;
    ? *sp54;
    ? *sp50;
    s32 sp4C;
    s32 sp48;
    s32 sp44;
    s32 sp40;
    s32 sp3C;
    s32 sp38;
    ? *temp_v0;

    sp4C = 0;
    sp58 = NULL;
    temp_v0 = GetRegister();
    sp5C = temp_v0;
    if (temp_v0 != NULL) {
        if ((Tokench == 0x69) && (LookUp(Tstring, &sp50) != 0) && (sp50->unk10 == 0)) {
            sp58 = sp50;
            nexttoken();
            if (Tokench == 0x2C) {
                nexttoken();
            }
        }
        if ((sp58 == NULL) && ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D))) {
            if ((s32) isa < 3) {
                sp40 = 0;
                sp48 = GetExpr();
            } else {
                sp40 = dw_GetExpr(&sp3C, &sp48);
            }
            sp4C = 1;
        }
        if ((sp58 == NULL) && (sp4C == 0)) {
            posterror("invalid syntax in statement", NULL, 1);
            return;
        }
        if (Tokench != 0x69) {
            posterror("label expected", NULL, 1);
            return;
        }
        if (func_00409118(&sp44, NULL) != 0) {
            binasm_rec.unkA = (u16) ((sp44 & 0x3FFF) | (binasm_rec.unkA & 0xC000));
            if (sp4C != 0) {
                func_00405178(NULL, arg0, sp5C->unk14, 0x48, 0xCU, 0x48, sp48);
            } else {
                func_00405178(NULL, arg0, sp5C->unk14, sp58->unk14, 8U, 0x48, 0);
            }
            gform_extn = 0;
            return;
        }
        if (LookUp(Tstring, &sp50) != 0) {
            if (sp50->unk10 == 3) {
                sp54 = sp50;
                goto block_31;
            }
            posterror("symbol is not a label", (u8 *) Tstring, 1);
            return;
        }
        EnterSym(Tstring, &sp54, 1);
block_31:
        if (list_extsyms != 0) {
            if ((*Tstring + &__ctype)->unk1 & 4) {
                func_004054E8(sp54->unk18, 0);
            } else {
                func_004054E8(sp54->unk18, (s32) Tstring);
            }
        }
        nexttoken();
        if (sp4C != 0) {
            sp38 = atflag;
            if (sp40 != 0) {
                if (atflag == 0) {
                    posterror("macro expansion needs at register after .set noat", NULL, 1);
                }
                atflag = 0;
                func_00405178(NULL, 0x14CU, 1, 0x48, 2U, 0x48, sp3C);
                func_00405178(NULL, 0x14CU, 1, 0x48, 2U, 0x48, sp48);
                func_00405178(sp54->unk18, arg0, sp5C->unk14, 1, 8U, 0x48, 0);
                atflag = sp38;
                return;
            }
            func_00405178(sp54->unk18, arg0, sp5C->unk14, 0x48, 0xCU, 0x48, sp48);
            return;
        }
        func_00405178(sp54->unk18, arg0, sp5C->unk14, sp58->unk14, 8U, 0x48, 0);
    }
}

void func_00409850(u32 arg0) {
    ? *sp3C;
    ? *sp38;
    ? *sp34;
    s32 sp30;
    ? *temp_v0;

    if (arg0 == 0xE3) {
        sp3C = reg_ptr->unk0;
        goto block_9;
    }
    temp_v0 = GetRegister();
    sp3C = temp_v0;
    if (temp_v0 != NULL) {
        if (((arg0 == 0xE5) || (arg0 == 0x120) || (arg0 == 0xE4) || (arg0 == 0x124)) && (temp_v0 == reg_ptr->unk7C)) {
            posterror("$31 not allowed in conditional branch and link", NULL, 2);
        }
block_9:
        if (Tokench != 0x69) {
            posterror("label expected", NULL, 1);
            return;
        }
        if (func_00409118(&sp30, NULL) != 0) {
            binasm_rec.unkA = (u16) ((sp30 & 0x3FFF) | (binasm_rec.unkA & 0xC000));
            func_00405178(NULL, arg0, sp3C->unk14, 0x48, 9U, 0x48, 0);
            gform_extn = 0;
            return;
        }
        if (LookUp(Tstring, &sp34) != 0) {
            if (sp34->unk10 == 3) {
                sp38 = sp34;
                goto block_18;
            }
            posterror("symbol is not a label", (u8 *) Tstring, 1, (s32) Tstring);
            return;
        }
        EnterSym(Tstring, &sp38, 1, Tstring);
block_18:
        if (list_extsyms != 0) {
            if ((*Tstring + &__ctype)->unk1 & 4) {
                func_004054E8(sp38->unk18, 0);
            } else {
                func_004054E8(sp38->unk18, (s32) Tstring);
            }
        }
        nexttoken();
        func_00405178(sp38->unk18, arg0, sp3C->unk14, 0x48, 9U, 0x48, 0);
    }
}

void func_00409B10(u32 arg0) {
    ? *sp4C;
    ? *sp48;
    ? *sp44;
    s32 sp3C;
    s32 sp38;
    s32 sp34;
    s32 var_v1;

    if (Tokench != 0x69) {
        posterror("condition code or label expected", NULL, 1);
        return;
    }
    var_v1 = arg0 == 8;
    if (var_v1 == 0) {
        var_v1 = arg0 == 7;
        if (var_v1 == 0) {
            var_v1 = arg0 == 0x128;
            if (var_v1 == 0) {
                var_v1 = arg0 == 0x127;
            }
        }
    }
    sp34 = var_v1;
    if (var_v1 != 0) {
        sp3C = 0x40;
        sp34 = var_v1;
        if ((LookUp(Tstring, &sp44) != 0) && (sp44->unk10 == 0)) {
            nexttoken();
            if (Tokench == 0x2C) {
                nexttoken();
            }
            sp3C = sp44->unk14;
        }
    }
    if (Tokench != 0x69) {
        posterror("label expected", NULL, 1);
        return;
    }
    if (func_00409118(&sp38, NULL) != 0) {
        binasm_rec.unkA = (u16) ((sp38 & 0x3FFF) | (binasm_rec.unkA & 0xC000));
        if (sp34 != 0) {
            func_00405178(NULL, arg0, sp3C, 0x48, 9U, 0x48, 0);
        } else {
            func_00405178(NULL, arg0, 0x48, 0x48, 0xAU, 0x48, 0);
        }
        gform_extn = 0;
        return;
    }
    if (LookUp(Tstring, &sp48) != 0) {
        if (sp48->unk10 == 3) {
            sp4C = sp48;
            goto block_24;
        }
        posterror("symbol is not a label", (u8 *) Tstring, 1);
        return;
    }
    EnterSym(Tstring, &sp4C, 1);
block_24:
    if (list_extsyms != 0) {
        if ((*Tstring + &__ctype)->unk1 & 4) {
            func_004054E8(sp4C->unk18, 0);
        } else {
            func_004054E8(sp4C->unk18, (s32) Tstring);
        }
    }
    nexttoken();
    if (sp34 != 0) {
        func_00405178(sp4C->unk18, arg0, sp3C, 0x48, 9U, 0x48, 0);
        return;
    }
    func_00405178(sp4C->unk18, arg0, 0x48, 0x48, 0xAU, 0x48, 0);
}

void func_00409ECC(u32 arg0, u8 *arg1) {
    u32 sp34;
    u32 temp_v0;
    u8 *var_a1;

    var_a1 = arg1;
    if ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (var_a1 = NULL, (Tokench == 0x2D))) {
        temp_v0 = GetExpr((u32) var_a1);
        if ((temp_v0 >> 0x19) != 0) {
            sp34 = temp_v0;
            posterror("coprocessor operation > 25 bits", NULL, 1);
        }
        func_00405178(NULL, arg0, 0x48, 0x48, 2U, 0x48, (s32) temp_v0);
        return;
    }
    posterror("expression required", NULL, 1);
}

void func_00409FD0(u32 arg0) {
    ? *temp_v0;

    temp_v0 = GetRegister();
    if (temp_v0 != NULL) {
        func_00405178(NULL, arg0, temp_v0->unk14, 0x48, 7U, 0x48, 0);
    }
}

void func_0040A044(s32 arg0) {
    ? *temp_v0;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
    temp_v0 = GetRegister();
    if (temp_v0 != NULL) {
        binasm_rec.unk8 = (u8) ((temp_v0->unk14 * 2) | (binasm_rec.unk8 & 0xFF01));
        put_binasmfyle();
    }
}

void func_0040A0D4(void) {
    s32 temp_v0;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0xF);
    temp_v0 = GetExpr();
    binasm_rec.unk8 = temp_v0;
    if (temp_v0 & 3) {
        posterror("Offset for cprestore must be positive and divisible by 4", NULL, 1);
    }
    put_binasmfyle();
}

void func_0040A160(void) {
    ? *sp24;
    ? *temp_v0;
    ? *var_v1;

    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x21);
    temp_v0 = GetRegister();
    var_v1 = temp_v0;
    if (temp_v0 == NULL) {
        sp24 = temp_v0;
        posterror(".cpalias requires a register argument", NULL, 1);
        var_v1 = sp24;
    }
    binasm_rec.unk8 = (u8) ((var_v1->unk14 * 2) | (binasm_rec.unk8 & 0xFF01));
    put_binasmfyle();
}

void func_0040A208(void) {
    s32 sp24;

    sp24 = GetExpr();
    GetExpr();
    if (sp24 != 3) {
        posterror("version stamp does not match", NULL, 2);
    }
}

void func_0040A280(void) {
    ? *sp34;
    ? *sp30;
    s32 sp2C;
    ? *sp28;
    ? *temp_v0;
    ? *temp_v0_2;

    temp_v0 = GetRegister();
    sp34 = temp_v0;
    if (temp_v0 != NULL) {
        if ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D) || (Tokench == 0x7E) || (Tokench == 0x28)) {
            sp2C = GetExpr();
            if (Tokench != 0x23) {
                temp_v0_2 = GetRegister();
                sp30 = temp_v0_2;
                if (temp_v0_2 == NULL) {
                    return;
                }
                goto block_14;
            }
            sp30 = reg_ptr->unk7C;
block_14:
            if (LookUp((? *) sframereg, &sp28) == 0) {
                posterror("can not find symbol", sframereg, 1);
            }
            sp28->unk8 = (s32) sp34->unk8;
            sp28->unk14 = (s32) sp34->unk14;
            if (LookUp(sframesize, &sp28) == 0) {
                posterror("can not find symbol", (u8 *) sframesize, 1);
            }
            sp28->unk8 = sp2C;
            binasm_rec.unk0 = NULL;
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x2B);
            binasm_rec.unkC = (u8) ((sp34->unk14 * 2) | (binasm_rec.unkC & 0xFF01));
            binasm_rec.unk8 = sp2C;
            binasm_rec.unkC = (s16) (((sp30->unk14 * 4) & 0x1FC) | ((u16) binasm_rec.unkC & 0xFE03));
            put_binasmfyle();
        } else {
            posterror("expression required", NULL, 1);
        }
    }
}

void func_0040A4B0(void) {
    if (LastLabel != NULL) {
        func_00405574(0);
    }
    StructOrg = GetExpr();
    isStruct = 1;
    LastLabel = NULL;
}

void func_0040A530(void) {
    s32 sp24;
    s32 temp_v0;
    s32 var_v1;

    temp_v0 = GetExpr();
    var_v1 = temp_v0;
    if (temp_v0 != 1) {
        sp24 = temp_v0;
        posterror(".shift_addr expression not 1", NULL, 1);
        var_v1 = sp24;
    }
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x39);
    binasm_rec.unk8 = var_v1;
    put_binasmfyle();
    shftaddr = 1;
}

void func_0040A5D4(void) {
    s32 temp_v0;

    temp_v0 = GetExpr();
    if ((temp_v0 < 0) || (temp_v0 >= 0xD)) {
        posterror("align expression not 0..12", NULL, 1);
        return;
    }
    if (isStruct != 0) {
        StructOrg = ((s32) ((StructOrg + (temp_v0 << temp_v0)) - 1) >> temp_v0) << temp_v0;
        return;
    }
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 4);
    binasm_rec.unk8 = temp_v0;
    put_binasmfyle();
}

void func_0040A6B8(s32 arg0) {
    ? **var_s0;
    s32 var_s1;
    s32 var_v0;
    u8 *temp_t2;
    u8 temp_t1;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
    var_v0 = 0x10;
    var_s1 = 0;
    binasm_rec.unk8 = (s32) Tstringlength;
    if (Tstringlength > 0) {
        var_s0 = Tstring;
        do {
            if (var_v0 == 0x10) {
                put_binasmfyle();
                var_v0 = 0;
            }
            temp_t1 = *var_s0;
            var_s1 += 1;
            temp_t2 = &binasm_rec + var_v0;
            var_s0 += 1;
            var_v0 += 1;
            *temp_t2 = temp_t1;
        } while (var_s1 < Tstringlength);
    }
    put_binasmfyle();
}

void func_0040A79C(s32 arg0) {
    s32 temp_t0;
    u8 temp_v0;

    if (LastLabel != NULL) {
        func_00405574(0);
    }
    temp_v0 = Tokench;
    do {
        if (temp_v0 != 0x22) {
            posterror("string literal expected", NULL, 1);
        } else if (isStruct != 0) {
            temp_t0 = StructOrg + Tstringlength;
            StructOrg = temp_t0;
            if (arg0 != 0) {
                StructOrg = temp_t0 + 1;
            }
        } else if (arg0 != 0) {
            func_0040A6B8(6);
        } else {
            func_0040A6B8(5);
        }
        if (temp_v0 != 0x23) {
            nexttoken();
        }
    } while (temp_v0 == 0x2C);
}

void func_0040A958(void) {
    s32 sp4C;
    s32 sp48;
    s32 var_v0;
    s32 var_v0_2;

    if (LastLabel != NULL) {
        func_00405574(0);
    }
    do {
        GetItem(&sp48, &sp4C);
        var_v0 = sp48;
        if (isStruct != 0) {
            var_v0_2 = sp4C;
            if (sp4C <= 0) {
                var_v0_2 = 1;
            }
            StructOrg += var_v0_2;
        } else {
            if (var_v0 >= -0x80) {
                if (var_v0 >= 0x100) {
                    goto block_11;
                }
            } else {
block_11:
                posterror("value must be -128..255", NULL, 1);
                var_v0 = 0;
            }
            binasm_rec.unk0 = NULL;
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 7);
            binasm_rec.unk8 = var_v0;
            binasm_rec.unkC = sp4C;
            sp48 = var_v0;
            put_binasmfyle();
        }
    } while (Tokench != 0x23);
}

void func_0040AAD4(s32 arg0) {
    ? *sp34;
    s32 sp30;
    s32 sp2C;
    s32 sp28;

    if (Tokench != 0x69) {
        posterror("identifer expected", NULL, 1);
        if (Tokench != 0x23) {
            nexttoken();
        }
    } else {
        if (LookUp(Tstring, &sp34) == 0) {
            EnterSym(Tstring, &sp34, arg0 != 9);
        }
        if (list_extsyms != 0) {
            func_004054E8(sp34->unk18, (s32) Tstring);
        }
        nexttoken();
        if (Tokench == 0x2C) {
            nexttoken();
        }
        sp28 = 0;
        if ((arg0 == 0x2D) && (Tokench == 0x23)) {
            sp2C = 0;
        } else {
            sp2C = GetExpr();
        }
        if (Tokench == 0x69) {
            if ((Tstring->unk0 == 0x53) && (Tstring->unk1 == 0)) {
                sp28 = 1;
            } else {
                posterror("optional argument not S, ignored.", NULL, 2);
            }
            nexttoken();
        }
        if (sp34->unk10 != 3) {
            posterror("invalid symbol for .comm/.lcomm/.extern ", (u8 *) Tstring, 1);
        } else {
            binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
            binasm_rec.unk0 = (? *) sp34->unk18;
            binasm_rec.unk8 = sp2C;
            binasm_rec.unkC = sp28;
            put_binasmfyle();
            switch (arg0) {                         /* irregular */
            case 8:
                sp30 = 0x11;
                break;
            case 9:
                sp30 = 0x21;
                break;
            case 45:
                sp30 = 0x22;
                break;
            default:
                assertion_failed("false", "as0parse.c", (s32 *)0xA08);
                break;
            }
            sym_define(sp34->unk18, sp30, sp2C);
        }
    }
}

void func_0040ADFC(void) {
    if (Tokench != 0x69) {
        posterror("identifer expected", NULL, 1);
    } else {
        nexttoken();
        if (Tokench == 0x2C) {
            nexttoken();
        }
        GetExpr();
    }
    if (Tokench != 0x23) {
        nexttoken();
    }
    posterror(".sym directive not implemented", NULL, 2);
}

void func_0040AF00(u32 arg0) {
    ? **var_v0;
    ? **var_v1;
    u8 temp_t6;

    if (LastLabel != NULL) {
        func_00405574(0, arg0);
    }
    isStruct = 0;
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
    if (arg0 == 0x15) {
        if (Tokench != 0x23) {
            binasm_rec.unk8 = (s32) Tstringlength;
        } else {
            binasm_rec.unk8 = 0;
        }
    }
    if ((arg0 == 0x15) && (Tokench != 0x23)) {
        put_binasmfyle();
        if (Tstringlength > 0) {
            var_v0 = Tstring;
            var_v1 = &binasm_rec;
            do {
                temp_t6 = *var_v0;
                var_v0 += 1;
                var_v1 += 1;
                var_v1->unk-1 = temp_t6;
            } while ((u32) var_v0 < (u32) (Tstringlength + Tstring));
        }
        nexttoken();
    }
    put_binasmfyle();
    if (arg0 != 0xA) {
        if (arg0 != 0x15) {
            if (arg0 != 0x19) {
                if (arg0 != 0x1A) {
                    if (arg0 != 0x1A) {
                        assertion_failed("iop == irdata", "as0parse.c", (s32 *)0xA43);
                    }
                } else {
                    CurrentSegment = 0xF;
                }
            } else {
                CurrentSegment = 0xD;
            }
        } else {
            CurrentSegment = 1;
        }
    } else {
        CurrentSegment = 2;
    }
}

void func_0040B0F4(s32 arg0) {
    u8 temp_v0;

    if (LastLabel != NULL) {
        if ((arg0 == 2) || (arg0 == 4)) {
            func_00405574(3);
        } else if (arg0 == 1) {
            func_00405574(2);
        }
    }
    do {
        if (isStruct != 0) {
            if ((arg0 == 4) || (arg0 == 2)) {
                StructOrg += 8;
            } else {
                StructOrg += 4;
            }
            if ((Tokench == 0x2D) || (Tokench == 0x2B)) {
                nexttoken();
            }
            nexttoken();
        } else {
            binasm_rec.unk0 = NULL;
            if (arg0 == 4) {
                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x2C);
            } else if (arg0 == 2) {
                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0xB);
            } else if (arg0 == 1) {
                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0xD);
            }
            func_00407334();
        }
        temp_v0 = Tokench;
        if (temp_v0 == 0x2C) {
            nexttoken();
        }
    } while (temp_v0 != 0x23);
}

void func_0040B340(void) {
    invent_locs = 0;
    GetExpr();
    if (Tokench != 0x22) {
        posterror("string literal expected", NULL, 1);
    }
    make_file((u8 *) Tstring);
    nexttoken();
}

void do_dot_end(s32 arg0) {
    ? *temp_a1;
    ? *temp_s0;

    if ((arg0 == 0) && (D_10000014 == NULL)) {
        posterror(".end without .ent", NULL, 2);
    } else {
        temp_a1 = D_10000014;
        if ((arg0 != 0) && (temp_a1 != NULL)) {
            posterror("missing .end at end of assembly", NULL, 2);
        }
        if (temp_a1 != NULL) {
            do {
                if (sym_undefined(temp_a1->unk0, temp_a1) != 0) {
                    posterror(".ent/.end block never defined the procedure name", NULL, 2);
                } else {
                    binasm_rec.unk0 = st_procend((s32) D_10000014->unk0);
                }
                temp_s0 = D_10000014->unk4;
                free(D_10000014);
                D_10000014 = temp_s0;
                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x18);
                put_binasmfyle();
            } while (D_10000014 != NULL);
        }
    }
}

void func_0040B554(? *arg0) {
    ? *sp24;
    ? *temp_v0;

    sp24 = D_10000014;
    temp_v0 = malloc(8, &D_10000014);
    D_10000014 = temp_v0;
    if (temp_v0 == NULL) {
        new_error();
        return;
    }
    *temp_v0 = arg0;
    D_10000014->unk4 = sp24;
}

void func_0040B5F0(u32 arg0) {
    ? *sp24;
    u8 temp_v1;
    u8 temp_v1_2;

    if (LastLabel != NULL) {
        func_00405574(0);
    }
    isStruct = 0;
    temp_v1 = Tokench;
    if (temp_v1 != 0x69) {
        if (arg0 != 0x18) {
            posterror("identifer expected", NULL, 1);
        } else {
            goto block_6;
        }
    } else {
block_6:
        if ((arg0 == 0x1B) || (arg0 == 0x2E)) {
            if (verbose != 0) {
                call_name_and_line(3);
                fprintf(&__iob + 0x20, "%s ", (s32) Tstring);
                fflush(&__iob + 0x20);
            }
            binasm_rec.unk8 = 0;
            if (arg0 == 0x1B) {
                if (D_10000014 != NULL) {
                    posterror("missing .end preceding this .ent", (u8 *) Tstring, 2);
                    do_dot_end(0);
                }
            } else if (D_10000014 == NULL) {
                posterror(".aent must be inside .ent/.end block", (u8 *) Tstring, 2);
                arg0 = 0x1BU;
            }
            if (LookUp(Tstring, &sp24) == 0) {
                EnterSym(Tstring, &sp24, 1);
            }
            if (sp24->unk10 != 3) {
                posterror("invalid symbol for .[a]ent ", (u8 *) Tstring, 1);
            }
            nexttoken();
            temp_v1_2 = Tokench;
            if (temp_v1_2 == 0x2C) {
                nexttoken();
            }
            if (temp_v1_2 == 0x64) {
                nexttoken();
            }
            sym_define(sp24->unk18, 0x23, 0);
            func_0040B554((? *) sp24->unk18);
            binasm_rec.unk0 = (? *) sp24->unk18;
            binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
            put_binasmfyle();
        } else if (arg0 == 0x18) {
            do_dot_end(0);
        }
        if (temp_v1 == 0x69) {
            nexttoken();
        }
    }
}

void func_0040B984(void) {
    ? *sp3C;
    s32 *sp38;
    s32 *var_s1;
    s32 temp_v0_3;
    u8 temp_v0;
    u8 temp_v0_2;

    var_s1 = sp38;
    temp_v0 = Tokench;
    do {
        if (temp_v0 != 0x69) {
            posterror("identifer expected", NULL, 1);
        } else {
            if (LookUp(Tstring, &sp3C) == 0) {
                EnterSym(Tstring, &sp3C, 1);
            }
            sym_define(sp3C->unk18, 0x22, 0);
            if (sp3C->unk10 == 3) {
                if (list_extsyms != 0) {
                    func_004054E8(sp3C->unk18, (s32) Tstring);
                }
                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 2);
                binasm_rec.unk0 = (? *) sp3C->unk18;
                put_binasmfyle();
                var_s1 = sp3C->unk18;
            } else {
                posterror("invalid symbol for .globl ", (u8 *) Tstring, 1);
            }
        }
        temp_v0_2 = Tokench;
        if (temp_v0_2 != 0x23) {
            nexttoken();
        }
        if (temp_v0_2 == 0x69) {
            if (opLookUp(Tstring, &sp3C) == 0) {
                posterror("bad section name\0\0\0\xad section name", NULL, 1);
            } else if (sp3C->unk10 == 2) {
                temp_v0_3 = sp3C->unk14;
                switch (temp_v0_3) {                /* irregular */
                case 21:
                    sym_define(var_s1, 0x23, 0);
                    break;
                case 10:
                    sym_define(var_s1, 2, 0);
                    break;
                case 25:
                    sym_define(var_s1, 0xD, 0);
                    break;
                case 26:
                    sym_define(var_s1, 0xF, 0);
                    break;
                }
            }
            nexttoken();
        }
    } while (temp_v0_2 == 0x2C);
    sp38 = var_s1;
}

void func_0040BC84(void) {
    ? *sp4C;
    ? *sp48;
    u8 temp_v0;
    u8 temp_v0_2;

    temp_v0 = Tokench;
    do {
        if (temp_v0 != 0x69) {
            posterror("identifer expected", NULL, 1);
        } else {
            if (LookUp(Tstring, &sp4C) == 0) {
                EnterSym(Tstring, &sp4C, 1);
            }
            sym_define(sp4C->unk18, 0x22, 0);
            if (sp4C->unk10 == 3) {
                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x12);
                binasm_rec.unk0 = (? *) sp4C->unk18;
                nexttoken();
                if (Tokench == 0x2C) {
                    nexttoken();
                }
                if (LookUp(Tstring, &sp48) == 0) {
                    EnterSym(Tstring, &sp48, 1);
                }
                if (sp48 != sp4C) {
                    binasm_rec.unk8 = (s32) sp48->unk18;
                } else {
                    binasm_rec.unk8 = 0;
                }
                put_binasmfyle();
            } else {
                posterror("invalid symbol for .globl ", (u8 *) Tstring, 1);
            }
        }
        temp_v0_2 = Tokench;
        if (temp_v0_2 != 0x23) {
            nexttoken();
        }
    } while (temp_v0_2 == 0x2C);
}

s32 func_0040BEBC(? **arg0, s32 *arg1, s32 *arg2) {
    ? *sp24;
    s32 temp_v0;

    if (Tokench == 0x69) {
        if (LookUp(Tstring, &sp24) == 0) {
            EnterSym(Tstring, &sp24, 1);
        }
        temp_v0 = sp24->unk10;
        if (temp_v0 == 4) {
            GetItem(arg1, arg2);
            goto block_11;
        }
        if (temp_v0 == 3) {
            *arg0 = sp24->unk18;
            nexttoken(arg1);
            func_00405A80(arg1, arg2);
            if (Tokench == 0x2C) {
                nexttoken();
            }
            /* Duplicate return node #12. Try simplifying control flow for better match */
            return 1;
        }
        posterror("Bad id in expression", (u8 *) Tstring, 1);
        nexttoken();
        return 0;
    }
    GetItem(arg1, arg2);
block_11:
    return 1;
}

void func_0040C048(void) {
    ? *sp54;
    s32 sp50;
    s32 sp4C;
    s32 temp_t8;
    s32 var_v0;
    s32 var_v1;

    if (LastLabel != NULL) {
        func_00405574(1);
    }
loop_3:
    sp4C = 0;
    sp50 = 1;
    sp54 = NULL;
    if (func_0040BEBC(&sp54, &sp4C, &sp50) != 0) {
        temp_t8 = sp50 * 2;
        if (isStruct != 0) {
            if (temp_t8 < 2) {
                var_v1 = 2;
            } else {
                var_v1 = temp_t8;
            }
            StructOrg += var_v1;
        } else {
            var_v0 = sp4C;
            if (shftaddr == 1) {
                var_v0 = sp4C >> 1;
            }
            if ((var_v0 < -0x8000) || (var_v0 >= 0x10000)) {
                posterror("value must be -32768..65535", NULL, 1);
                sp4C = 0;
            }
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0xE);
            binasm_rec.unk0 = sp54;
            binasm_rec.unk8 = sp4C;
            binasm_rec.unkC = sp50;
            put_binasmfyle();
        }
        if (Tokench == 0x23) {
            shftaddr = 0;
        } else {
            goto loop_3;
        }
    }
}

void func_0040C218(void) {
    s32 temp_v0;

    invent_locs = 0;
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x1C);
    GetExpr();
    binasm_rec.unk8 = (s32) CurrentFile;
    if (Tokench == 0x3A) {
        nexttoken();
    }
    temp_v0 = GetExpr();
    CurrentLine = temp_v0;
    binasm_rec.unkC = temp_v0;
    put_binasmfyle();
}

void func_0040C2E0(void) {
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x13);
    binasm_rec.unk8 = GetExpr();
    binasm_rec.unkC = GetExpr();
    put_binasmfyle();
}

void func_0040C360(void) {
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x32);
    binasm_rec.unk8 = GetExpr();
    binasm_rec.unkC = GetExpr();
    put_binasmfyle();
}

void func_0040C3E0(void) {
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x33);
    binasm_rec.unk8 = GetExpr();
    binasm_rec.unkC = GetExpr();
    put_binasmfyle();
}

void func_0040C460(void) {
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x3C);
    binasm_rec.unk8 = GetExpr();
    put_binasmfyle();
}

void func_0040C4CC(void) {
    ? *sp24;
    ? *temp_t1;
    s32 temp_v0;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x3D);
    temp_v0 = GetExpr();
    binasm_rec.unk8 = temp_v0;
    if (temp_v0 != 0) {
        sp24 = NULL;
        if (LookUp(Tstring, &sp24) == 0) {
            EnterSym(Tstring, &sp24, 0);
        }
        temp_t1 = sp24->unk18;
        sp24 = NULL;
        binasm_rec.unk0 = temp_t1;
        nexttoken();
        if (LookUp(Tstring, &sp24) == 0) {
            EnterSym(Tstring, &sp24, 1);
        }
        binasm_rec.unkC = (? *) sp24->unk18;
    }
    put_binasmfyle();
}

void func_0040C5E8(u32 arg0) {
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
    binasm_rec.unk8 = GetExpr();
    binasm_rec.unkC = GetExpr();
    put_binasmfyle();
}

void func_0040C66C(s32 arg0, s32 arg1) {
    s32 var_s1;
    s32 var_s5;
    u32 temp_v0;
    u32 var_s0;
    void *temp_t1;

    if (isStruct != 0) {
        posterror(".repeat not allowed in struct", NULL, 1);
    } else if (arg0 != 0) {
        if (in_repeat_block != 0) {
            posterror(".repeat may not nest", NULL, 1);
        } else {
            in_repeat_block = 1;
            rep_count = arg1;
            rep_size = 0;
        }
    } else if (in_repeat_block == 0) {
        posterror(".endr without preceding .repeat", NULL, 1);
    } else {
        in_repeat_block = 0;
        var_s5 = rep_count;
        if (var_s5 != 0) {
            temp_v0 = rep_size;
            do {
                var_s0 = 0;
                if (temp_v0 != 0) {
                    var_s1 = 0;
                    do {
                        temp_t1 = rep_buffer + var_s1;
                        binasm_rec.unk0 = temp_t1->unk0;
                        binasm_rec.unk4 = (s32) temp_t1->unk4;
                        binasm_rec.unk8 = (s32) temp_t1->unk8;
                        binasm_rec.unkC = (s32) temp_t1->unkC;
                        put_binasmfyle();
                        var_s0 += 1;
                        var_s1 += 0x10;
                    } while (var_s0 < (u32) rep_size);
                }
                var_s5 -= 1;
            } while (var_s5 != 0);
        }
    }
}

void func_0040C830(u32 arg0) {
    if (LastLabel != NULL) {
        func_00405574(0, arg0);
    }
    isStruct = 0;
    binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
    if (arg0 == 0x24) {
        if (Tokench == 0x69) {
            nexttoken();
            return;
        }
        posterror("identifier expected", NULL, 1);
        return;
    }
    binasm_rec.unk0 = GetExpr();
}

void func_0040C928(void) {
    ? *sp24;
    ? *temp_v0;

    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x25);
    temp_v0 = GetRegister();
    sp24 = temp_v0;
    if (temp_v0 != NULL) {
        binasm_rec.unkC = GetExpr();
        binasm_rec.unk0 = GetExpr();
        binasm_rec.unk8 = (u8) ((sp24->unk14 * 2) | (binasm_rec.unk8 & 0xFF01));
    }
}

void func_0040C9D0(void) {
    s32 sp24;
    ? *sp20;
    ? *temp_v0;

    if (Tokench != 0x69) {
        posterror(".option name expected", NULL, 2);
        return;
    }
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x2F);
    temp_v0 = malloc(Tstringlength + 2);
    sp20 = temp_v0;
    *temp_v0 = 0x2D;
    strcpy(temp_v0 + 1, Tstring);
    sp24 = which_opt((u8 *) sp20);
    free(sp20);
    nexttoken();
    switch (sp24) {                                 /* irregular */
    case 0x7:
        binasm_rec.unkC = 0;
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x40);
        break;
    case 0x8:
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x40);
        binasm_rec.unkC = 1;
        break;
    case 0x6:
    case 0x9:
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x40);
        binasm_rec.unkC = 2;
        break;
    case 0xA:
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x40);
        binasm_rec.unkC = 3;
        break;
    case 0xB:
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x40);
        binasm_rec.unkC = 4;
        break;
    case 0x57:
        binasm_rec.unkC = 0;
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x80);
        break;
    case 0x58:
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x80);
        binasm_rec.unkC = 1;
        break;
    case 0x59:
        binasm_rec.unk6 = (u8) ((binasm_rec.unk6 & 0xFF3F) | 0x80);
        binasm_rec.unkC = 2;
        break;
    default:
        posterror("Unknown name in .option", NULL, 2);
        break;
    }
    put_binasmfyle();
}

s32 func_0040CC44(? *arg0) {
    ? **var_s1;
    s32 var_s0;

    var_s1 = sset_value;
    var_s0 = 0;
loop_1:
    if (strcmp(arg0, *var_s1) == 0) {
        return var_s0;
    }
    var_s0 += 1;
    var_s1 += 4;
    if (var_s0 == 0x11) {
        return 0;
    }
    goto loop_1;
}

void func_0040CCCC(void) {
    s32 temp_v0;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x20);
    if (Tokench != 0x69) {
        posterror(".set option expected", NULL, 2);
    } else {
        temp_v0 = func_0040CC44(Tstring, &binasm_rec);
        binasm_rec.unk8 = temp_v0;
        switch (temp_v0) {                          /* irregular */
        case 5:
            atflag = 1;
            break;
        case 6:
            atflag = 0;
            break;
        case 0:
            posterror("unknown option in .set", (u8 *) Tstring, 2);
            break;
        }
        nexttoken();
    }
    put_binasmfyle();
}

void func_0040CDE4(s32 arg0) {
    ? *temp_v0;
    ? *temp_v0_2;

    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((arg0 & 0x3F) | (binasm_rec.unk5 & 0xFFC0));
    temp_v0 = GetRegister();
    if (temp_v0 != NULL) {
        binasm_rec.unk6 = (u8) ((temp_v0->unk14 * 2) | (binasm_rec.unk6 & 0xFF01));
        temp_v0_2 = GetRegister();
        if (temp_v0_2 != NULL) {
            binasm_rec.unk6 = (s16) (((temp_v0_2->unk14 * 4) & 0x1FC) | ((u16) binasm_rec.unk6 & 0xFE03));
            put_binasmfyle();
        }
    }
}

void func_0040CEB4(void) {
    s32 temp_v0;
    s32 temp_v1;
    s32 var_v1;

    if (LastLabel != NULL) {
        func_00405574(0);
    }
    temp_v0 = GetExpr();
    temp_v1 = temp_v0;
    if (isStruct != 0) {
        var_v1 = temp_v0;
        if (temp_v0 < 0) {
            var_v1 = 0;
        }
        StructOrg += var_v1;
        return;
    }
    binasm_rec.unk0 = NULL;
    binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x14);
    binasm_rec.unk8 = temp_v1;
    binasm_rec.unkC = 0;
    put_binasmfyle();
}

void func_0040CF9C(void) {
    ? *sp54;
    s32 sp50;
    s32 sp4C;
    s32 temp_t9;
    s32 var_v1;

    if (LastLabel != NULL) {
        func_00405574(2);
    }
loop_3:
    sp4C = 0;
    sp50 = 1;
    sp54 = NULL;
    if (func_0040BEBC(&sp54, &sp4C, &sp50) != 0) {
        if (isStruct != 0) {
            temp_t9 = sp50 * 4;
            if (temp_t9 < 4) {
                var_v1 = 4;
            } else {
                var_v1 = temp_t9;
            }
            StructOrg += var_v1;
        } else {
            binasm_rec.unk0 = sp54;
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x16);
            binasm_rec.unk8 = sp4C;
            binasm_rec.unkC = sp50;
            put_binasmfyle();
        }
        if (Tokench == 0x23) {

        } else {
            goto loop_3;
        }
    }
}

void func_0040D110(void) {
    ? *sp54;
    s32 sp50;
    s32 sp4C;
    s32 temp_t9;
    s32 var_v1;

    if (LastLabel != NULL) {
        func_00405574(2);
    }
loop_3:
    sp4C = 0;
    sp50 = 1;
    sp54 = NULL;
    if (func_0040BEBC(&sp54, &sp4C, &sp50) != 0) {
        if (isStruct != 0) {
            temp_t9 = sp50 * 4;
            if (temp_t9 < 4) {
                var_v1 = 4;
            } else {
                var_v1 = temp_t9;
            }
            StructOrg += var_v1;
        } else {
            binasm_rec.unk0 = sp54;
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x10);
            binasm_rec.unk8 = sp4C;
            binasm_rec.unkC = sp50;
            put_binasmfyle();
        }
        if (Tokench == 0x23) {

        } else {
            goto loop_3;
        }
    }
}

void func_0040D284(? *arg0) {
    ? *sp24;
    s32 temp_v0;

    if (LookUp(&sp24) == 0) {
        EnterSym(arg0, &sp24, 0);
    }
    temp_v0 = sp24->unk10;
    if ((temp_v0 != 3) && (temp_v0 != 4)) {
        posterror("Reserved name used as label", (u8 *) arg0, 1);
        return;
    }
    sym_define(sp24->unk18, CurrentSegment, 0);
    binasm_rec.unk5 = (u8) (binasm_rec.unk5 & 0xFFC0);
    binasm_rec.unk0 = (? *) sp24->unk18;
    if (list_extsyms != 0) {
        if ((*arg0 + &__ctype)->unk1 & 4) {
            func_004054E8(sp24->unk18, 0);
        } else {
            func_004054E8(sp24->unk18, (s32) arg0);
        }
    }
    put_binasmfyle();
}

void Parsestmt(void) {
    u8 sp38;
    ? *sp34;
    s32 temp_v0;
    u32 temp_a0;
    u32 temp_a0_2;
    u32 temp_t3;
    u8 temp_v1;

    nexttoken();
    strcpy(&sp38, Tstring);
    temp_v1 = Tokench;
    if (temp_v1 != 0x23) {
        if (invent_locs != 0) {
            binasm_rec.unk0 = NULL;
            binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x1C);
            binasm_rec.unk8 = (s32) CurrentFile;
            binasm_rec.unkC = (s32) CurrentLine;
            put_binasmfyle();
        }
        if (temp_v1 == 0x64) {
            make_local_label(Tstring, &Tstringlength);
            strcpy(&sp38, Tstring);
            nexttoken();
            if (Tokench != 0x3A) {
                posterror("colon must follow a local label", NULL, 1);
            } else {
                goto block_10;
            }
        } else if (temp_v1 != 0x69) {
            posterror("malformed statement", NULL, 1);
        } else {
            nexttoken();
block_10:
            if (Tokench == 0x3D) {
                func_004056DC(&sp38);
            } else if (Tokench == 0x3A) {
                if (isStruct != 0) {
                    func_004055D4(&sp38);
                } else {
                    func_0040D284((? *) &sp38);
                }
                nexttoken();
                if (Tokench != 0x23) {
                    if (Tokench != 0x69) {
                        posterror("malformed statement", NULL, 1);
                    } else {
                        strcpy(&sp38, Tstring);
                        nexttoken();
                        goto block_21;
                    }
                }
            } else {
block_21:
                if (opLookUp((? *) &sp38, &sp34) == 0) {
                    posterror("undefined assembler operation", &sp38, 1);
                } else {
                    temp_v0 = sp34->unk10;
                    if (temp_v0 == 2) {
                        temp_a0 = sp34->unk14;
                        switch (temp_a0) {          /* switch 1 */
                        case 0xA:                   /* switch 1 */
                        case 0x15:                  /* switch 1 */
                        case 0x19:                  /* switch 1 */
                        case 0x1A:                  /* switch 1 */
                            func_0040AF00(temp_a0, &sp38);
                            break;
                        case 0x4:                   /* switch 1 */
                            func_0040A5D4(temp_a0, &sp38);
                            break;
                        case 0x5:                   /* switch 1 */
                            func_0040A79C(0, &sp38);
                            break;
                        case 0x6:                   /* switch 1 */
                            func_0040A79C(1, &sp38);
                            break;
                        case 0x7:                   /* switch 1 */
                            func_0040A958(temp_a0, &sp38);
                            break;
                        case 0x8:                   /* switch 1 */
                            func_0040AAD4(8, &sp38);
                            break;
                        case 0xD:                   /* switch 1 */
                            func_0040B0F4(1, &sp38);
                            break;
                        case 0xB:                   /* switch 1 */
                            func_0040B0F4(2, &sp38);
                            break;
                        case 0x2C:                  /* switch 1 */
                            func_0040B0F4(4, &sp38);
                            break;
                        case 0x2:                   /* switch 1 */
                            func_0040B984(temp_a0, &sp38);
                            break;
                        case 0x12:                  /* switch 1 */
                            func_0040BC84(temp_a0, &sp38);
                            break;
                        case 0xE:                   /* switch 1 */
                            func_0040C048(temp_a0, &sp38);
                            break;
                        case 0x9:                   /* switch 1 */
                            func_0040AAD4(9, &sp38);
                            break;
                        case 0x2D:                  /* switch 1 */
                            func_0040AAD4(0x2D, &sp38);
                            break;
                        case 0x2F:                  /* switch 1 */
                            func_0040C9D0(temp_a0, &sp38);
                            break;
                        case 0x20:                  /* switch 1 */
                            func_0040CCCC(temp_a0, &sp38);
                            break;
                        case 0x14:                  /* switch 1 */
                            func_0040CEB4(temp_a0, &sp38);
                            break;
                        case 0x16:                  /* switch 1 */
                            func_0040CF9C(temp_a0, &sp38);
                            break;
                        case 0x3B:                  /* switch 1 */
                            func_00406034(temp_a0, &sp38);
                            break;
                        case 0x18:                  /* switch 1 */
                        case 0x1B:                  /* switch 1 */
                        case 0x2E:                  /* switch 1 */
                            func_0040B5F0(temp_a0, &sp38);
                            break;
                        case 0x1D:                  /* switch 1 */
                        case 0x1E:                  /* switch 1 */
                        case 0x24:                  /* switch 1 */
                            func_0040C830(temp_a0, &sp38);
                            break;
                        case 0x1C:                  /* switch 1 */
                            func_0040C218(temp_a0, &sp38);
                            break;
                        case 0x25:                  /* switch 1 */
                            func_0040C928(temp_a0, &sp38);
                            break;
                        case 0x22:                  /* switch 1 */
                            func_0040C66C(1, GetExpr(temp_a0, &sp38));
                            break;
                        case 0x23:                  /* switch 1 */
                            func_0040C66C(0, 0);
                            break;
                        case 0x28:                  /* switch 1 */
                            posterror(".err directive encountered", NULL, 1);
                            break;
                        case 0x1:                   /* switch 1 */
                            func_0040ADFC(temp_a0, &sp38);
                            break;
                        case 0x26:                  /* switch 1 */
                            func_0040C5E8(0x26U, &sp38);
                            break;
                        case 0x27:                  /* switch 1 */
                            func_0040C5E8(0x27U, &sp38);
                            break;
                        case 0x34:                  /* switch 1 */
                            func_0040A4B0(temp_a0, &sp38);
                            break;
                        case 0x2B:                  /* switch 1 */
                            func_0040A280(temp_a0, &sp38);
                            break;
                        case 0x2A:                  /* switch 1 */
                            func_0040A208(temp_a0, &sp38);
                            break;
                        case 0xC:                   /* switch 1 */
                            func_0040B340(temp_a0, &sp38);
                            break;
                        case 0x32:                  /* switch 1 */
                            func_0040C360(temp_a0, &sp38);
                            break;
                        case 0x33:                  /* switch 1 */
                            func_0040C3E0(temp_a0, &sp38);
                            break;
                        case 0x13:                  /* switch 1 */
                            func_0040C2E0(temp_a0, &sp38);
                            break;
                        case 0x30:                  /* switch 1 */
                            func_0040CDE4(0x30, &sp38);
                            break;
                        case 0x31:                  /* switch 1 */
                            func_0040CDE4(0x31, &sp38);
                            break;
                        case 0x35:                  /* switch 1 */
                        case 0x36:                  /* switch 1 */
                        case 0x37:                  /* switch 1 */
                        case 0x38:                  /* switch 1 */
                            func_0040C5E8(temp_a0, &sp38);
                            break;
                        case 0x39:                  /* switch 1 */
                            if (mednat != 0) {
                                func_0040A530(temp_a0, &sp38, (s32 *)0xDD1);
                            } else {
                                assertion_failed("false", "as0parse.c", (s32 *)0xDD1);
                            }
                            break;
                        case 0x3A:                  /* switch 1 */
                            if (mednat != 0) {
                                binasm_rec.unk5 = (u8) ((binasm_rec.unk5 & 0xFFC0) | 0x3A);
                                put_binasmfyle(temp_a0, &sp38, (s32 *)0xDD9);
                            } else {
                                assertion_failed("false", "as0parse.c", (s32 *)0xDD9);
                            }
                            break;
                        case 0x3C:                  /* switch 1 */
                            func_0040C460(temp_a0, &sp38);
                            break;
                        case 0x3D:                  /* switch 1 */
                            func_0040C4CC(temp_a0, &sp38);
                            break;
                        case 0x3:                   /* switch 1 */
                            func_0040A044(3, &sp38);
                            break;
                        case 0xF:                   /* switch 1 */
                            func_0040A0D4(temp_a0, &sp38);
                            break;
                        case 0x11:                  /* switch 1 */
                            func_0040A044(0x11, &sp38);
                            break;
                        case 0x10:                  /* switch 1 */
                            func_0040D110(temp_a0, &sp38);
                            break;
                        case 0x21:                  /* switch 1 */
                            func_0040A160(temp_a0, &sp38);
                            break;
                        default:                    /* switch 1 */
                            assertion_failed("false", "as0parse.c", (s32 *)0xDF1);
                            break;
                        }
                        if ((printedline == 0) && (Tokench != 0x23)) {
                            posterror("stmt extends past logical end", NULL, 1);
                        }
                    } else if (temp_v0 == 1) {
                        temp_t3 = sp34->unk18;
                        temp_a0_2 = sp34->unk14;
                        switch (temp_t3) {          /* switch 2 */
                        case 0:                     /* switch 2 */
                            func_004058F0(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 5:                     /* switch 2 */
                            func_00408C80(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 10:                    /* switch 2 */
                            func_00409FD0(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 4:                     /* switch 2 */
                            func_0040848C((s32) temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 3:                     /* switch 2 */
                            func_00407A20(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 1:                     /* switch 2 */
                            func_00406728(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 12:                    /* switch 2 */
                            func_00406FE8(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 2:                     /* switch 2 */
                            func_004076A0(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 11:                    /* switch 2 */
                            func_004075CC(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 8:                     /* switch 2 */
                            func_00409B10(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 7:                     /* switch 2 */
                            func_00409850(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 6:                     /* switch 2 */
                            func_004092FC(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 9:                     /* switch 2 */
                            func_00409ECC(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 13:                    /* switch 2 */
                            func_004088B8(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 15:                    /* switch 2 */
                            func_00406C48(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 14:                    /* switch 2 */
                            func_004061F8(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 16:                    /* switch 2 */
                            func_004085D8(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        case 17:                    /* switch 2 */
                            func_004086EC(temp_a0_2, &sp38, (s32 *)0xE30);
                            break;
                        default:                    /* switch 2 */
                            assertion_failed("false", "as0parse.c", (s32 *)0xE30);
                            break;
                        }
                        if ((printedline == 0) && (Tokench != 0x23)) {
                            posterror("stmt extends past logical end", NULL, 1);
                        }
                    } else {
                        posterror("assembler op/directive expected", &sp38, 1);
                    }
                }
            }
        }
    }
}

void func_0040E180(? *arg0, u32 arg1, s32 arg2) {
    ? *sp20;

    sprintf(&sp20, arg0, arg1);
    postcerror(&sp20, arg2);
}

s32 sym_undefined(void) {
    s32 sp34;
    u32 sp30;
    s32 sp2C;
    s32 sp28;

    st_sym_idn(&sp30, &sp2C, &sp34, &sp28);
    return sp30 == 0;
}

void func_0040E230(u32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    void *sp2C;
    s32 sp20;
    s32 *temp_v0;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 var_a1;
    void *temp_v0_2;

    temp_v0 = st_pdn_idn();
    if (temp_v0->unk0 == 0x7FFFFFFF) {
        if ((arg1 == 0xE) || (var_a1 = arg1 == 6, (var_a1 != 0))) {
            var_a1 = arg4 != 0;
        }
        sp20 = var_a1;
        temp_v0_2 = st_pext_iext(temp_v0->unk4, var_a1);
        temp_v0_2->unkC = (u8) ((arg1 * 4) | (temp_v0_2->unkC & 0xFF03));
        temp_v0_2->unkC = (s16) (((arg2 << 5) & 0x3E0) | ((u16) temp_v0_2->unkC & 0xFC1F));
        if (D_10000020 != 0) {
            if (temp_v0_2->unk8 < arg3) {
                goto block_7;
            }
        } else {
block_7:
            temp_v0_2->unk8 = arg3;
        }
        if (var_a1 != 0) {
            sp20 = var_a1;
            sp2C = temp_v0_2;
            temp_v1 = (s32) temp_v0_2->unkC;
            temp_v0_2->unkC = (s32) (((u32) ((st_auxisymadd(-1, var_a1, temp_v0_2) ^ temp_v1) << 0xC) >> 0xC) ^ temp_v1);
        } else {
            temp_v1_2 = (s32) temp_v0_2->unkC;
            temp_v0_2->unkC = (s32) (((u32) ((temp_v1_2 ^ 0xFFFFF) << 0xC) >> 0xC) ^ temp_v1_2);
        }
        if (var_a1 != 0) {
            sp2C = temp_v0_2;
            temp_v0_2->unk2 = st_currentifd();
            st_auxbtadd(0);
        }
    } else {
        postcerror("Expected global in change_global()", 0);
    }
}

void func_0040E3F0(u32 arg1, u32 arg2, u32 arg3) {
    s32 *sp2C;
    s32 *temp_v0;
    void *temp_s0;

    temp_v0 = st_pdn_idn();
    sp2C = temp_v0;
    if (*temp_v0 != 0x7FFFFFFF) {
        postcerror("Expected global in data_localize", 0);
    }
    temp_s0 = st_pext_iext(sp2C->unk4);
    if ((arg1 == 0xE) || (arg1 == 6)) {
        postcerror("Expected non-Proc in data_localize", 0);
    }
    sp2C->unk4 = st_symadd(st_stradd(st_str_extiss(temp_s0->unk4)), arg3, arg1, arg2, 0xFFFFF);
    sp2C->unk0 = st_currentifd();
    temp_s0->unkC = (u8) (temp_s0->unkC & 0xFF03);
    temp_s0->unkC = (s16) ((u16) temp_s0->unkC & 0xFC1F);
}

void func_0040E554(u32 arg1, u32 arg2, u32 arg3, s32 arg4) {
    s32 *sp44;
    s32 sp3C;
    s32 sp38;
    s32 sp34;
    s32 sp2C;
    s32 *temp_v0;
    s32 temp_a1;
    s32 temp_v0_3;
    s32 var_v1;
    s32 var_v1_2;
    void *temp_s0;
    void *temp_v0_2;

    temp_v0 = st_pdn_idn();
    sp44 = temp_v0;
    if (*temp_v0 != 0x7FFFFFFF) {
        postcerror("Expected global in text_localize", 0);
    }
    temp_v0_2 = st_pext_iext(sp44->unk4);
    temp_a1 = arg1 == 0xE;
    temp_s0 = temp_v0_2;
    if ((temp_a1 != 0) || (var_v1 = arg1 == 6, (var_v1 != 0))) {
        var_v1 = (temp_v0_2->unkC & 0xFFFFF) == 0xFFFFF;
        if (var_v1 != 0) {
            var_v1 = arg4 != 0;
        }
    }
    sp3C = var_v1;
    sp2C = temp_a1;
    sp38 = var_v1;
    sp34 = st_stradd(st_str_extiss(temp_s0->unk4, temp_a1, arg1));
    if (var_v1 != 0) {
        var_v1_2 = st_auxisymadd(-1);
    } else {
        var_v1_2 = temp_s0->unkC & 0xFFFFF;
    }
    sp44->unk4 = st_symadd(sp34, arg3, arg1, arg2, var_v1_2);
    if (sp3C != 0) {
        st_auxbtadd(0);
    }
    sp44->unk0 = st_currentifd();
    temp_s0->unkC = (s8) ((u8) temp_s0->unkC & 0xFF03);
    temp_s0->unkC = (s16) ((u16) temp_s0->unkC & 0xFC1F);
    if (sp2C != 0) {
        temp_v0_3 = temp_s0->unkC;
        temp_s0->unkC = (s32) (((u32) ((temp_v0_3 ^ 0xFFFFF) << 0xC) >> 0xC) ^ temp_v0_3);
    }
}

? *func_0040E760(void) {
    ? *sp24;
    ? *temp_v0;

    temp_v0 = malloc();
    sp24 = temp_v0;
    if (temp_v0 == NULL) {
        perror("check_malloc");
        exit(2);
    }
    return sp24;
}

void sym_init(s32 arg0) {
    st_cuinit();
    D_10000024 = arg0 != 0;
}

void sym_finish(? *arg0, u8 *arg1) {
    s32 sp60;
    s32 sp5C;
    s32 sp58;
    ? sp54;
    s32 temp_v0;
    u32 *var_s0;
    u32 temp_a1;
    u8 *temp_v0_2;

    if (arg1 == NULL) {
        temp_v0 = strlen();
        temp_v0_2 = strcpy(func_0040E760(temp_v0) + 3, arg0);
        arg1 = temp_v0_2;
        if ((temp_v0 + arg0)->unk-1 == 0x47) {
            temp_v0_2[temp_v0].unk-1 = 0x54;
        } else {
            strcat(arg1, ".T");
        }
    }
    var_s0 = (u32 *)2;
    if (st_currentpchdr()->unk3C >= 3) {
        do {
            temp_a1 = st_sym_idn(var_s0, &sp5C, &sp58, &sp60, &sp54);
            if (sp5C == 0) {
                if (sp58 == 0) {
                    func_0040E230((u32) var_s0, 1, sp5C, sp60, 1);
                } else if ((sp58 != 1) && (sp58 != 6)) {
                    func_0040E180("Symbol %s never defined", temp_a1, 1, sp60);
                }
            }
            var_s0 += 1;
        } while ((s32) var_s0 < st_currentpchdr()->unk3C);
    }
    st_endallfiles();
    st_writebinary(arg1, -1);
}

void sym_enter(u8 *arg1) {
    st_idn_index_fext(st_extadd(st_extstradd(), 0, 0, 0, 0xFFFFF), 1);
}

? sym_define(u32 arg0, u32 arg1, s32 arg2) {
    s32 sp3C;
    u32 sp38;
    s32 sp34;
    s32 sp30;
    u32 sp2C;

    sp2C = st_sym_idn(&sp38, &sp34, &sp3C, &sp30);
    switch (arg1) {
    case 5:
        if ((sp34 == 0) && (sp38 == 0)) {
            func_0040E554(arg0, 2U, 5U, sp3C, 1);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 0)) {
            func_0040E230(arg0, 1, 5, sp3C, 1);
block_78:
            return 1;
        }
        func_0040E180("Conflicting definition of symbol %s", sp2C, 1, arg2);
        return 0;
    case 1:
        if ((sp34 == 0) && (sp38 == 0)) {
            func_0040E554(arg0, 5U, 1U, sp3C, 0);
            goto block_78;
        }
        if (sp34 == 0xE) {
            if (sp38 == 0) {
                func_0040E554(arg0, 0xEU, 1U, sp3C, 1);
                st_procbegin(arg0);
                st_pdadd_idn(arg0);
                goto block_78;
            }
            goto block_16;
        }
block_16:
        if ((sp34 == 6) && (sp38 == 0)) {
            func_0040E230(arg0, 6, 0, sp3C, 1);
            st_procbegin(arg0);
            st_pdadd_idn(arg0);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 0)) {
            func_0040E230(arg0, 5, 1, sp3C, 0);
            goto block_78;
        }
        func_0040E180("Conflicting definition of symbol %s", sp2C, 1, arg2);
        return 0;
    case 2:
    case 13:
    case 15:
        if (sp34 == 0) {
            if (sp38 == 0) {
                func_0040E3F0(arg0, 2U, arg1, sp3C);
                goto block_78;
            }
            goto block_27;
        }
block_27:
        if ((sp34 == 1) && (sp38 == 0)) {
            func_0040E230(arg0, 1, (s32) arg1, sp3C, 1);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 0x11)) {
            func_0040E230(arg0, 1, (s32) arg1, sp3C, 1);
            goto block_78;
        }
        func_0040E180("Conflicting definition of symbol %s", sp2C, 1, arg2);
        return 0;
    case 17:
        if ((sp34 == 0) && (sp38 == 0)) {
            func_0040E230(arg0, 1, 0x11, arg2, 1);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 0)) {
            func_0040E230(arg0, 1, 0x11, arg2, 1);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 0x11)) {
            D_10000020 = 1;
            func_0040E230(arg0, 1, 0x11, arg2, 1);
            D_10000020 = 0;
            goto block_78;
        }
        func_0040E180("Cannot use .comm on previously defined symbol %s", sp2C, 1, arg2);
        return 0;
    case 33:
        if (sp34 == 0) {
            if (sp38 == 0) {
                func_0040E3F0(arg0, 2U, 0x11U, arg2);
                goto block_78;
            }
            goto block_48;
        }
block_48:
        if ((sp34 == 1) && (sp38 == 0)) {
            func_0040E230(arg0, 1, 3, arg2, 1);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 3)) {
            D_10000020 = 1;
            func_0040E230(arg0, 1, 3, arg2, 1);
            D_10000020 = 0;
            goto block_78;
        }
        func_0040E180("Cannot use .lcomm on previously defined symbol %s", sp2C, 1, arg2);
        return 0;
    case 34:
        if ((sp34 == 0) && (sp38 == 0)) {
            func_0040E230(arg0, 1, 0, sp3C, 1);
            goto block_78;
        }
        if (((sp34 != 1) || (sp38 != 0)) && ((sp34 != 1) || (sp38 != 0x11))) {
            if ((sp34 == 0xE) && (sp38 == 0)) {
                func_0040E230(arg0, 6, 0, sp3C, 1);
                goto block_78;
            }
            func_0040E180(".globl must precede the definition of the symbol %s", sp2C, 1, arg2);
            return 0;
        }
        goto block_78;
    case 35:
        if ((sp34 == 0) && (sp38 == 0)) {
            func_0040E230(arg0, 0xE, 0, sp3C, 1);
            goto block_78;
        }
        if ((sp34 == 1) && (sp38 == 0)) {
            func_0040E230(arg0, 6, 0, sp3C, 1);
            goto block_78;
        }
        func_0040E180(".ent must precede the definition of the symbol %s", sp2C, 1, arg2);
        return 0;
    case 0:
        if ((sp34 == 0) && (sp38 == 0)) {
            goto block_78;
        }
        postcerror("scNil to scNil", 0, arg1, arg2);
        return 0;
    default:
        postcerror("Internal: bad action in sym_define", 0, arg1, arg2);
        return 0;
    }
}

void st_feinit(void) {

}

void itoa(u32 arg0, ? *arg1) {
    sprintf(arg1, "%d", arg0);
}

u32 hex_to_num(u8 arg0) {
    s32 var_v1;
    u8 temp_a0;

    temp_a0 = tolower(arg0);
    if ((arg0 + &__ctype)->unk1 & 4) {
        var_v1 = 0x30;
    } else {
        var_v1 = 0x57;
    }
    return temp_a0 - var_v1;
}

void make_local_label(? *arg0, s32 *arg1) {
    u32 sp2C;
    s32 sp28;
    s32 sp24;
    u8 sp23;
    s32 *temp_v1;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1_2;
    s32 var_a2_2;
    s32 var_a3;
    u32 temp_lo;
    u32 temp_lo_2;
    u32 temp_lo_3;
    u32 temp_lo_4;
    u32 temp_v0;
    u32 var_a2;
    u32 var_a3_2;
    void *temp_a1;
    void *temp_t0;
    void *var_a0;

    sp24 = strlen();
    if (strcmp(token_tmp, arg0) != 0) {
        strcpy((u8 *) token_tmp, arg0);
    }
    temp_v0 = atol(token_tmp);
    var_a2 = temp_v0;
    sp23 = (token_tmp + sp24)->unk-1;
    if (temp_v0 >= 0x100U) {
        posterror("Local label number is out of range\0\0No such label", (u8 *) token_tmp, 1);
        var_a2 = 0;
    }
    sp2C = var_a2;
    ltoa(var_a2, token_tmp, var_a2);
    if (sp23 == 0x62) {
        var_a3 = local_label[var_a2] - 1;
    } else if (sp23 == 0x66) {
        var_a3 = local_label[var_a2];
    } else {
        temp_v1 = &local_label[var_a2];
        temp_v0_2 = *temp_v1;
        var_a3 = temp_v0_2;
        if (temp_v0_2 >= 0x7FFFFFFF) {
            sp28 = var_a3;
            posterror("Too many local labels", (u8 *) token_tmp, 1, var_a3);
        } else {
            *temp_v1 = temp_v0_2 + 1;
        }
    }
    sp28 = var_a3;
    temp_v0_3 = strlen(token_tmp);
    *(token_tmp + temp_v0_3) = 0x24;
    temp_v1_2 = temp_v0_3 + 0xB;
    *arg1 = temp_v1_2;
    temp_lo = (u32) var_a3 / 10U;
    temp_a1 = token_tmp + temp_v0_3 + 1;
    *(token_tmp + temp_v1_2) = 0;
    temp_t0 = temp_a1 + 9;
    var_a2_2 = 8;
    var_a0 = (temp_a1 + 8) - 1;
    temp_t0->unk0 = (s8) (((u32) var_a3 % 10U) + 0x30);
    var_a3_2 = temp_lo / 10U;
    temp_t0->unk-1 = (s8) ((temp_lo % 10U) + 0x30);
    do {
        temp_lo_2 = var_a3_2 / 10U;
        var_a2_2 -= 4;
        var_a0 -= 4;
        var_a0->unk4 = (s8) ((var_a3_2 % 10U) + 0x30);
        temp_lo_3 = temp_lo_2 / 10U;
        var_a0->unk3 = (s8) ((temp_lo_2 % 10U) + 0x30);
        temp_lo_4 = temp_lo_3 / 10U;
        var_a0->unk2 = (s8) ((temp_lo_3 % 10U) + 0x30);
        var_a3_2 = temp_lo_4 / 10U;
        var_a0->unk1 = (s8) ((temp_lo_4 % 10U) + 0x30);
    } while (var_a2_2 != 0);
    if (strcmp(token_tmp, arg0, var_a2_2, var_a3_2) != 0) {
        strcpy((u8 *) arg0, token_tmp);
    }
}

void unscan(u8 arg0) {
    save.unk0 = (u8) Tokench;
    strcpy(&save + 1, Tstring);
    save.unk404 = (s32) Tstringlength;
    Tokench = arg0;
}

void make_file(void) {
    CurrentFile = st_filebegin((? *)3, 1, map_glevel[debugflag]);
}

s32 func_0040F5D8(u8 *arg0, s32 arg1) {
    s32 temp_lo;
    u32 temp_v0_2;
    u32 var_s2;
    u32 var_s4;
    u32 var_s5;
    u32 var_v0;
    u8 *var_s0;
    u8 temp_v0;
    u8 var_a0;

    var_s2 = 0;
    if (arg0->unk0 == 0x30) {
        temp_v0 = arg0->unk1;
        var_s5 = 0x10;
        if ((temp_v0 == 0x78) || (var_s4 = 1, (temp_v0 == 0x58))) {
            var_s4 = 2;
        } else {
            var_s5 = 8;
        }
    } else {
        var_s5 = 0xA;
        var_s4 = 0;
    }
    var_s0 = arg0 + var_s4;
    var_a0 = *var_s0;
    if (var_a0 != 0) {
loop_8:
        temp_v0_2 = hex_to_num(var_a0);
        var_s0 += 1;
        if (((u32) (((0x7FFFFFFFU / var_s5) * 2) + 1) < var_s2) || (temp_lo = var_s2 * var_s5, (((u32) (-1 - temp_lo) < temp_v0_2) != 0))) {
            posterror("Overflow", arg0, 1);
            goto block_20;
        }
        var_a0 = *var_s0;
        var_s2 = temp_lo + temp_v0_2;
        var_s4 += 1;
        if (var_a0 == 0) {
            goto block_13;
        }
        goto loop_8;
    }
block_13:
    if ((var_s5 == 0xA) && (var_s2 & 0x80000000) && (var_s2 != 0x80000000)) {
        posterror("Large decimal set sign bit", arg0, 2, (s32) arg0);
    }
    var_s4 = var_s2;
    if (arg1 != 0) {
        var_v0 = var_s4;
        if (var_s2 != 0x80000000) {
            var_s4 = (u32) -(s32) var_s2;
            goto block_20;
        }
    } else {
block_20:
        var_v0 = var_s4;
    }
    return (s32) var_v0;
}

s32 func_0040F77C(u8 *arg0, s32 arg1) {
    s32 sp24;
    s32 sp20;
    s32 temp_ret;
    s32 temp_ret_2;
    s32 temp_t2;
    u32 var_v1;

    errno = 0;
    if (Tokench == 0x68) {
        temp_ret = strtoull(0, 0x10);
        var_v1 = (u32) (u64) temp_ret;
        sp20 = temp_ret;
    } else {
        temp_ret_2 = strtoll(arg0, 0, 0);
        var_v1 = (u32) (u64) temp_ret_2;
        sp20 = temp_ret_2;
    }
    sp24 = (s32) var_v1;
    if (errno == 0x22) {
        posterror("Number out of range", arg0, 1);
    }
    if (arg1 != 0) {
        temp_t2 = ~sp20 + (sp24 == 0);
        sp24 = -sp24;
        sp20 = temp_t2;
    }
    return sp20;
}

s32 hash(u8 *arg0) {
    s32 sp20;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 var_a0;
    s32 var_a1;
    s32 var_a2;
    s32 var_a3;
    s32 var_t0;

    temp_v0 = strlen();
    var_a3 = temp_v0;
    if (temp_v0 <= 0) {
        sp20 = temp_v0;
        assertion_failed("i > 0", "as0util.c", (s32 *)0xE5, var_a3);
        var_a3 = sp20;
    }
    temp_v0_2 = var_a3 - 1;
    if (temp_v0_2 >= 2) {
        var_t0 = temp_v0_2;
    } else {
        var_t0 = 1;
    }
    temp_v0_3 = var_a3 - 2;
    var_a1 = 1;
    if (temp_v0_3 >= 2) {
        var_a1 = temp_v0_3;
    }
    var_a2 = var_a3;
    if (var_a3 >= 4) {
        var_a2 = 3;
    }
    var_a0 = var_a3;
    if (var_a3 >= 3) {
        var_a0 = 2;
    }
    return (s32) ((*(arg0 + var_a3) * 0x13) + (arg0->unk1 * 0xD) + (*(arg0 + var_a0) * 0x11) + (*(arg0 + var_a2) * 0xB) + (*(arg0 + var_a1) * 3) + (*(arg0 + var_t0) * 7)) % 128;
}

s32 LookUp(? *arg0, ? **arg1) {
    ? *var_s0;

    *arg1 = NULL;
    var_s0 = hashtable[hash()];
    if (var_s0 != NULL) {
loop_1:
        if (strcmp(arg0, var_s0->unk4) == 0) {
            *arg1 = var_s0;
            return 1;
        }
        var_s0 = var_s0->unk0;
        if (var_s0 == NULL) {
            /* Duplicate return node #5. Try simplifying control flow for better match */
            return 0;
        }
        goto loop_1;
    }
    return 0;
}

s32 opLookUp(? *arg0, ? **arg1) {
    ? *var_s0;

    *arg1 = NULL;
    var_s0 = ophashtable[hash()];
    if (var_s0 != NULL) {
loop_1:
        if (strcmp(arg0, var_s0->unk4) == 0) {
            *arg1 = var_s0;
            return 1;
        }
        var_s0 = var_s0->unk0;
        if (var_s0 == NULL) {
            /* Duplicate return node #5. Try simplifying control flow for better match */
            return 0;
        }
        goto loop_1;
    }
    return 0;
}

void func_0040FB2C(void) {
    u8 temp_v1;

    if (linelength >= nextinline) {
        temp_v1 = line[nextinline];
        if (((temp_v1 + &__ctype)->unk1 & 3) || (temp_v1 == 0x39)) {
            posterror("Badly delimited numeric literal", NULL, 1);
        }
    }
}

void consume(void) {
    if (Tstringlength < 0x3FF) {
        *(Tstringlength + token_tmp) = line[nextinline];
    }
    Tstringlength += 1;
    nextinline += 1;
}

s32 func_0040FC20(s32 arg0) {
    s32 sp40;
    s32 temp_v1;
    s32 var_s2;
    u8 *var_t7;
    u8 temp_s0;
    u8 temp_v0;
    s32 phi_v1;

    temp_v1 = nextinline;
    var_s2 = 1;
    sp40 = temp_v1;
    phi_v1 = temp_v1;
    if (linelength >= temp_v1) {
        var_t7 = &line[temp_v1];
loop_2:
        temp_s0 = *var_t7;
        temp_v0 = (&__ctype + temp_s0)->unk1;
        if (temp_v0 & 4) {
            consume();
            phi_v1 = nextinline;
        } else if (temp_v0 & 0x80) {
            if (arg0 == 0xA) {
                posterror("Hex digit in decimal literal", NULL, 1);
            }
            line[nextinline] = tolower(temp_s0);
            consume();
            phi_v1 = nextinline;
        } else {
            var_s2 = 0;
        }
        if (var_s2 != 0) {
            var_t7 = &line[phi_v1];
            if (linelength < phi_v1) {

            } else {
                goto loop_2;
            }
        }
    }
    return sp40 < temp_v1;
}

void func_0040FD98(void) {
    s32 sp2C;
    s32 sp24;
    s32 temp_v0;
    s32 var_a1;
    u8 *temp_v1;
    u8 temp_v0_2;
    u8 temp_v0_3;
    u8 temp_v0_4;

    Tokench = 0x68;
    token_tmp->unk1 = 0x78;
    Tstringlength = 2;
    nextinline += 1;
    temp_v0 = func_0040FC20(0x10);
    var_a1 = temp_v0;
    if ((linelength >= nextinline) && (line[nextinline] == 0x2E)) {
        sp2C = temp_v0;
        Tokench = 0x66;
        consume();
        var_a1 = sp2C | func_0040FC20(0x10);
    }
    if ((var_a1 != 0) && (linelength >= nextinline)) {
        sp2C = var_a1;
        temp_v0_2 = tolower(line[nextinline], var_a1);
        line[nextinline] = temp_v0_2;
        if ((temp_v0_2 & 0xFF) == 0x68) {
            Tokench = 0x66;
            consume();
            if (linelength < nextinline) {
                var_a1 = 0;
            } else {
                sp24 = 0xA;
                if ((nextinline < linelength) && (temp_v0_3 = tolower(line[nextinline].unk1), temp_v1 = &line[nextinline], temp_v1->unk1 = temp_v0_3, (temp_v1->unk0 == 0x30))) {
                    if ((temp_v0_3 & 0xFF) == 0x78) {
                        sp24 = 0x10;
                        consume();
                        consume();
                    }
                }
                if ((sp24 == 0xA) && ((temp_v0_4 = line[nextinline], (temp_v0_4 == 0x2B)) || (temp_v0_4 == 0x2D))) {
                    consume();
                }
                var_a1 = func_0040FC20(sp24);
            }
        }
    }
    if (var_a1 == 0) {
        posterror("Badly delimited hexadecimal literal", NULL, 1);
    } else {
        func_0040FB2C();
    }
    if ((Tokench == 0x66) && (Tstringlength >= 0x400)) {
        posterror("Hex floating point literal too long", NULL, 1);
        Tstringlength = 0x3FF;
    }
}

void func_004100C8(void) {
    u8 temp_v1;
    u8 temp_v1_2;

    Tokench = 0x64;
    if (nextinline < linelength) {
        temp_v1 = line[nextinline];
        if (((s32) temp_v1 >= 0x30) && ((s32) temp_v1 < 0x39)) {
loop_3:
            consume();
            if (nextinline < linelength) {
                temp_v1_2 = line[nextinline];
                if ((s32) temp_v1_2 >= 0x30) {
                    if ((s32) temp_v1_2 < 0x39) {
                        goto loop_3;
                    }
                }
            }
        }
    }
    func_0040FB2C();
}

void func_004101AC(void) {
    u8 temp_v1;
    u8 temp_v1_2;

    if ((nextinline < linelength) && (temp_v1 = line[nextinline], (((s32) temp_v1 < 0x30) == 0))) {
        if ((s32) temp_v1 < 0x3A) {
loop_3:
            consume();
            if (nextinline < linelength) {
                temp_v1_2 = line[nextinline];
                if (((s32) temp_v1_2 < 0x30) || ((s32) temp_v1_2 >= 0x3A)) {

                } else {
                    goto loop_3;
                }
            }
        }
    }
}

void func_00410270(u8 *arg0) {
    s32 temp_v0;

    temp_v0 = Tstringlength;
    if (temp_v0 >= 0x400) {
        Tstringlength = 0x3FF;
        posterror("Truncating token", arg0, 1);
    }
    arg0[temp_v0] = 0;
}

s32 dot_soon(s32 arg0) {
    s32 var_a0;
    u8 *var_a1;
    u8 temp_v1;

    var_a0 = arg0;
    if (var_a0 < linelength) {
        var_a1 = &line[var_a0];
loop_2:
        temp_v1 = *var_a1;
        var_a0 += 1;
        if ((temp_v1 == 0x2E) || (temp_v1 == 0x65) || (temp_v1 == 0x45)) {
            return 1;
        }
        if (!((&__ctype + temp_v1)->unk1 & 4)) {
            return 0;
        }
        var_a1 += 1;
        if (var_a0 >= linelength) {
            /* Duplicate return node #9. Try simplifying control flow for better match */
            return 0;
        }
        goto loop_2;
    }
    return 0;
}

void nexttoken(s32 arg3) {
    u8 sp5F;
    s32 sp4C;
    s32 sp3C;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_t2;
    s32 temp_t4;
    s32 temp_t9;
    s32 temp_t9_2;
    s32 temp_t9_3;
    s32 var_a0;
    s32 var_a0_2;
    s32 var_a3;
    s32 var_at;
    s32 var_at_2;
    s32 var_at_3;
    s32 var_at_4;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s1;
    s32 var_t5;
    s32 var_t8;
    u8 *temp_v1;
    u8 *var_t4;
    u8 temp_a1;
    u8 temp_a1_2;
    u8 temp_a1_3;
    u8 temp_v0;
    u8 temp_v0_2;
    u8 temp_v0_3;
    u8 temp_v0_4;
    u8 var_a1;
    u8 var_a1_2;
    u8 var_v1;

    var_a3 = arg3;
    sp4C = 0;
    if (save.unk0 != 0) {
        Tokench = save.unk0;
        save.unk0 = 0U;
        strcpy((u8 *) Tstring, &save + 1);
        Tstringlength = save.unk404;
    } else {
        var_a0 = nextinline;
        temp_a2 = linelength;
        Tstringlength = 0;
        if ((var_a0 < temp_a2) && (line[var_a0] == 0x20)) {
loop_4:
            temp_t9 = var_a0 + 1;
            nextinline = temp_t9;
            var_a0 = temp_t9;
            if (temp_t9 < temp_a2) {
                if (line[var_a0].unk1 == 0x20) {
                    goto loop_4;
                }
            }
        }
        if (var_a0 >= temp_a2) {
            Tokench = 0x23;
        } else {
            temp_a1 = line[var_a0];
            Tstringlength = 1;
            *token_tmp = temp_a1;
            nextinline = var_a0 + 1;
            if ((s32) temp_a1 >= 0x5F) {
                switch (temp_a1);                   /* switch 3; irregular */
            } else {
                if ((s32) temp_a1 >= 0x3F) {
                    if (temp_a1 != 0x5E) {
                        goto block_25;
                    }
                    goto block_19;
                }
                var_at = (s32) temp_a1 < 0x31;
                switch (temp_a1) {                  /* switch 1 */
                case 0x25:                          /* switch 1 */
                case 0x26:                          /* switch 1 */
                case 0x28:                          /* switch 1 */
                case 0x29:                          /* switch 1 */
                case 0x2A:                          /* switch 1 */
                case 0x2B:                          /* switch 1 */
                case 0x2C:                          /* switch 1 */
                case 0x2D:                          /* switch 1 */
                case 0x2F:                          /* switch 1 */
                case 0x3A:                          /* switch 1 */
                case 0x3B:                          /* switch 1 */
                case 0x3C:                          /* switch 1 */
                case 0x3D:                          /* switch 1 */
                case 0x3E:                          /* switch 1 */
                case 0x7C:                          /* switch 3 */
                case 0x7E:                          /* switch 3 */
block_19:
                    if (((temp_a1 == 0x3C) && (line[nextinline] == 0x3C)) || ((temp_a1 == 0x3E) && (line[nextinline] == 0x3E))) {
                        nextinline += 1;
                    }
                    Tokench = temp_a1;
                    break;
                case 0x23:                          /* switch 1 */
                case 0x24:                          /* switch 1 */
                case 0x27:                          /* switch 1 */
                case 0x2E:                          /* switch 1 */
                case 0x30:                          /* switch 1 */
                case 0x31:                          /* switch 1 */
                case 0x32:                          /* switch 1 */
                case 0x33:                          /* switch 1 */
                case 0x34:                          /* switch 1 */
                case 0x35:                          /* switch 1 */
                case 0x36:                          /* switch 1 */
                case 0x37:                          /* switch 1 */
                case 0x38:                          /* switch 1 */
                case 0x39:                          /* switch 1 */
block_25:
                    var_at = (s32) temp_a1 < 0x31;
                    /* fallthrough */
                default:                            /* switch 1 */
                    if ((var_at != 0) || ((s32) temp_a1 >= 0x3A)) {
                        if ((nextinline < temp_a2) && (((temp_a1 == 0x2E) && ((line[nextinline] + &__ctype)->unk1 & 4)) || ((temp_a1 == 0x30) && (sp3C = (s32) temp_a1, sp5F = temp_a1, (dot_soon(nextinline, temp_a1, temp_a2) != 0))))) {
                            goto block_34;
                        }
                        if (temp_a1 == 0x30) {
                            sp4C = 1;
                            if ((nextinline < linelength) && ((temp_v0 = line[nextinline], (temp_v0 == 0x78)) || (temp_v0 == 0x58))) {
                                func_0040FD98(nextinline, temp_a1);
                            } else {
                                func_004100C8(nextinline, temp_a1);
                            }
                        } else if (((&__ctype + temp_a1)->unk1 & 3) || (temp_a1 == 0x2E) || (temp_a1 == 0x5F) || (temp_a1 == 0x24)) {
                            Tokench = 0x69;
                            temp_a0 = nextinline;
                            if (temp_a0 < linelength) {
                                var_t4 = &line[temp_a0];
loop_75:
                                temp_a1_2 = *var_t4;
                                if (((&__ctype + temp_a1_2)->unk1 & 7) || (temp_a1_2 == 0x2E) || (temp_a1_2 == 0x5F) || (temp_a1_2 == 0x24)) {
                                    consume(temp_a0, temp_a1_2);
                                    var_t4 = &line[nextinline];
                                    if (nextinline >= linelength) {

                                    } else {
                                        goto loop_75;
                                    }
                                }
                            }
                        }
                    } else {
block_34:
                        if (temp_a1 == 0x2E) {
                            Tokench = 0x66;
                            consume();
                            func_004101AC();
                            goto block_48;
                        }
                        Tokench = 0x64;
                        func_004101AC();
                        if (linelength < nextinline) {

                        } else {
                            temp_v0_2 = line[nextinline];
                            if ((temp_v0_2 == 0x62) || (temp_v0_2 == 0x66)) {
                                consume(nextinline);
                                Tokench = 0x69;
                                func_00410270((u8 *) token_tmp);
                                make_local_label(token_tmp, &Tstringlength);
                                func_0040FB2C();
                            } else if ((temp_v0_2 != 0x2E) && (temp_v0_2 != 0x65) && (temp_v0_2 != 0x45)) {
                                func_0040FB2C(nextinline);
                            } else {
                                Tokench = 0x66;
                                var_at_2 = nextinline < linelength;
                                if (temp_v0_2 == 0x2E) {
                                    consume(nextinline);
                                    func_004101AC();
block_48:
                                    var_at_2 = nextinline < linelength;
                                }
                                temp_v1 = &line[nextinline];
                                if ((var_at_2 != 0) && ((temp_v0_3 = *temp_v1, (temp_v0_3 == 0x65)) || (temp_v0_3 == 0x45))) {
                                    *temp_v1 = 0x65;
                                    consume(nextinline);
                                    temp_a0_2 = nextinline;
                                    temp_a2_2 = linelength;
                                    if (temp_a0_2 < temp_a2_2) {
                                        temp_v0_4 = line[temp_a0_2];
                                        if ((temp_v0_4 == 0x2B) || (var_at_3 = temp_a0_2 < temp_a2_2, (temp_v0_4 == 0x2D))) {
                                            consume(temp_a0_2);
                                            goto block_56;
                                        }
                                    } else {
block_56:
                                        var_at_3 = temp_a0_2 < temp_a2_2;
                                    }
                                    if ((var_at_3 == 0) || !((line[temp_a0_2] + &__ctype)->unk1 & 4)) {
                                        posterror("Missing exponent in floating-point literal", NULL, 1);
                                        Tstringlength -= 1;
                                    } else {
                                        func_004101AC(temp_a0_2);
                                        goto block_61;
                                    }
                                } else {
block_61:
                                    func_0040FB2C();
                                }
                            }
                        }
                    }
                    break;
                case 0x22:                          /* switch 1 */
                    Tokench = 0x22;
                    var_a0_2 = nextinline;
                    Tstringlength = 0;
                    if (var_a0_2 < temp_a2) {
                        var_a3 = 0x22;
loop_86:
                        var_a1 = line[var_a0_2];
                        if (var_a1 == (u8) 0x22) {
                            nextinline = var_a0_2 + 1;
                            if (Tstringlength == 0) {
                                posterror("zero length string", NULL, 2, 0x22);
                            }
                        } else {
                            temp_t4 = var_a0_2 + 1;
                            if (var_a1 == 0x5C) {
                                nextinline = temp_t4;
                                var_a0_2 = temp_t4;
                                if (temp_t4 >= temp_a2) {
                                    posterror("literal string not terminated", NULL, 1, 0x22);
                                } else {
                                    var_a1 = line[var_a0_2].unk1;
                                    var_v1 = var_a1;
                                    if ((s32) var_a1 >= 0x28) {
                                        var_at_4 = (s32) var_v1 < 0x30;
                                        switch (var_v1) { /* switch 2 */
                                        case 0x61:  /* switch 2 */
                                            var_a1 = 7;
                                            goto block_128;
                                        case 0x62:  /* switch 2 */
                                            var_a1 = 8;
                                            goto block_128;
                                        case 0x66:  /* switch 2 */
                                            var_a1 = 0xC;
                                            goto block_128;
                                        case 0x6E:  /* switch 2 */
                                            var_a1 = 0xA;
                                            goto block_128;
                                        case 0x72:  /* switch 2 */
                                            var_a1 = 0xD;
                                            goto block_128;
                                        case 0x74:  /* switch 2 */
                                            var_a1 = 9;
                                            goto block_128;
                                        case 0x76:  /* switch 2 */
                                            var_a1 = 0xB;
                                            goto block_128;
                                        }
                                    } else if ((var_v1 != (u8) 0x22) && (var_v1 != 0x27)) {
                                    case 0x5D:      /* switch 2 */
                                    case 0x5E:      /* switch 2 */
                                    case 0x5F:      /* switch 2 */
                                    case 0x60:      /* switch 2 */
                                    case 0x63:      /* switch 2 */
                                    case 0x64:      /* switch 2 */
                                    case 0x65:      /* switch 2 */
                                    case 0x67:      /* switch 2 */
                                    case 0x68:      /* switch 2 */
                                    case 0x69:      /* switch 2 */
                                    case 0x6A:      /* switch 2 */
                                    case 0x6B:      /* switch 2 */
                                    case 0x6C:      /* switch 2 */
                                    case 0x6D:      /* switch 2 */
                                    case 0x6F:      /* switch 2 */
                                    case 0x70:      /* switch 2 */
                                    case 0x71:      /* switch 2 */
                                    case 0x73:      /* switch 2 */
                                    case 0x75:      /* switch 2 */
                                        var_at_4 = (s32) var_v1 < 0x30;
                                    default:        /* switch 2 */
                                        if (((var_at_4 == 0) && ((s32) var_v1 < 0x38)) || (var_v1 == 0x78) || (var_v1 == 0x58)) {
                                            sp4C = 1;
                                            var_s1 = 0;
                                            if (((s32) var_v1 >= 0x30) && (var_s0 = 3, (((s32) var_v1 < 0x38) != 0))) {
                                                var_t8 = 0 * 8;
loop_113:
                                                temp_t9_2 = var_a0_2 + 1;
                                                var_s1 = (var_t8 + var_v1) - 0x30;
                                                nextinline = temp_t9_2;
                                                var_a0_2 = temp_t9_2;
                                                if (temp_t9_2 >= temp_a2) {
                                                    posterror("literal string not terminated", NULL, 1, 0x22);
                                                } else {
                                                    temp_a1_3 = line[var_a0_2].unk1;
                                                    var_s0 -= 1;
                                                    var_v1 = temp_a1_3;
                                                    if ((s32) temp_a1_3 >= 0x30) {
                                                        var_t5 = var_a0_2 - 1;
                                                        if ((s32) temp_a1_3 < 0x38) {
                                                            var_t8 = var_s1 * 8;
                                                            if (var_s0 == 0) {
                                                                goto block_124;
                                                            }
                                                            goto loop_113;
                                                        }
                                                        goto block_125;
                                                    }
                                                    goto block_124;
                                                }
                                            } else {
                                                temp_t2 = var_a0_2 + 1;
                                                var_a1_2 = line[var_a0_2].unk1;
                                                nextinline = temp_t2;
                                                var_a0_2 = temp_t2;
                                                var_s0_2 = 2;
                                                if ((&__ctype + var_a1_2)->unk1 & 0x80) {
loop_120:
                                                    var_a0_2 = nextinline + 1;
                                                    var_s1 = hex_to_num(var_a1_2 & 0xFF, var_a1_2, temp_a2) + (var_s1 * 0x10);
                                                    nextinline = var_a0_2;
                                                    if (var_a0_2 >= linelength) {
                                                        posterror("literal string not terminated", NULL, 1);
                                                    } else {
                                                        var_a1_2 = line[nextinline].unk1;
                                                        var_s0_2 -= 1;
                                                        var_t5 = var_a0_2 - 1;
                                                        if ((&__ctype + var_a1_2)->unk1 & 0x80) {
                                                            if (var_s0_2 == 0) {
                                                                goto block_124;
                                                            }
                                                            goto loop_120;
                                                        }
                                                        goto block_125;
                                                    }
                                                } else {
block_124:
                                                    var_t5 = var_a0_2 - 1;
block_125:
                                                    var_a3 = 0x22;
                                                    nextinline = var_t5;
                                                    if (var_s1 < 0x100) {
                                                        var_a1 = var_s1 & 0xFF;
                                                        var_a0_2 = var_t5;
                                                        goto block_128;
                                                    }
                                                    posterror(" number in string too big", NULL, 1, 0x22);
                                                }
                                            }
                                        } else {
                                            goto block_128;
                                        }
                                    } else {
                                        goto block_128;
                                    }
                                }
                            } else {
                            case 0x5C:              /* switch 2 */
block_128:
                                temp_t9_3 = var_a0_2 + 1;
                                if (Tstringlength < 0x3FF) {
                                    *(Tstringlength + token_tmp) = var_a1;
                                }
                                Tstringlength += 1;
                                nextinline = temp_t9_3;
                                var_a0_2 = temp_t9_3;
                                if (temp_t9_3 >= temp_a2) {
                                    goto block_131;
                                }
                                goto loop_86;
                            }
                        }
                    } else {
block_131:
                        if (Tstringlength >= 0x400) {
                            posterror("literal string too long", NULL, 1, var_a3);
                            Tstringlength = 0x3FF;
                        } else if (var_a0_2 >= temp_a2) {
                            posterror("Missing \" at end of string", NULL, 1, var_a3);
                        }
                    }
                    break;
                }
            }
        }
        if ((Tokench == 0x69) || (Tokench == 0x68) || (Tokench == 0x64) || (Tokench == 0x66) || (Tokench == 0x22)) {
            func_00410270((u8 *) token_tmp);
            if (sp4C != 0) {
                memcpy(Tstring, token_tmp, Tstringlength + 1);
            } else {
                strcpy((u8 *) Tstring, token_tmp);
            }
        }
    }
}

s8 func_00410E80(void) {
    s8 sp443;
    u8 sp44;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s32 var_at;
    s32 var_at_2;
    s32 var_s0_2;
    s32 var_s1;
    s32 var_s6;
    s32 var_v1;
    u8 temp_a0;
    u8 var_a0;
    u8 var_a0_2;
    u8 var_s0;
    u8 var_v1_2;
    u8 var_v1_3;

    temp_v0 = fgetc(in_file);
    var_a0 = temp_v0 & 0xFF;
    var_v1_2 = var_a0;
    var_s0 = temp_v0 & 0xFF;
    if ((var_a0 == 0x20) || (var_a0 == 9)) {
        do {
loop_2:
            temp_v0_2 = fgetc(in_file);
            var_a0 = temp_v0_2 & 0xFF;
            var_v1_2 = var_a0;
            var_s0 = temp_v0_2 & 0xFF;
            if (var_a0 == 0x20) {
                goto loop_2;
            }
        } while (var_s0 == 9);
    }
    if (var_v1_2 == 0x6C) {
        if (((fgetc(in_file) & 0xFF) != 0x69) || ((fgetc(in_file) & 0xFF) != 0x6E) || ((fgetc(in_file) & 0xFF) != 0x65)) {
            posterror("Expected cpp-generated line number", NULL, 1);
            exit(1);
        }
        temp_v0_3 = fgetc(in_file);
        var_a0 = temp_v0_3 & 0xFF;
        var_s0 = temp_v0_3 & 0xFF;
        if ((var_a0 == 0x20) || (var_a0 == 9)) {
            do {
loop_12:
                temp_v0_4 = fgetc(in_file);
                var_a0 = temp_v0_4 & 0xFF;
                var_s0 = temp_v0_4 & 0xFF;
                if (var_a0 == 0x20) {
                    goto loop_12;
                }
            } while (var_s0 == 9);
        }
    }
    var_s6 = 0;
    if (!((&__ctype + var_a0)->unk1 & 4)) {
        posterror("Expected cpp-generated line number", NULL, 1);
        exit(1);
        var_s6 = 0;
    }
    do {
        var_s6 = ((var_s6 * 0xA) + var_s0) - 0x30;
        temp_v0_5 = fgetc(in_file);
        temp_a0 = temp_v0_5 & 0xFF;
        var_s0 = temp_v0_5 & 0xFF;
    } while ((&__ctype + temp_a0)->unk1 & 4);
    if ((var_s0 == 0x20) || (var_v1_3 = temp_a0, (temp_a0 == 9))) {
        do {
loop_20:
            temp_v0_6 = fgetc(in_file);
            var_v1_3 = temp_v0_6 & 0xFF;
            var_s0 = temp_v0_6 & 0xFF;
            if (var_v1_3 == 0x20) {
                goto loop_20;
            }
        } while (var_s0 == 9);
    }
    if (var_v1_3 != 0x22) {
        posterror("Expected cpp-generated file name", NULL, 1);
        return var_s0;
    }
    temp_v0_7 = fgetc(in_file, NULL);
    var_a0_2 = temp_v0_7 & 0xFF;
    var_s0_2 = temp_v0_7 & 0xFF;
    var_s1 = 0;
    if (var_a0_2 != 0x22) {
        var_at = 0 < 0x400;
        switch (var_a0_2) {                         /* irregular */
        case 0x20:
            break;
        default:
            var_at_2 = 0 < 0x3FF;
loop_29:
            if (var_at_2 != 0) {
                (&sp44)[var_s1] = var_a0_2;
            }
            var_s1 += 1;
            temp_v0_8 = fgetc(in_file);
            var_a0_2 = temp_v0_8 & 0xFF;
            var_s0_2 = temp_v0_8 & 0xFF;
            if ((var_a0_2 != 0x22) && (var_a0_2 != 0x20) && (var_a0_2 != 0xA)) {
                var_at_2 = var_s1 < 0x3FF;
                if (var_s0_2 != 0xFF) {
                    goto loop_29;
                }
            }
            goto block_35;
        }
    } else {
    case 0xA:
    case 0xFF:
block_35:
        var_at = var_s1 < 0x400;
    }
    if (var_at == 0) {
        sp443 = 0;
        posterror("Truncating cpp-generated filename", &sp44, 2);
    } else {
        (&sp44)[var_s1] = 0;
    }
    CurrentLine = var_s6 - 2;
    if (invent_locs != 0) {
        make_file(&sp44);
    }
    var_v1 = var_s0_2;
    if (var_s0_2 == 0x22) {
        var_v1 = fgetc(in_file);
    }
    return var_v1 & 0xFF;
}

void readinline(u8 arg3) {
    u8 sp46F;
    u8 sp46E;
    u8 *sp468;
    ? *sp40;
    s32 sp3C;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 var_s0;
    s32 var_t0;
    u8 *var_a1;
    u8 temp_v1;
    u8 var_a2;
    u8 var_a3;
    u8 var_v1;

    var_a3 = arg3;
    var_s0 = 0;
    var_a2 = 0x20;
    var_t0 = 1;
    var_a1 = NULL;
    printedline = 0;
    do {
        sp468 = var_a1;
        sp46E = var_a2;
        sp3C = var_t0;
        temp_v0 = fgetc(in_file, var_a1, var_a2, var_a3);
        temp_v1 = temp_v0 & 0xFF;
        var_a3 = temp_v0 & 0xFF;
        if ((temp_v1 == 9) || (temp_v1 == 0xC)) {
            var_a3 = 0x20;
        } else if ((temp_v1 == 0x22) && (var_a2 != 0x5C)) {
            var_t0 = var_t0 == 0;
        } else {
            if ((temp_v1 == 0xA) || (temp_v1 == 0xFF)) {
                goto block_14;
            }
            if ((var_t0 != 0) && ((temp_v1 == 0x3B) || (temp_v1 == 0x23))) {
block_14:
                var_a1 = (u8 *)1;
            }
        }
        var_a2 = var_a3 & 0xFF;
        if (var_a1 == NULL) {
            if (var_s0 < 0x41F) {
                *(var_s0 + &sp40) = var_a3;
            }
            var_s0 += 1;
        }
    } while (var_a1 == NULL);
    var_v1 = var_a3;
    if (var_a3 == 0x23) {
        if (var_s0 == 0) {
            var_a3 = func_00410E80() & 0xFF;
            var_v1 = var_a3;
        }
    }
    if ((var_v1 == 0x3B) || (var_v1 == 0xFF)) {
        if (B_1000A810 == 0) {
            CurrentLine += 1;
        }
        B_1000A810 = 1;
    } else {
        if ((var_v1 != 0xA) && (var_v1 != 0xFF)) {
loop_31:
            temp_v0_2 = fgetc(in_file);
            var_a3 = temp_v0_2 & 0xFF;
            if ((temp_v0_2 & 0xFF) != 0xA) {
                if (var_a3 != 0xFF) {
                    goto loop_31;
                }
            }
        }
        if ((invent_locs != 0) && (B_1000A810 == 0)) {
            CurrentLine += 1;
        }
        B_1000A810 = 0;
    }
    if (var_s0 >= 0x420) {
        var_s0 = 0x41F;
        sp46F = var_a3;
        posterror("Line too long", NULL, 2, (s32) var_a3);
    }
    *(var_s0 + &sp40) = 0;
    sp46F = var_a3;
    strcpy(line, &sp40);
    linelength = var_s0;
    if ((var_s0 == 0) && (sp46F != 0xFF)) {
        readinline();
    }
    nextinline = 0;
}

? *alloc_new_sym(void) {
    ? *sp24;
    ? *temp_v0;

    temp_v0 = malloc(0x1C);
    sp24 = temp_v0;
    if (temp_v0 == NULL) {
        new_error();
    } else {
        memset(sp24, 0, 0x1C);
    }
    return sp24;
}

? *alloc_new_string(? *arg0) {
    ? *sp20;
    ? *temp_v0;

    temp_v0 = malloc(strlen() + 1);
    sp20 = temp_v0;
    if (temp_v0 == NULL) {
        new_error();
    }
    strcpy((u8 *) sp20, arg0);
    return sp20;
}

void EnterSym(u8 *arg0, ? **arg1, s32 arg2) {
    ? *sp2C;
    s32 sp28;
    ? **sp24;
    ? **temp_v1;
    ? *temp_v0;

    if (LookUp(&sp2C) == 0) {
        sp28 = hash(arg0);
        temp_v0 = alloc_new_sym();
        temp_v1 = &hashtable[sp28];
        sp2C = temp_v0;
        *temp_v0 = *temp_v1;
        sp24 = temp_v1;
        sp2C->unk4 = alloc_new_string(arg0);
        sp2C->unk10 = 3;
        sp2C->unk8 = 0;
        sp2C->unk14 = 0;
        sp2C->unk18 = sym_enter(arg0, arg2);
        *sp24 = sp2C;
    }
    if (sp2C->unk10 != 3) {
        posterror("Address symbol expected", (u8 *) Tstring, 1);
    }
    *arg1 = sp2C;
}

? *GetRegister(void) {
    ? *sp24;
    ? *sp20;

    sp20 = NULL;
    if (Tokench != 0x69) {
        posterror("register expected", NULL, 1);
    } else if (LookUp(Tstring, &sp24) == 0) {
        posterror("Undefined symbol", (u8 *) Tstring, 1);
    } else if (sp24->unk10 != 0) {
        posterror("Register expected", (u8 *) Tstring, 1);
    } else {
        sp20 = sp24;
    }
    nexttoken();
    if (Tokench == 0x2C) {
        nexttoken();
    }
    return sp20;
}

s32 func_00411898(void) {
    s32 sp3C;
    s32 sp38;
    s32 sp34;
    ? *sp30;
    s32 sp2C;
    s32 temp_a1;
    s32 var_v1;
    u8 temp_v1;

    temp_v1 = Tokench;
    sp34 = 0;
    sp3C = 0;
    sp38 = 0;
    if (temp_v1 == 0x2D) {
        sp3C = 1;
        nexttoken();
    } else if (temp_v1 == 0x2B) {
        nexttoken();
    } else if (temp_v1 == 0x7E) {
        sp38 = 1;
        nexttoken();
    }
    if (temp_v1 != 0x22) {
        switch (temp_v1) {                          /* irregular */
        case 0x28:
            nexttoken();
            sp34 = func_0041244C();
            if (Tokench != 0x29) {
                posterror("Right paren expected", NULL, 1);
            }
            break;
        case 0x69:
            if (LookUp(Tstring, &sp30) == 0) {
                posterror("undefined symbol in expression", NULL, 1, (s32) Tstring);
            } else if (sp30->unk10 != 4) {
                posterror("Symbol must have absolute value", (u8 *) Tstring, 1, (s32) Tstring);
            } else {
                sp34 = sp30->unk8;
            }
            break;
        case 0x64:
        case 0x68:
            temp_a1 = sp3C;
            sp3C = 0;
            sp34 = func_0040F5D8((u8 *) Tstring, temp_a1);
            break;
        default:
            posterror("Invalid symbol in expression", NULL, 1);
            nexttoken();
            break;
        }
    } else {
        sp3C = 0;
        sp34 = (s32) *Tstring;
        if (Tstringlength >= 2) {
            posterror("String within expression may have only one character", (u8 *) Tstring, 1, (s32) Tstring);
        }
    }
    if (sp3C != 0) {
        var_v1 = -sp34;
    } else {
        var_v1 = sp34;
        if (sp38 != 0) {
            var_v1 = ~sp34;
        }
    }
    sp2C = var_v1;
    nexttoken();
    return sp2C;
}

s32 func_00411B84(void) {
    s32 sp44;
    s32 sp40;
    s32 sp3C;                                       /* compiler-managed */
    s32 sp38;
    ? *sp34;
    s32 sp2C;
    s32 sp28;
    s32 temp_a1;
    s32 temp_ret;
    s32 temp_ret_2;
    s32 temp_t4;
    u8 temp_v1;

    temp_v1 = Tokench;
    sp3C = 0;
    sp38 = 0;
    sp44 = 0;
    sp40 = 0;
    if (temp_v1 == 0x2D) {
        sp44 = 1;
        nexttoken();
    } else if (temp_v1 == 0x2B) {
        nexttoken();
    } else if (temp_v1 == 0x7E) {
        sp40 = 1;
        nexttoken();
    }
    switch (temp_v1) {                              /* irregular */
    case 0x28:
        nexttoken();
        temp_ret = func_00412548();
        sp38 = temp_ret;
        sp3C = (u32) (u64) temp_ret;
        if (Tokench != 0x29) {
            posterror("Right paren expected", NULL, 1);
        }
        break;
    case 0x69:
        if (LookUp(Tstring, &sp34) == 0) {
            posterror("undefined symbol in expression", NULL, 1, (s32) Tstring);
        } else if (sp34->unk10 != 4) {
            posterror("Symbol must have absolute value", (u8 *) Tstring, 1, (s32) Tstring);
        } else {
            temp_t4 = sp34->unk8;
            sp38 = temp_t4 >> 0x1F;
            sp3C = temp_t4;
        }
        break;
    case 0x64:
    case 0x68:
        temp_a1 = sp44;
        sp44 = 0;
        temp_ret_2 = func_0040F77C((u8 *) Tstring, temp_a1);
        sp38 = temp_ret_2;
        sp3C = (u32) (u64) temp_ret_2;
        break;
    case 0x22:
        sp38 = 0;
        sp44 = 0;
        sp3C = (s32) *Tstring;
        if (Tstringlength >= 2) {
            posterror("String within expression may have only one character", (u8 *) Tstring, 1, (s32) Tstring);
        }
        break;
    default:
        posterror("Invalid symbol in expression", NULL, 1);
        nexttoken();
        break;
    }
    if (sp44 != 0) {
        sp2C = -sp3C;
        sp28 = ~sp38 + (sp3C == 0);
    } else if (sp40 != 0) {
        sp2C = ~sp3C;
        sp28 = ~sp38;
    } else {
        sp28 = sp38;
        sp2C = sp3C;
    }
    nexttoken();
    return sp28;
}

u32 func_00411ECC(void) {
    s32 temp_s1;
    s32 temp_v0;
    s32 var_s2;
    u8 temp_a0;

    var_s2 = func_00411898();
    temp_a0 = Tokench;
    if ((temp_a0 == 0x2A) || (temp_a0 == 0x2F) || (temp_a0 == 0x25) || (temp_a0 == 0x3C) || (temp_a0 == 0x3E) || (temp_a0 == 0x5E) || (temp_a0 == 0x26) || (temp_a0 == 0x7C)) {
        do {
loop_8:
            temp_s1 = temp_a0 & 0xFF;
            nexttoken((s32 *) temp_a0);
            temp_v0 = func_00411898();
            switch (temp_s1) {                      /* irregular */
            case 0x2A:
                var_s2 *= temp_v0;
                break;
            case 0x2F:
                var_s2 = var_s2 / temp_v0;
                break;
            case 0x25:
                var_s2 = var_s2 % temp_v0;
                break;
            case 0x3C:
                var_s2 <<= temp_v0;
                break;
            case 0x3E:
                var_s2 = (s32) ((u32) var_s2 >> temp_v0);
                break;
            case 0x5E:
                var_s2 ^= temp_v0;
                break;
            case 0x26:
                var_s2 &= temp_v0;
                break;
            case 0x7C:
                var_s2 |= temp_v0;
                break;
            }
            if (Tokench == 0x2A) {
                goto loop_8;
            }
            if (Tokench == 0x2F) {
                goto loop_8;
            }
            if (Tokench == 0x25) {
                goto loop_8;
            }
            if (Tokench == 0x3C) {
                goto loop_8;
            }
            if (Tokench == 0x3E) {
                goto loop_8;
            }
            if (Tokench == 0x5E) {
                goto loop_8;
            }
            if (Tokench == 0x26) {
                goto loop_8;
            }
        } while (Tokench == 0x7C);
    }
    return (u32) var_s2;
}

void func_0041213C(void) {

}

s32 func_00412144(void) {
    u32 sp3C;
    s32 sp38;
    u32 sp34;
    s32 sp30;
    u32 sp2C;
    s32 sp28;
    s32 temp_ret;
    s32 temp_ret_2;
    s32 temp_ret_3;
    s32 temp_ret_4;
    s32 temp_ret_5;
    s32 temp_ret_6;
    s32 temp_ret_7;
    s32 temp_s0;
    s32 temp_v0;
    u32 temp_v1;

    temp_ret = func_00411B84();
    sp38 = temp_ret;
    sp3C = (u32) (u64) temp_ret;
    func_0041213C();
    if ((Tokench == 0x2A) || (Tokench == 0x2F) || (Tokench == 0x25) || (Tokench == 0x3C) || (Tokench == 0x3E) || (Tokench == 0x5E) || (Tokench == 0x26) || (Tokench == 0x7C)) {
loop_8:
        do {
loop_9:
            temp_s0 = Tokench & 0xFF;
            sp30 = sp38;
            sp34 = sp3C;
            nexttoken((s32 *) Tokench, (u8 *) Tokench);
            temp_ret_2 = func_00411B84();
            temp_v0 = temp_ret_2;
            temp_v1 = (u32) (u64) temp_ret_2;
            sp28 = temp_v0;
            sp2C = temp_v1;
            switch (temp_s0) {                      /* irregular */
            case 0x2A:
                temp_ret_3 = __ll_mul(sp38, sp3C, sp28, sp2C);
                sp38 = temp_ret_3;
                sp3C = (u32) (u64) temp_ret_3;
                break;
            case 0x2F:
                temp_ret_4 = __ll_div(sp38, sp3C, sp28, sp2C);
                sp38 = temp_ret_4;
                sp3C = (u32) (u64) temp_ret_4;
                break;
            case 0x25:
                temp_ret_5 = __ll_rem(sp38, sp3C, sp28, sp2C);
                sp38 = temp_ret_5;
                sp3C = (u32) (u64) temp_ret_5;
                break;
            case 0x3C:
                temp_ret_6 = __ll_lshift(sp38, sp3C, sp28, sp2C);
                sp38 = temp_ret_6;
                sp3C = (u32) (u64) temp_ret_6;
                break;
            case 0x3E:
                temp_ret_7 = __ull_rshift(sp38, sp3C, sp28, sp2C);
                sp38 = temp_ret_7;
                sp3C = (u32) (u64) temp_ret_7;
                break;
            case 0x5E:
                sp3C = sp34 ^ temp_v1;
                sp38 = sp30 ^ temp_v0;
                break;
            case 0x26:
                sp3C = sp34 & temp_v1;
                sp38 = sp30 & temp_v0;
                break;
            case 0x7C:
                sp3C = sp34 | temp_v1;
                sp38 = sp30 | temp_v0;
                break;
            }
            if (Tokench == 0x2A) {
                goto loop_8;
            }
            if (Tokench == 0x2F) {
                goto loop_9;
            }
            if (Tokench == 0x25) {
                goto loop_9;
            }
            if (Tokench == 0x3C) {
                goto loop_9;
            }
            if (Tokench == 0x3E) {
                goto loop_9;
            }
            if (Tokench == 0x5E) {
                goto loop_9;
            }
            if (Tokench == 0x26) {
                goto loop_9;
            }
        } while (Tokench == 0x7C);
    }
    return sp38;
}

s32 func_0041244C(void) {
    s32 temp_s1;
    u32 temp_v0;
    u32 var_s2;
    u8 temp_a0;

    var_s2 = func_00411ECC();
    temp_a0 = Tokench;
    if ((temp_a0 == 0x2B) || (temp_a0 == 0x2D)) {
        do {
loop_2:
            temp_s1 = temp_a0 & 0xFF;
            nexttoken((s32 *) temp_a0);
            temp_v0 = func_00411ECC();
            switch (temp_s1) {                      /* irregular */
            case 43:
                var_s2 += temp_v0;
                break;
            case 45:
                var_s2 -= temp_v0;
                break;
            }
            if (Tokench == 0x2B) {
                goto loop_2;
            }
        } while (Tokench == 0x2D);
    }
    return (s32) var_s2;
}

s32 func_00412548(void) {
    u32 sp3C;
    s32 sp38;
    u32 sp34;
    s32 sp30;
    s32 temp_ret;
    s32 temp_ret_2;
    s32 temp_s0;
    s32 temp_v0;
    u32 temp_t1;
    u32 temp_v1;

    temp_ret = func_00412144();
    sp38 = temp_ret;
    sp3C = (u32) (u64) temp_ret;
    func_0041213C();
    if ((Tokench == 0x2B) || (Tokench == 0x2D)) {
loop_2:
        do {
            temp_s0 = Tokench & 0xFF;
            sp30 = sp38;
            sp34 = sp3C;
            nexttoken((s32 *) Tokench, (u8 *) Tokench);
            temp_ret_2 = func_00412144();
            temp_v0 = temp_ret_2;
            temp_v1 = (u32) (u64) temp_ret_2;
            switch (temp_s0) {                      /* irregular */
            case 43:
                temp_t1 = sp34 + temp_v1;
                sp38 = (temp_t1 < temp_v1) + sp30 + temp_v0;
                sp3C = temp_t1;
                break;
            case 45:
                sp3C = sp34 - temp_v1;
                sp38 = (sp30 - temp_v0) - (sp34 < temp_v1);
                break;
            }
            if (Tokench == 0x2B) {
                goto loop_2;
            }
        } while (Tokench == 0x2D);
    }
    return sp38;
}

s32 GetExpr(u8 *arg1) {
    s32 sp24;
    u8 *var_a1;

    var_a1 = arg1;
    sp24 = 0;
    if ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D) || (Tokench == 0x7E) || (Tokench == 0x28) || (var_a1 = NULL, (Tokench == 0x22))) {
        sp24 = func_0041244C(var_a1);
        if (Tokench == 0x2C) {
            nexttoken();
        }
    } else {
        posterror("Invalid symbol in expression", NULL, 1);
        nexttoken();
    }
    return sp24;
}

s32 dw_GetExpr(s32 *arg0, u8 *arg1) {
    u32 sp24;
    s32 sp20;
    s32 temp_ret;
    s32 var_v0;
    u32 temp_a0;
    u8 *var_a1;

    var_a1 = arg1;
    if ((Tokench == 0x69) || (Tokench == 0x64) || (Tokench == 0x68) || (Tokench == 0x2B) || (Tokench == 0x2D) || (Tokench == 0x7E) || (Tokench == 0x28) || (var_a1 = NULL, (Tokench == 0x22))) {
        temp_ret = func_00412548(var_a1);
        sp20 = temp_ret;
        sp24 = (u32) (u64) temp_ret;
        func_0041213C();
        if (Tokench == 0x2C) {
            nexttoken();
        }
    } else {
        posterror("Invalid symbol in expression", NULL, 1);
        nexttoken();
    }
    *arg0 = (u32) (u64) __ull_rshift(sp20, sp24, 0, 0x20U);
    *arg1 = sp24;
    temp_a0 = *arg0;
    var_v0 = temp_a0 != 0;
    if (var_v0 != 0) {
        var_v0 = (temp_a0 + 1) != 0;
        if (var_v0 == 0) {
            var_v0 = ((s32) sp24 < 0) ^ 1;
        }
    }
    return var_v0;
}

void GetBaseOrExpr(? **arg0, s32 *arg1) {
    *arg0 = NULL;
    if (Tokench == 0x28) {
        nexttoken();
        if ((Tokench == 0x69) && (LookUp(Tstring, arg0) != 0) && ((*arg0)->unk10 == 0)) {
            nexttoken();
            if (Tokench != 0x29) {
                posterror("Expected \")\" after base register", NULL, 1);
            }
            nexttoken();
            return;
        }
        unscan(0x28U);
        goto block_8;
    }
block_8:
    *arg1 = GetExpr();
}

void GetItem(s32 *arg0, s32 *arg1) {
    *arg0 = GetExpr();
    if (Tokench == 0x3A) {
        nexttoken();
        *arg1 = GetExpr();
        return;
    }
    *arg1 = 1;
}

void dw_GetItem(s32 *arg2) {
    dw_GetExpr();
    if (Tokench == 0x3A) {
        nexttoken();
        *arg2 = GetExpr();
        return;
    }
    *arg2 = 1;
}

void put_binasmfyle(void) {
    u32 temp_v1;
    void *temp_t2;

    if (in_repeat_block != 0) {
        temp_v1 = rep_size;
        if (temp_v1 >= (u32) rep_buffer.unk4) {
            rep_buffer.unk0 = grow_array(&rep_buffer + 4, temp_v1, 0x10, rep_buffer.unk0, 0);
        }
        temp_t2 = rep_buffer.unk0 + (temp_v1 * 0x10);
        temp_t2->unk0 = (? *) binasm_rec.unk0;
        temp_t2->unk4 = (s32) binasm_rec.unk4;
        temp_t2->unk8 = (s32) binasm_rec.unk8;
        temp_t2->unkC = (s32) binasm_rec.unkC;
        rep_size += 1;
        return;
    }
    fwrite(&binasm_rec, 0x10, 1U, binasmfyle);
    memset(&binasm_rec, 0, 0x10);
    binasm_count += 1;
}

s32 filesize(void **arg0) {
    ? sp28;
    void *temp_v0;

    if (arg0 != NULL) {
        temp_v0 = *arg0;
        if (temp_v0 != NULL) {
            if (fstat(temp_v0->unkD, &sp28) == 0) {
                return sp58;
            }
            /* Duplicate return node #5. Try simplifying control flow for better match */
            return -1;
        }
    }
    return -1;
}

void ltoa(u32 arg0, ? *arg1) {
    sprintf(arg1, "%d", arg0);
}

void st_error(? *arg0, s32 arg1, s32 *arg2, s32 arg3, s32 arg4) {
    fprintf(&__iob + 0x20, "libmld--");
    call_name_and_line(1);
    fprintf(&__iob + 0x20, arg0, arg1, arg2, arg3, arg4);
    fprintf(&__iob + 0x20, "\n");
    exit(1);
}

void st_warning(? *arg0, s32 arg1, s32 *arg2, s32 arg3, s32 arg4) {
    fprintf(&__iob + 0x20, "\nlibmld--");
    call_name_and_line(2);
    fprintf(&__iob + 0x20, arg0, arg1, arg2, arg3, arg4);
    fprintf(&__iob + 0x20, "\n");
}

void st_printf_2(? *arg0, s32 arg1) {
    fprintf(&__iob + 0x20, arg0, arg1);
}

void st_printf_3(? *arg0, s32 arg1, s32 *arg2) {
    fprintf(&__iob + 0x20, arg0, arg1, arg2);
}

void st_internal(? *arg0, s32 arg1, s32 *arg2, s32 arg3, s32 arg4) {
    fprintf(&__iob + 0x20, "libmld--");
    call_name_and_line(0);
    fprintf(&__iob + 0x20, arg0, arg1, arg2, arg3, arg4);
    fprintf(&__iob + 0x20, "\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Internal\0\0\0\x0error\0\0\0Warning\0Info");
    exit(1);
}

s32 l_addr(s32 arg0) {
    return arg0;
}

s32 e_addr(s32 arg0) {
    return arg0;
}

s32 s_addr(s32 arg0) {
    return arg0;
}

void func_00413060(u8 *arg0, s32 arg1) {
    if (verbose != 0) {
        if (arg1 != 3) {
            if (D_10001094 != 0) {
                fprintf(&__iob + 0x20, "\n", arg1);
                D_10001094 = 0;
            }
            goto block_5;
        }
        if (D_10001094 == 0) {
            goto block_5;
        }
    } else {
block_5:
        if (severity < arg1) {
            severity = severity;
        } else {
            severity = arg1;
        }
        if (arg1 != 3) {
            fprintf(&__iob + 0x20, "%s", (s32) "as0: ", (s32 *) arg1);
        }
        if (arg1 == 1) {
            debugflag = 0;
            goto block_14;
        }
        if (arg1 == 3) {
            D_10001094 = 1;
        } else {
block_14:
            fprintf(&__iob + 0x20, "%s: ", D_10001098[arg1], (s32 *) arg1);
            if (*arg0 != 0) {
                fprintf(&__iob + 0x20, "%s", (s32) arg0);
            }
            fprintf(&__iob + 0x20, ", line %1d:", CurrentLine);
        }
    }
}

void func_00413224(u8 *arg0) {
    if (D_10001090 != 0) {
        *arg0 = 0;
        return;
    }
    D_10001090 = 1;
    if (CurrentFile != -1) {
        strcpy(arg0, st_str_idn(CurrentFile, arg0));
    } else {
        *arg0 = 0;
    }
    D_10001090 = 0;
}

void call_name_and_line(s32 arg0) {
    u8 sp20;

    func_00413224(&sp20);
    func_00413060(&sp20, arg0);
}

void call_perror(? *arg1) {
    call_name_and_line();
    perror(arg1);
    fflush(&__iob + 0x20);
}

void new_error(void) {
    call_perror(1, NULL);
    fflush(&__iob + 0x20);
}

void posterror(s32 arg0, s32 arg1, s32 arg2) {
    if (warnexitflag != 0) {
        if (severity < arg2) {
            severity = severity;
        } else {
            severity = arg2;
        }
    }
    if ((arg2 < 2) || (nowarnflag == 0)) {
        call_name_and_line(arg2);
        fprintf(&__iob + 0x20, "%s", arg0);
        if (arg1 != 0) {
            fprintf(&__iob + 0x20, ": %s\n", arg1);
        } else {
            fprintf(&__iob + 0x20, "\n", arg1);
        }
        if ((printedline == 0) && (linelength > 0)) {
            fprintf(&__iob + 0x20, "     %s\n", (s32) line);
            printedline = 1;
        }
    }
}

void postcerror(s32 arg0, s32 arg1) {
    call_name_and_line(arg1);
    if (arg0 != 0) {
        fprintf(&__iob + 0x20, "%s\n", arg0);
    }
}

void assertion_failed(s32 arg0, s32 arg1, s32 *arg2) {
    call_name_and_line(0);
    fprintf(&__iob + 0x20, "%s, line %1d:\n", arg1, arg2);
    if (arg0 != 0) {
        fprintf(&__iob + 0x20, "    assertion (%s) failed\n\0\0-EB\0-EL\0-G\0\0-K\0\0-M\0\0-NR\0-O\0\0-O0\0-O1\0-O2\0-O3\0-O4\0-Olimit\0-R\0\0-RD\0-T\0\0-e\0\0-fli\0\0\0\0-f\0\0-f0\0-f1\0-f2\0-f3\0-f4\0-g\0\0-g0\0-g1\0-g2\0-g3\0-l\0\0-o\0\0-p\0\0-p0\0-p1\0-p2\0-p3\0-r\0\0-t\0\0-v\0\0-w\0\0-w1\0-w2\0-w3\0-no_const_opts\0\0-no_lui_opts\0\0\0\0-no_div_rem_opts\0\0\0\0-no_at_compression\0\0-no_branch_target\0\0\0-mips1\0\0-mips2\0\0-mips3\0\0-mips4\0\0-nopool\0-align8\0-align16\0\0\0\0-align32\0\0\0\0-align64\0\0\0\0-align_common\0\0\0-gp_warn\0\0\0\0-non_pic\0\0\0\0-r3000\0\0-r4000\0\0-r6000\0\0-r6000LHU\0\0\0-r6000LWL\0\0\0-trapuv\0-nopeep\0-peepdbg\0\0\0\0-noswpipe\0\0\0-swpdbg\0-nosymregs\0\0-noxbb\0\0-aggr_xbb\0\0\0-xbbdbg\0-newhilo\0\0\0\0-domtag\0-fpstall_nop\0\0\0\0-noglobal\0\0\0-nobopt\0-dwalign\0\0\0\0-excpt\0\0-diag\0\0\0-mednat\0-dwopcode\0\0\0-64bit\0\0-fp32reg\0\0\0\0-extsyms\0\0\0\0-pic0\0\0\0-pic1\0\0\0-pic2\0\0\0-big_got\0\0\0\0-coff\0\0\0-elf\0\0\0\0-mscoff\0-mscoff1\0\0\0\0-multi_issue\0\0\0\0-nonzero_scnbase\0\0\0\0-new_mdebug\0-abi\0\0\0\0-tfprev10\0\0\0-force_branch_fixup\0-r4200\0\0-r4600\0\0-tfp\0\0\0\0-r4300_mul", arg0);
    }
    fflush(&__iob + 0x20);
    exit(1);
}

s32 which_opt(? *arg0) {
    ? **var_s1;
    s32 var_s0;

    var_s1 = opt_strings;
    var_s0 = 0;
loop_1:
    if (strcmp(arg0, *var_s1) == 0) {
        return var_s0;
    }
    var_s0 += 1;
    var_s1 += 4;
    if (var_s0 == 0x6A) {
        return 0x69;
    }
    goto loop_1;
}

? *grow_array(? **arg0, u32 arg1, s32 arg2, ? *arg3, s32 arg4) {
    s32 sp28;
    s32 sp24;
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *var_s0;
    s32 temp_lo;
    s32 temp_lo_2;
    s32 temp_lo_3;
    u32 temp_t0;
    u32 temp_v0;
    u32 var_v0;

    temp_v0 = *arg0;
    if (temp_v0 == 0) {
        if (arg1 >= 0x400U) {
            *arg0 = arg1 + 1;
        } else {
            *arg0 = 0x400;
        }
        temp_lo = *arg0 * arg2;
        sp24 = temp_lo;
        temp_v0_2 = xmalloc(temp_lo);
        var_s0 = temp_v0_2;
        if (temp_v0_2 == NULL) {
            new_error();
        } else if (arg4 != 0) {
            var_s0 = memset(var_s0, 0, sp24, sp24);
        }
    } else {
        temp_lo_2 = temp_v0 * arg2;
        temp_t0 = temp_v0 * 2;
        *arg0 = temp_t0;
        var_v0 = temp_t0;
        if (arg1 >= temp_t0) {
            var_v0 = arg1 + 1;
            *arg0 = var_v0;
        }
        temp_lo_3 = var_v0 * arg2;
        sp28 = temp_lo_2;
        sp24 = temp_lo_3;
        temp_v0_3 = xrealloc(arg3, temp_lo_3);
        var_s0 = temp_v0_3;
        if (temp_v0_3 == NULL) {
            new_error();
        } else if (arg4 != 0) {
            memset(var_s0 + temp_lo_2, 0, sp24 - temp_lo_2, sp24);
        }
    }
    return var_s0;
}

? *st_cuinit(void) {
    ? *temp_v0;
    ? *var_v1;

    temp_v0 = calloc(0xBC, 1);
    var_v1 = temp_v0;
    st_pchdr = temp_v0;
    if (temp_v0 == NULL) {
        _md_st_error("st_cuinit: cannot allocate current chdr\n", &st_pchdr);
        var_v1 = st_pchdr;
    }
    var_v1->unk3C = 2;
    return st_pchdr;
}

void st_extadd(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    void *sp24;
    ? *temp_t0;
    s32 temp_v0;
    s32 var_a0;
    u8 temp_t3;
    u8 temp_t5;
    u8 temp_t7;
    u8 temp_t9;
    void *temp_v1;
    void *temp_v1_2;

    temp_t0 = st_pchdr;
    if (temp_t0 == NULL) {
        _md_st_internal("st_extadd: you didn't initialize with cuinit or readst\n");
    }
    var_a0 = temp_t0->unk1C;
    if (var_a0 >= temp_t0->unk20) {
        st_pchdr->unk18 = _md_st_malloc(temp_t0->unk18, (s32 *) (temp_t0 + 0x20), 0x10, 0x20);
        var_a0 = st_pchdr->unk1C;
    }
    temp_v1 = temp_t0->unk18 + (var_a0 * 0x10);
    sp24 = temp_v1;
    temp_v1->unk2 = _md_st_currentifd(var_a0);
    temp_t3 = temp_v1->unk0 & 0xFF7F;
    temp_t5 = temp_t3 & 0xBF;
    temp_t7 = temp_t5 & 0xDF;
    temp_v1->unk0 = temp_t3;
    temp_t9 = temp_t7 & 0xEF;
    temp_v1->unk0 = temp_t5;
    temp_v1->unk0 = temp_t7;
    temp_v1->unk0 = temp_t9;
    temp_v1->unk0 = (u8) (temp_t9 & 0xF7);
    temp_v1->unk0 = (s16) ((u16) temp_v1->unk0 & 0xF800);
    temp_v1->unk4 = arg0;
    temp_v1->unk8 = arg1;
    temp_v1->unkC = (u8) ((arg2 * 4) | (temp_v1->unkC & 0xFF03));
    temp_v1->unkC = (s16) (((arg3 << 5) & 0x3E0) | ((u16) temp_v1->unkC & 0xFC1F));
    temp_v1->unkD = (u8) (temp_v1->unkD & 0xFFEF);
    temp_v0 = (s32) temp_v1->unkC;
    temp_v1->unkC = (s32) (((u32) (((arg4 & 0xFFFFF) ^ temp_v0) << 0xC) >> 0xC) ^ temp_v0);
    if ((arg3 != 0x12) && (arg3 != 0x11) && (arg3 != 0) && (arg3 != 6) && (arg3 != 0x15)) {
        temp_v1_2 = *st_pcfd_ifd(temp_v1->unk2);
        temp_v1_2->unk3C = (u8) (temp_v1_2->unk3C & 0xFFFB);
    }
    st_pchdr->unk1C = (s32) (st_pchdr->unk1C + 1);
}

void *st_pext_iext(s32 arg0) {
    if ((arg0 < 0) || (st_pchdr->unk1C < arg0)) {
        _md_st_internal("st_pext_iext: index out of range (%d)\n", arg0);
    }
    return st_pchdr->unk18 + (arg0 * 0x10);
}

void st_idn_index_fext(s32 arg0, s32 arg1) {
    s32 sp34;
    s32 sp30;
    s32 sp2C;
    ? *temp_v1;
    s32 temp_v0;
    s32 var_t0;
    void *temp_t6;

    temp_v1 = st_pchdr;
    if (temp_v1 == NULL) {
        _md_st_internal("st_idn_index_fext: you didn't initialize with cuinit or readst\n");
    }
    temp_v0 = temp_v1->unk40;
    var_t0 = temp_v0;
    if (temp_v1->unk3C >= temp_v0) {
        sp2C = temp_v0;
        var_t0 = sp2C;
        st_pchdr->unk38 = _md_st_malloc(temp_v1->unk38, (s32 *) (temp_v1 + 0x40), 8, 0x80);
    }
    if (var_t0 == 0) {
        bzero(st_pchdr->unk38, 0x10);
    }
    sp34 = arg0;
    if (arg1 != 0) {
        sp30 = 0x7FFFFFFF;
    } else {
        sp30 = _md_st_currentifd();
    }
    temp_t6 = st_pchdr->unk38 + (st_pchdr->unk3C * 8);
    temp_t6->unk0 = (s32) sp30.unk0;
    temp_t6->unk4 = (s32) sp30.unk4;
    st_pchdr->unk3C = (s32) (st_pchdr->unk3C + 1);
}

s32 *st_pdn_idn(s32 arg0) {
    if ((arg0 < 0) || (st_pchdr->unk3C < arg0)) {
        _md_st_internal("st_pdn_idn: idn (%d) less than 0 or greater than max (%d)\n", arg0, st_pchdr->unk3C);
    }
    return st_pchdr->unk38 + (arg0 * 8);
}

void st_symadd(s32 arg0, u32 arg1, u32 arg2, u32 arg3, s32 arg4) {
    s32 temp_a1;
    s32 var_a0;
    void **temp_v1;
    void *temp_v0;
    void *temp_v1_2;
    void *temp_v1_3;

    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_v1 = pcfdcur;
    if (temp_v1 == NULL) {
        _md_st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    if (temp_v1->unk3C & 2) {
        _md_st_internal("routine: cannot add to this entry it was readin from disk\n");
    }
    var_a0 = temp_v1->unk0->unk14;
    if (var_a0 >= temp_v1->unk8) {
        pcfdcur->unk4 = _md_st_malloc(temp_v1->unk4, (s32 *) (temp_v1 + 8), 0xC, 0x40);
        var_a0 = pcfdcur->unk0->unk14;
    }
    temp_v0 = temp_v1->unk4 + (var_a0 * 0xC);
    temp_v0->unk0 = arg0;
    temp_v0->unk8 = (u8) ((arg2 * 4) | (temp_v0->unk8 & 0xFF03));
    temp_v0->unk4 = arg1;
    temp_v0->unk8 = (s16) (((arg3 << 5) & 0x3E0) | ((u16) temp_v0->unk8 & 0xFC1F));
    temp_v0->unk9 = (u8) (temp_v0->unk9 & 0xFFEF);
    temp_a1 = (s32) temp_v0->unk8;
    temp_v0->unk8 = (s32) (((u32) (((arg4 & 0xFFFFF) ^ temp_a1) << 0xC) >> 0xC) ^ temp_a1);
    if ((arg2 == 0xE) || (arg2 == 2) || (arg2 == 5) || (arg2 == 6)) {
        temp_v1_2 = pcfdcur->unk0;
        temp_v1_2->unk3C = (u8) (temp_v1_2->unk3C & 0xFFFB);
    }
    temp_v1_3 = pcfdcur->unk0;
    temp_v1_3->unk14 = (s32) (temp_v1_3->unk14 + 1);
}

s32 st_ifd_pcfd(void **arg0) {
    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    if (pcfdcur == NULL) {
        _md_st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    return (s32) (arg0 - st_pchdr->unk4) >> 6;
}

void **st_pcfd_ifd(s32 arg0) {
    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n", arg0);
    }
    if ((arg0 < 0) || (arg0 >= st_pchdr->unkC)) {
        _md_st_internal("st_pcfd_ifd: ifd (%d) out of range\n", arg0);
    }
    return st_pchdr->unk4 + (arg0 << 6);
}

s32 *st_psym_ifd_isym(s32 arg0, s32 arg1) {
    s32 sp24;
    s32 var_t8;
    void **var_v1;

    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n", arg1, arg0);
    }
    if (arg0 == 0x7FFFFFFF) {
        return st_pext_iext(arg1) + 4;
    }
    if ((arg0 < 0) || (arg1 < 0) || (arg0 >= st_pchdr->unkC) || (var_v1 = st_pchdr->unk4 + (arg0 << 6), var_t8 = arg1 * 4, ((arg1 < (*var_v1)->unk14) == 0))) {
        sp24 = arg0 << 6;
        _md_st_internal("st_psym_ifd_isym: ifd (%d) or isym (%d) out of range\n", arg0, arg1, arg0);
        var_v1 = st_pchdr->unk4 + sp24;
        var_t8 = arg1 * 4;
    }
    return var_v1->unk4 + ((var_t8 - arg1) * 4);
}

u32 *st_paux_iaux(s32 arg0) {
    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    if (pcfdcur == NULL) {
        _md_st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    if ((arg0 < 0) || (arg0 >= (*pcfdcur)->unk30)) {
        _md_st_internal("st_paux_iaux: iaux (%d) out of range\n", arg0);
    }
    return pcfdcur->unkC + (arg0 * 4);
}

? *st_str_ifd_iss(s32 arg0, s32 arg1) {
    s32 temp_v1;
    void **temp_v0;

    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n", arg0);
    }
    if (arg0 == 0x7FFFFFFF) {
        return _md_st_str_extiss(arg1, arg1, (s16) arg0);
    }
    temp_v0 = st_pcfd_ifd((s16) arg0, arg1, (s16) arg0);
    temp_v1 = temp_v0->unk0->unkC;
    if ((temp_v1 != 0) && (arg1 < temp_v1)) {
        return temp_v0->unk14 + arg1;
    }
    return NULL;
}

void *st_ppd_ifd_isym(s32 arg0, s32 arg1) {
    s32 var_a1;
    u32 var_v1;
    void **temp_v0;
    void *var_a0;

    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n", arg1);
    }
    temp_v0 = st_pcfd_ifd((s16) arg0);
    var_v1 = 0;
    if (temp_v0->unk0->unk2A != 0) {
        var_a0 = temp_v0->unk34;
        var_a1 = 0;
loop_4:
        if (arg1 == var_a0->unk4) {
            return temp_v0->unk34 + var_a1;
        }
        var_v1 += 1;
        var_a1 += 0x34;
        var_a0 += 0x34;
        if (var_v1 >= (u16) temp_v0->unk0->unk2A) {
            goto block_7;
        }
        goto loop_4;
    }
block_7:
    return NULL;
}

void _md_st_internal(? *arg0, s32 arg1, s32 *arg2, s32 arg3, s32 arg4) {
    fprintf(&__iob + 0x20, "%s: Internal: ", st_errname);
    fprintf(&__iob + 0x20, arg0, arg1, arg2, arg3, arg4);
    fprintf(&__iob + 0x20, "\n");
    exit(1);
}

void _md_st_error(? *arg0, s32 arg1, s32 *arg2, s32 arg3, s32 arg4) {
    fprintf(&__iob + 0x20, "%s: Error: ", st_errname);
    fprintf(&__iob + 0x20, arg0, arg1, arg2, arg3, arg4);
    fprintf(&__iob + 0x20, "\n");
    exit(1);
}

? *_md_st_str_extiss(s32 arg0) {
    if ((arg0 >= 0) && (arg0 < st_pchdr->unk28)) {
        return st_pchdr->unk24 + arg0;
    }
    return NULL;
}

s32 _md_st_str_iss(s32 arg0) {
    s32 temp_v0;
    void **temp_v1;

    if (st_pchdr->unk4 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_v1 = pcfdcur;
    if (temp_v1 == NULL) {
        _md_st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    temp_v0 = temp_v1->unk0->unkC;
    if (temp_v0 != 0) {
        if (arg0 < temp_v0) {
            return temp_v1->unk14 + arg0;
        }
        /* Duplicate return node #8. Try simplifying control flow for better match */
        return 0;
    }
    return 0;
}

s32 _md_st_iextmax(void) {
    return st_pchdr->unk1C;
}

s16 _md_st_currentifd(void) {
    if (pcfdcur == NULL) {
        return -1;
    }
    return st_ifd_pcfd(pcfdcur);
}

? *_md_st_malloc(? *arg0, s32 *arg1, s32 arg2, s32 arg3) {
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *temp_v0_4;
    ? *var_s1;
    ? *var_v0;
    s32 temp_lo;
    s32 temp_t0;
    s32 temp_v0;

    temp_v0 = *arg1;
    if ((temp_v0 == 0) || (arg0 == NULL) || (temp_t0 = temp_v0 * 2, (arg0 == (? *)-1))) {
        *arg1 = arg3;
        if (arg3 == 0) {
            temp_v0_2 = malloc(1);
            var_s1 = temp_v0_2;
            if (temp_v0_2 == NULL) {
                _md_st_error("_md_st_malloc: cannot allocate item of 1 byte with malloc(3)\n");
            }
            goto block_12;
        }
        temp_v0_3 = malloc(*arg1 * arg2);
        var_s1 = temp_v0_3;
        if (temp_v0_3 == NULL) {
            temp_lo = *arg1 * arg2;
            var_v0 = var_s1;
            if (temp_lo != 0) {
                _md_st_error("_md_st_malloc: cannot allocate item of %ld bytes with malloc(3)\n", (? **) temp_lo);
                goto block_12;
            }
        } else {
            goto block_12;
        }
    } else {
        *arg1 = temp_t0;
        temp_v0_4 = realloc(arg0, temp_t0 * arg2);
        var_s1 = temp_v0_4;
        if (temp_v0_4 == NULL) {
            _md_st_error("_md_st_malloc: cannot grow item to %ld bytes with realloc(3)\n", (? **) (*arg1 * arg2));
        }
block_12:
        var_v0 = var_s1;
    }
    return var_v0;
}

s32 _md_st_ifdmax(void) {
    return st_pchdr->unkC;
}

void _md_st_setfd(s32 arg0) {
    s32 var_v0;

    var_v0 = st_pchdr->unk4;
    if (var_v0 == 0) {
        _md_st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
        var_v0 = st_pchdr->unk4;
    }
    pcfdcur = var_v0 + (arg0 << 6);
}

void __sgi_mld_st_commonbegin(void) {
    __sgi_common_dummy_file = 1;
    st_filebegin();
    __sgi_common_dummy_file = 0;
}

s32 st_filebegin(? *arg0, s32 arg1, s32 arg2, s32 arg3) {
    s32 *var_v0;
    s32 temp_v0;
    s32 var_a0;
    s32 var_s0;
    s32 var_t2;
    s32 var_v1;

    var_s0 = 0;
    if (st_ifdmax() > 0) {
loop_2:
        if (strcmp(arg0, st_str_ifd_iss(var_s0, 1)) == 0) {
            var_v1 = B_1000A830 - 1;
            if (var_v1 >= 0) {
                var_v0 = B_1000A82C + (var_v1 * 8);
loop_5:
                if (var_s0 != *var_v0) {
                    var_v1 -= 1;
                    var_v0 -= 8;
                    if (var_v1 >= 0) {
                        goto loop_5;
                    }
                }
            }
            if (var_v1 >= 0) {
                var_t2 = B_1000A830 - 1;
                if (var_s0 != (B_1000A82C + (B_1000A830 * 8))->unk-8) {
                    do {
                        B_1000A830 = var_t2;
                        var_a0 = var_t2;
                        if (var_t2 < 0) {
                            st_internal("st_filebegin: tried to end too many files (%s)\n", (s32) arg0);
                            var_a0 = B_1000A830;
                        }
                        var_t2 = var_a0 - 1;
                    } while (var_s0 != (B_1000A82C + (var_a0 * 8))->unk-8);
                }
                st_setfd(var_s0);
                return (B_1000A82C + (B_1000A830 * 8))->unk-4;
            }
            goto block_13;
        }
block_13:
        var_s0 += 1;
        if (var_s0 >= st_ifdmax()) {
            goto block_14;
        }
        goto loop_2;
    }
block_14:
    st_fdadd(arg0, arg1, arg2, arg3);
    st_feinit();
    if (B_1000A830 >= B_1000A834) {
        B_1000A82C = st_malloc(B_1000A82C, &B_1000A834, 8, 0x19);
    }
    *(B_1000A82C + (B_1000A830 * 8)) = st_currentifd();
    (B_1000A82C + (B_1000A830 * 8))->unk4 = st_idn_index_fext(st_symadd(1, 0U, 0xBU, 1U, 0xFFFFF), 0);
    temp_v0 = (B_1000A82C + (B_1000A830 * 8))->unk4;
    B_1000A830 += 1;
    return temp_v0;
}

void st_endallfiles(void) {
    s32 sp38;
    s16 var_s1;
    s32 *temp_v0_2;
    s32 temp_a0;
    s32 temp_s0;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_a1;
    void **temp_v0;

    sp38 = st_currentifd();
    var_s1 = 0;
    if (st_ifdmax() > 0) {
        do {
            temp_v0 = st_pcfd_ifd(var_s1);
            temp_v1 = temp_v0->unk4;
            if ((temp_v1 == 0) || (temp_v1 == -1) || (temp_a0 = temp_v0->unk0->unk14, (temp_a0 <= 0)) || (temp_a1 = (temp_v1 + (temp_a0 * 0xC))->unk-4, ((temp_a1 >> 0x1A) != 8)) || ((temp_a1 << 0xC) != 0)) {
                st_setfd((s32) var_s1);
                temp_s0 = st_symadd(*st_psym_ifd_isym((s32) var_s1, 0), 0U, 8U, 1U, 0);
                temp_v0_2 = st_psym_ifd_isym((s32) var_s1, 0);
                temp_v1_2 = temp_v0_2->unk8;
                temp_v0_2->unk8 = (s32) (((u32) ((((temp_s0 + 1) & 0xFFFFF) ^ temp_v1_2) << 0xC) >> 0xC) ^ temp_v1_2);
            }
            var_s1 += 1;
        } while (var_s1 < st_ifdmax());
    }
    st_setfd(sp38);
    free(B_1000A82C);
    B_1000A82C = NULL;
    B_1000A830 = 0;
    B_1000A834 = 0;
}

s32 st_fileend(void) {
    s32 sp4C;
    s32 sp48;
    s32 *sp44;
    s32 sp3C;
    s32 *temp_v0;
    s32 *temp_v0_3;
    s32 temp_a0;
    s32 temp_a1_2;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    u32 temp_a1;
    void **temp_v0_2;

    temp_v0 = st_pdn_idn();
    sp48.unk0 = temp_v0->unk0;
    sp48.unk4 = (s32) temp_v0->unk4;
    temp_v0_2 = st_pcfd_ifd((s16) sp48);
    temp_v1 = temp_v0_2->unk4;
    if ((temp_v1 != 0) && (temp_v1 != -1)) {
        temp_a0 = temp_v0_2->unk0->unk14;
        if (temp_a0 > 0) {
            temp_a1 = (temp_v1 + (temp_a0 * 0xC))->unk-4;
            if (((temp_a1 >> 0x1A) == 8) && ((temp_a1 << 0xC) == 0)) {
                return -1;
            }
        }
    }
    sp3C = st_currentifd();
    st_setfd(sp48);
    temp_v0_3 = st_psym_ifd_isym(sp48, sp4C);
    sp44 = temp_v0_3;
    temp_v1_2 = sp44->unk8;
    temp_a1_2 = st_symadd(*temp_v0_3, 0U, 8U, 1U, 0) & 0xFFFFF;
    sp44->unk8 = (s32) (((u32) ((temp_a1_2 ^ temp_v1_2) << 0xC) >> 0xC) ^ temp_v1_2);
    sp4C = temp_a1_2;
    temp_v1_3 = sp44->unk8;
    sp44->unk8 = (s32) (((u32) ((((temp_v1_3 & 0xFFFFF) + 1) ^ temp_v1_3) << 0xC) >> 0xC) ^ temp_v1_3);
    st_setfd(sp3C, temp_a1_2);
    return st_idn_dn(sp48.unk0, sp48.unk4);
}

s32 st_textblock(u32 arg1, u32 arg2) {
    s32 sp34;
    s32 sp30;
    s32 sp2C;
    u32 var_a1;
    u32 var_a2;
    void *temp_t1;

    var_a1 = arg1;
    var_a2 = arg2;
    if (D_10001384 != 0) {
        var_a1 = 0;
        var_a2 = 7;
        if (B_1000A824 >= 2) {
            D_10001384 = 0;
            sp34 = st_symadd(0, 0U, 7U, 1U, 0);
            sp2C = st_currentifd();
            sp30 = sp34;
            temp_t1 = B_1000A820 + (B_1000A824 * 8);
            temp_t1->unk-8 = (s32) sp2C.unk0;
            temp_t1->unk-4 = (s32) sp2C.unk4;
            return st_idn_dn(sp2C.unk0, sp2C.unk4);
        }
    }
    if (D_10001384 != 0) {
        st_internal("st_textblock: block pending set in illegal case\n", (s32) var_a1, (s32 *) var_a2);
    }
    return 0;
}

s32 _sgi_st_blockbegin(u32 arg2, s32 arg3) {
    s32 sp34;
    s32 sp30;
    s32 sp2C;
    s32 temp_v1;
    s32 var_t0;
    void *temp_t3;

    if ((arg2 == 1) && (var_t0 = 0xFFFFF, (B_1000A824 != 0))) {
        D_10001384 = 1;
    } else {
        var_t0 = st_symadd(arg3, arg2, 0U);
    }
    sp34 = var_t0;
    temp_v1 = B_1000A824;
    sp2C = st_currentifd();
    sp30 = var_t0;
    if (temp_v1 >= B_1000A828) {
        sp34 = var_t0;
        B_1000A820 = st_malloc(B_1000A820, &B_1000A828, 8, 0x19);
    }
    temp_t3 = B_1000A820 + (temp_v1 * 8);
    temp_t3->unk0 = (s32) sp2C.unk0;
    temp_t3->unk4 = (s32) sp2C.unk4;
    B_1000A824 += 1;
    if (var_t0 == 0xFFFFF) {
        return 0;
    }
    return st_idn_dn(sp2C.unk0, sp2C.unk4);
}

s32 st_blockbegin(u32 arg2) {
    s32 sp34;
    s32 sp30;
    s32 sp2C;
    s32 temp_v1;
    s32 var_t0;
    void *temp_t2;

    if ((arg2 == 1) && (var_t0 = 0xFFFFF, (B_1000A824 != 0))) {
        D_10001384 = 1;
    } else {
        var_t0 = st_symadd(7, arg2, 0U);
    }
    sp34 = var_t0;
    temp_v1 = B_1000A824;
    sp2C = st_currentifd();
    sp30 = var_t0;
    if (temp_v1 >= B_1000A828) {
        sp34 = var_t0;
        B_1000A820 = st_malloc(B_1000A820, &B_1000A828, 8, 0x19);
    }
    temp_t2 = B_1000A820 + (temp_v1 * 8);
    temp_t2->unk0 = (s32) sp2C.unk0;
    temp_t2->unk4 = (s32) sp2C.unk4;
    B_1000A824 += 1;
    if (var_t0 == 0xFFFFF) {
        return 0;
    }
    return st_idn_dn(sp2C.unk0, sp2C.unk4);
}

s32 st_blockend(s32 arg0) {
    s32 *sp3C;
    s32 sp34;
    s32 sp30;
    s32 sp2C;
    s32 *temp_v0_2;
    s32 temp_t4;
    s32 temp_t7;
    s32 temp_v0;
    s32 temp_v1;
    void *temp_t3;

    temp_t7 = B_1000A824 - 1;
    B_1000A824 = temp_t7;
    temp_t3 = B_1000A820 + (temp_t7 * 8);
    sp34.unk0 = temp_t3->unk0;
    sp34.unk4 = (s32) temp_t3->unk4;
    if (sp38 == 0xFFFFF) {
        D_10001384 = 0;
        return 0;
    }
    sp3C = st_psym_ifd_isym(sp34, sp38);
    sp2C = st_currentifd();
    st_setfd(sp34);
    sp30 = st_symadd(0, 0U, 8U, (u32) (sp3C->unk8 << 6) >> 0x1B, (B_1000A820 + (B_1000A824 * 8))->unk4) + 1;
    temp_v0_2 = st_psym_ifd_isym(sp34, sp38);
    temp_v1 = temp_v0_2->unk8;
    temp_t4 = ((u32) (((sp30 & 0xFFFFF) ^ temp_v1) << 0xC) >> 0xC) ^ temp_v1;
    temp_v0_2->unk8 = temp_t4;
    if (((u32) (temp_t4 << 6) >> 0x1B) != 1) {
        temp_v0_2->unk4 = arg0;
    }
    temp_v0 = st_idn_index_fext((temp_v0_2->unk8 & 0xFFFFF) - 1, 0);
    sp30 = temp_v0;
    st_setfd(sp2C);
    return temp_v0;
}

void st_blockpop(void) {
    B_1000A824 -= 1;
}

s32 st_procend(s32 arg0) {
    void *sp54;
    s32 *sp50;
    s32 sp48;
    s32 sp44;
    s32 sp3C;
    s32 sp38;
    s32 *temp_v0;
    s32 temp_s0;
    s32 temp_t5;
    s32 var_s0;
    u32 temp_t6;
    u32 temp_v0_3;
    void *temp_v0_2;

    temp_v0 = st_pdn_idn();
    sp44.unk0 = temp_v0->unk0;
    sp44.unk4 = (s32) temp_v0->unk4;
    if (sp44 == 0x7FFFFFFF) {
        sp3C = 1;
        temp_v0_2 = st_pext_iext(sp48);
        sp54 = temp_v0_2;
        sp50 = st_psym_ifd_isym((s32) temp_v0_2->unk2, temp_v0_2->unkC & 0xFFFFF);
        sp44 = (s32) sp54->unk2;
        temp_t5 = sp54->unkC & 0xFFFFF;
        var_s0 = temp_t5;
        sp48 = temp_t5;
    } else {
        sp3C = 0;
        var_s0 = sp48;
        sp50 = st_psym_ifd_isym(sp44, sp48);
    }
    sp38 = st_currentifd();
    st_setfd(sp44);
    temp_s0 = st_symadd(sp50->unk0, 0U, 8U, 1U, var_s0);
    sp50 = st_psym_ifd_isym(sp44, sp48);
    temp_t6 = sp50->unk8 & 0xFFFFF;
    if ((u32) (*st_pcfd_ifd(st_currentifd()))->unk30 >= temp_t6) {
        if (temp_t6 != 0xFFFFF) {
            *st_paux_iaux((s32) temp_t6) = temp_s0 + 1;
        }
    }
    if (sp3C == 1) {
        temp_v0_3 = sp54->unkC;
        if ((temp_v0_3 >> 0x1A) == 0xE) {
            st_setidn(arg0, st_idn_index_fext(temp_v0_3 & 0xFFFFF, 0));
            sp54->unkC = (s16) ((u16) sp54->unkC & 0xFC1F);
        }
    }
    arg0 = st_idn_index_fext(temp_s0, 0);
    st_setfd(sp38);
    return arg0;
}

u32 st_procbegin(u32 arg0) {
    s32 sp30;
    s32 *temp_v0;
    u32 temp_v1;
    u32 temp_v1_2;
    u32 temp_v1_3;
    void *temp_v0_2;
    void *temp_v1_4;

    temp_v0 = st_pdn_idn();
    sp30.unk0 = temp_v0->unk0;
    sp30.unk4 = (s32) temp_v0->unk4;
    if (sp30 != 0x7FFFFFFF) {
        return arg0;
    }
    temp_v0_2 = st_pext_iext(sp34);
    if (((u32) (temp_v0_2->unkC << 6) >> 0x1B) == 1) {
        return arg0;
    }
    temp_v0_2->unkC = (s16) (((u16) temp_v0_2->unkC & 0xFC1F) | 0x20);
    if (st_currentifd() != temp_v0_2->unk2) {
        if (((*st_pcfd_ifd(st_currentifd()))->unk30 > 0) && ((temp_v0_2->unkC & 0xFFFFF) != 0xFFFFF)) {
            temp_v1 = temp_v0_2->unkC;
            temp_v0_2->unkC = (u32) (((u32) (((st_iaux_copyty(temp_v0_2->unk2, temp_v0_2 + 4) & 0xFFFFF) ^ temp_v1) << 0xC) >> 0xC) ^ temp_v1);
        }
        temp_v0_2->unk2 = st_currentifd();
    }
    temp_v1_2 = temp_v0_2->unkC;
    temp_v1_3 = temp_v0_2->unkC;
    temp_v0_2->unkC = (u32) (((u32) (((st_symadd(st_stradd(st_str_extiss(temp_v0_2->unk4)), 0U, temp_v1_2 >> 0x1A, 1U, temp_v1_2 & 0xFFFFF) & 0xFFFFF) ^ temp_v1_3) << 0xC) >> 0xC) ^ temp_v1_3);
    temp_v1_4 = *st_pcfd_ifd(temp_v0_2->unk2);
    temp_v1_4->unk3C = (u8) (temp_v1_4->unk3C & 0xFFFB);
    return arg0;
}

u32 st_sym_idn(u32 *arg1, s32 *arg2, s32 *arg3, s32 *arg4) {
    s32 sp28;
    s32 *temp_v0;
    s32 *temp_v0_2;

    temp_v0_2 = st_pdn_idn();
    sp28.unk0 = temp_v0_2->unk0;
    sp28.unk4 = (s32) temp_v0_2->unk4;
    if (sp2C == 0xFFFFF) {
        return -1U;
    }
    temp_v0 = st_psym_ifd_isym(sp28, sp2C);
    *arg1 = (u32) (temp_v0->unk8 << 6) >> 0x1B;
    *arg2 = (u32) temp_v0->unk8 >> 0x1A;
    *arg3 = temp_v0->unk4;
    *arg4 = temp_v0->unk8 & 0xFFFFF;
    return st_str_ifd_iss(sp28, temp_v0->unk0);
}

? *st_str_idn(void) {
    s32 sp28;
    s32 *temp_v0;

    temp_v0 = st_pdn_idn();
    sp28.unk0 = temp_v0->unk0;
    sp28.unk4 = (s32) temp_v0->unk4;
    if (sp2C == 0xFFFFF) {
        return (? *)-1;
    }
    return st_str_ifd_iss(sp28, *st_psym_ifd_isym(sp28, sp2C));
}

s32 st_fglobal_idn(void) {
    s32 sp28;
    s32 *temp_v0;
    s32 *temp_v0_2;
    s32 var_v0;

    temp_v0 = st_pdn_idn();
    sp28.unk0 = temp_v0->unk0;
    sp28.unk4 = (s32) temp_v0->unk4;
    if (sp2C == 0xFFFFF) {
        var_v0 = 0;
    } else {
        temp_v0_2 = st_psym_ifd_isym(sp28, sp2C);
        var_v0 = ((u32) temp_v0_2->unk8 >> 0x1A) != 2;
        if (var_v0 != 0) {
            var_v0 = ((u32) temp_v0_2->unk8 >> 0x1A) != 0xE;
        }
    }
    return var_v0;
}

s32 *st_psym_idn_offset(s32 arg1) {
    s32 sp64;                                       /* compiler-managed */
    s32 sp60;
    s32 *temp_v0;
    s32 *temp_v0_2;
    s32 *temp_v0_4;
    u32 *temp_v0_5;
    u32 temp_a1;
    u32 temp_a1_2;
    u32 temp_s0;
    u32 temp_t6;
    u32 temp_t9;
    u32 temp_v1;
    void *temp_v0_3;

    temp_v0_2 = st_pdn_idn();
    sp60.unk0 = temp_v0_2->unk0;
    sp60.unk4 = (s32) temp_v0_2->unk4;
    if (sp60 == 0x7FFFFFFF) {
        temp_v0_3 = st_pext_iext(sp64);
        sp60 = (s32) temp_v0_3->unk2;
        sp64 = temp_v0_3->unkC & 0xFFFFF;
    }
    temp_v0_4 = st_psym_ifd_isym(sp60, sp64);
    if ((temp_v0_4->unk8 & 0xFFFFF) == 0xFFFFF) {
        goto block_24;
    }
    temp_v0_5 = st_paux_ifd_iaux(sp60, temp_v0_4->unk8 & 0xFFFFF, temp_v0_4);
    if (temp_v0_5 == NULL) {
        goto block_24;
    }
    temp_s0 = *temp_v0_5;
    temp_t6 = sp64 + 1;
    sp64 = temp_t6;
    if (temp_t6 < temp_s0) {
loop_9:
        temp_v0 = st_psym_ifd_isym(sp60, (s32) sp64);
        temp_a1 = temp_v0->unk8;
        temp_v1 = temp_a1 >> 0x1A;
        if (((temp_v1 == 4) || (temp_v1 == 3)) && ((temp_t9 = (u32) (temp_a1 << 6) >> 0x1B, (temp_t9 == 5)) || (temp_t9 == 0x10)) && (arg1 == temp_v0->unk4)) {
            return temp_v0;
        }
        if ((temp_v1 != 6) && (temp_v1 != 0xE)) {
            if ((((u32) (temp_a1 << 6) >> 0x1B) == 0xB) && ((temp_v1 == 7) || (temp_v1 == 0x1A) || (temp_v1 == 0x1B) || (temp_v1 == 0x1C))) {
                sp64 = (temp_a1 & 0xFFFFF) - 1;
            }
            temp_a1_2 = sp64 + 1;
            sp64 = temp_a1_2;
            if (temp_a1_2 >= temp_s0) {
                goto block_24;
            }
            goto loop_9;
        }
        goto block_24;
    }
block_24:
    return NULL;
}

void st_fixextindex(s32 arg1) {
    void *sp2C;
    ? sp24;
    s32 *temp_v0;
    s32 temp_a0;

    temp_v0 = st_pdn_idn();
    sp24.unk0 = (s32) temp_v0->unk0;
    sp24.unk4 = (s32) temp_v0->unk4;
    sp2C = st_pext_iext(sp28);
    sp2C->unk2 = st_currentifd();
    temp_a0 = sp2C->unkC;
    sp2C->unkC = (s32) (((u32) (((arg1 & 0xFFFFF) ^ temp_a0) << 0xC) >> 0xC) ^ temp_a0);
    sp2C->unkC = (s16) (((u16) sp2C->unkC & 0xFC1F) | 0x20);
}

void st_fixextsc(s32 arg1) {
    ? sp24;
    s32 *temp_v0;
    void *temp_v0_2;

    temp_v0 = st_pdn_idn();
    sp24.unk0 = (s32) temp_v0->unk0;
    sp24.unk4 = (s32) temp_v0->unk4;
    temp_v0_2 = st_pext_iext(sp28);
    temp_v0_2->unkC = (u16) (((arg1 << 5) & 0x3E0) | (temp_v0_2->unkC & 0xFC1F));
}

void st_pdadd_idn(void) {
    s32 *temp_v0;
    s32 var_a0;

    temp_v0 = st_pdn_idn();
    if (temp_v0->unk0 == 0x7FFFFFFF) {
        var_a0 = st_pext_iext(temp_v0->unk4)->unkC & 0xFFFFF;
    } else {
        var_a0 = temp_v0->unk4;
    }
    st_pdadd(var_a0);
}

void st_fixiss(s32 arg1) {
    s32 *temp_v0;
    s32 *var_v1;

    temp_v0 = st_pdn_idn();
    if (temp_v0->unk0 == 0x7FFFFFFF) {
        var_v1 = st_pext_iext(temp_v0->unk4) + 4;
    } else {
        var_v1 = st_psym_ifd_isym(temp_v0->unk0, temp_v0->unk4);
    }
    *var_v1 = arg1;
}

void st_changedn(s32 arg1, s32 arg2) {
    s32 *temp_v0;

    temp_v0 = st_pdn_idn();
    temp_v0->unk0 = arg1;
    temp_v0->unk4 = arg2;
}

s32 st_file_idn(? *arg0) {
    s32 *var_v0;
    s32 temp_s1;
    s32 var_s0;
    s32 var_s1;
    s32 var_v1_2;
    void *var_v1;

    if (st_currentpchdr() == NULL) {
        goto block_17;
    }
    var_s0 = 0;
    if (st_ifdmax() > 0) {
loop_4:
        if (strcmp(arg0, st_str_ifd_iss(var_s0, 1)) == 0) {
            var_v1_2 = B_1000A830 - 1;
            if (var_v1_2 >= 0) {
                var_v0 = B_1000A82C + (var_v1_2 * 8);
loop_7:
                if (var_s0 != *var_v0) {
                    var_v1_2 -= 1;
                    var_v0 -= 8;
                    if (var_v1_2 >= 0) {
                        goto loop_7;
                    }
                }
            }
            if (var_v1_2 >= 0) {
                temp_s1 = B_1000A830 * 8;
                var_v1 = B_1000A82C + temp_s1;
                if (var_s0 != var_v1->unk-8) {
                    var_s1 = temp_s1 - 8;
                    do {
                        var_v1 -= 8;
                        if (var_s1 < 0) {
                            st_internal("st_file_idn: istack underflow (%s)\n", (s32) arg0);
                            var_v1 = B_1000A82C + var_s1;
                        }
                        var_s1 -= 8;
                    } while (var_s0 != var_v1->unk-8);
                }
                return var_v1->unk-4;
            }
            goto block_16;
        }
block_16:
        var_s0 += 1;
        if (var_s0 >= st_ifdmax()) {
block_17:
            /* Duplicate return node #18. Try simplifying control flow for better match */
            return 0;
        }
        goto loop_4;
    }
    return 0;
}

u32 st_tqhigh_iaux(void) {
    u32 *temp_v0;
    u32 var_v0;

    temp_v0 = st_paux_iaux();
    if (temp_v0->unk0 & 0xF) {
        return temp_v0->unk0 & 0xF;
    }
    if (((u8) temp_v0->unk1 >> 4) != 0) {
        return (u8) temp_v0->unk1 >> 4;
    }
    if (temp_v0->unk0 & 0xF) {
        return temp_v0->unk0 & 0xF;
    }
    if (((u8) temp_v0->unk3 >> 4) != 0) {
        return (u8) temp_v0->unk3 >> 4;
    }
    if (temp_v0->unk2 & 0xF) {
        return temp_v0->unk2 & 0xF;
    }
    var_v0 = 0;
    if (((u16) temp_v0->unk2 >> 0xC) != 0) {
        var_v0 = (u16) temp_v0->unk2 >> 0xC;
    }
    return var_v0;
}

void st_shifttq(s32 arg1) {
    u32 *temp_v0;
    u8 temp_a0;
    u8 temp_t1;
    u8 temp_t3;
    u8 temp_t4;
    u8 temp_t6;
    u8 temp_v1;

    temp_v0 = st_paux_iaux();
    temp_v1 = temp_v0->unk1;
    temp_t4 = ((temp_v1 >> 4) & 0xF) | (temp_v1 & 0xFFF0);
    temp_v0->unk1 = temp_t4;
    temp_a0 = temp_v0->unk3;
    temp_t1 = temp_v0->unk2;
    temp_t3 = ((temp_a0 >> 4) & 0xF) | (temp_a0 & 0xFFF0);
    temp_v0->unk1 = (u8) ((temp_v0->unk0 * 0x10) | (temp_t4 & 0xF));
    temp_v0->unk3 = temp_t3;
    temp_v0->unk3 = (u8) ((temp_t1 * 0x10) | (temp_t3 & 0xF));
    temp_t6 = (((u16) temp_v0->unk2 >> 0xC) & 0xF) | (temp_t1 & 0xFFF0);
    temp_v0->unk2 = temp_t6;
    temp_v0->unk2 = (u8) ((arg1 * 0x10) | (temp_t6 & 0xF));
}

s32 st_iaux_copyty(s32 arg0, s32 *arg1) {
    s32 sp2C;
    s32 temp_t1;
    s32 var_s0;
    s32 var_s1;
    s32 var_s1_2;
    s32 var_t0;
    u32 *temp_v0;
    u32 temp_a0;
    u32 temp_v0_2;
    void *temp_a1;

    var_s1 = 0;
    temp_v0 = st_paux_ifd_iaux(arg1->unk8 & 0xFFFFF);
    var_t0 = 0 * 4;
    if (((u32) arg1->unk8 >> 0x1A) == 6) {
        var_s1 = 1;
        var_t0 = 1 * 4;
    }
    temp_a1 = var_t0 + temp_v0;
    temp_t1 = temp_a1->unk0 & 0x3F;
    var_s1_2 = var_s1 + 1;
    if (temp_t1 == 0x25) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 1;
    } else if ((temp_t1 == 0x11) || (temp_t1 == 0x14) || (temp_t1 == 0xC) || (temp_t1 == 0xD) || (temp_t1 == 0xF) || (temp_t1 == 0xE)) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 1;
    } else if (temp_t1 == 0x10) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 3;
    }
    if (((u16) temp_a1->unk2 >> 0xC) == 3) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 4;
    }
    if (((u8) temp_a1->unk2 & 0xF) == 3) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 4;
    }
    if (((u8) temp_a1->unk3 >> 4) == 3) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 4;
    }
    temp_a0 = (u32) temp_a1->unk0;
    if ((temp_a0 & 0xF) == 3) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 4;
    }
    if (((u8) temp_a1->unk1 >> 4) == 3) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 4;
    }
    if (((u16) temp_a1->unk0 & 0xF) == 3) {
        if (((u32) temp_v0[var_s1_2] >> 0x14) == 0xFFF) {
            var_s1_2 += 1;
        }
        var_s1_2 += 4;
    }
    if ((temp_a0 >> 0x1F) != 0) {
        var_s1_2 += 1;
    }
    var_s0 = 0;
    if (var_s1_2 > 0) {
        do {
            temp_v0_2 = arg1->unk8;
            if (var_s0 == 0) {
                sp2C = st_auxadd(*st_paux_ifd_iaux(arg0, (temp_v0_2 & 0xFFFFF) + var_s0, arg1));
            } else {
                st_auxadd(*st_paux_ifd_iaux(arg0, (temp_v0_2 & 0xFFFFF) + var_s0, arg1));
            }
            var_s0 += 1;
        } while (var_s0 != var_s1_2);
    }
    return sp2C;
}

void st_changeaux(u32 arg1) {
    *st_paux_iaux() = arg1;
}

void st_addtq(s32 arg1) {
    u32 *temp_v0;
    u8 temp_v1;
    u8 temp_v1_2;
    u8 temp_v1_3;

    temp_v0 = st_paux_iaux();
    if (((u16) temp_v0->unk2 >> 0xC) == 0) {
        temp_v0->unk2 = (s8) (((arg1 & 0xF) * 0x10) | ((u8) temp_v0->unk2 & 0xFF0F));
    } else {
        temp_v1 = (u8) temp_v0->unk2;
        if (!(temp_v1 & 0xF)) {
            temp_v0->unk2 = (s8) ((arg1 & 0xF) | (temp_v1 & 0xFFF0));
        } else {
            temp_v1_2 = temp_v0->unk3;
            if ((temp_v1_2 >> 4) == 0) {
                temp_v0->unk3 = (u8) ((arg1 * 0x10) | (temp_v1_2 & 0xFF0F));
            } else if (!(temp_v0->unk0 & 0xF)) {
                temp_v0->unk3 = (u8) ((arg1 & 0xF) | (temp_v1_2 & 0xFFF0));
            } else {
                temp_v1_3 = temp_v0->unk1;
                if ((temp_v1_3 >> 4) == 0) {
                    temp_v0->unk1 = (u8) ((arg1 * 0x10) | (temp_v1_3 & 0xFF0F));
                } else if (!((u16) temp_v0->unk0 & 0xF)) {
                    temp_v0->unk1 = (u8) ((arg1 & 0xF & 0xF) | (temp_v1_3 & 0xFFF0));
                }
            }
        }
    }
}

void st_changeauxrndx(s32 arg0, s32 arg1, s32 arg2) {
    u32 *sp2C;
    u32 *temp_v0;
    u32 temp_v0_2;
    u32 temp_v0_3;

    temp_v0 = st_paux_iaux();
    if (((u32) ((u32) temp_v0->unk0 >> 0x14) < 0xFFFU) && (arg1 >= 0xFFF)) {
        temp_v0_2 = temp_v0->unk0;
        sp2C = temp_v0;
        st_internal("tried to replace rndx aux (%d) that fits into one word (%d, %d) with one that can't (%d,%d)\n", arg0, (s32 *) (temp_v0_2 >> 0x14), temp_v0_2 & 0xFFFFF, arg1, arg2);
    }
    if ((u32) ((u32) temp_v0->unk0 >> 0x14) < 0xFFFU) {
        temp_v0->unk0 = (s16) ((arg1 * 0x10) | ((u16) temp_v0->unk0 & 0xF));
    } else {
        temp_v0->unk4 = arg1;
    }
    temp_v0_3 = temp_v0->unk0;
    temp_v0->unk0 = ((u32) (((arg2 & 0xFFFFF) ^ temp_v0_3) << 0xC) >> 0xC) ^ temp_v0_3;
}

void st_auxbtadd(s32 arg0) {
    ? *sp24;

    memset(&sp24, 0, 4);
    sp24 = (arg0 & 0x3F) | ((u8) sp24 & 0xFFC0);
    st_auxadd((u32) sp24);
}

void st_auxisymadd(s32 arg0) {
    s32 sp24;

    sp24 = arg0;
    st_auxadd();
}

s32 st_auxrndxadd(s32 arg0, s32 arg1) {
    u16 sp2C;                                       /* compiler-managed */
    u32 sp28;
    s32 sp24;
    s32 temp_v0;
    u32 temp_a0;

    sp2C |= 0xFFF0;
    sp2C = ((u32) (((arg1 & 0xFFFFF) ^ (s32) sp2C) << 0xC) >> 0xC) ^ (s32) sp2C;
    temp_a0 = sp2C;
    sp28 = temp_a0;
    temp_v0 = st_auxadd(temp_a0);
    sp24 = temp_v0;
    st_auxisymadd(arg0);
    return temp_v0;
}

void st_auxbtsize(s32 arg1) {
    u32 *temp_v0;

    temp_v0 = st_paux_iaux();
    *temp_v0 = (u8) (*temp_v0 | 0x80);
    st_auxisymadd(arg1);
}

void st_auxrndxadd_idn(void) {
    s32 *temp_v0;

    temp_v0 = st_pdn_idn();
    st_auxrndxadd(temp_v0->unk0, temp_v0->unk4);
}

void st_addcontinued(void) {
    u32 *temp_v0;

    temp_v0 = st_paux_iaux();
    *temp_v0 = (u8) (*temp_v0 | 0x40);
}

s16 st_currentifd(void) {
    if (pcfdcur == NULL) {
        return -1;
    }
    return st_ifd_pcfd(pcfdcur);
}

s32 st_ifdmax(void) {
    return st_pchdr->unkC;
}

void st_setfd(s32 arg0) {
    s32 var_v0;

    var_v0 = st_pchdr->unk4;
    if (var_v0 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
        var_v0 = st_pchdr->unk4;
    }
    pcfdcur = var_v0 + (arg0 << 6);
}

void st_fdadd(s32 arg0, s32 arg1, s32 arg2, s32 arg3) {
    s32 spEC;
    s32 spE8;
    s32 spE4;
    ? *spC0;
    ? sp38;
    s32 sp2C;
    s32 sp28;
    ? *temp_t0;
    ? *temp_t0_2;
    ? *temp_t0_3;
    ? *temp_t0_4;
    ? *temp_v0_4;
    ? *temp_v0_5;
    ? *temp_v0_6;
    s32 *temp_a2;
    s32 temp_a1;
    s32 temp_t6;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 var_t1;
    s32 var_v0;
    s32 var_v1;
    s32 var_v1_2;
    u32 temp_v0_7;
    void **temp_t3;
    void *temp_v1;
    void *temp_v1_2;
    void *temp_v1_3;
    void *temp_v1_4;

    temp_t0 = st_pchdr;
    temp_t6 = temp_t0->unkC;
    sp28 = temp_t6;
    if (temp_t6 >= 0x7FFFFFFF) {
        st_error("st_fdadd: number of files (%d) exceeds max (%d)\n", temp_t6, (s32 *)0x7FFFFFFF);
        sp28 = st_pchdr->unkC;
    }
    temp_v0 = temp_t0->unk10;
    if (sp28 >= temp_v0) {
        spEC = temp_v0;
        spE8 = temp_v0;
        st_pchdr->unk4 = st_malloc(temp_t0->unk4, (s32 *) (temp_t0 + 0x10), 0x40, 0x19);
        st_pchdr->unk8 = st_malloc(st_pchdr->unk8, &spEC, 0x48, 0x19);
        temp_a2 = st_pchdr->unk10;
        if (spEC != temp_a2) {
            st_internal("st_fdadd: allocation botch (%d fds and %d cfds) in %s\n", spEC, temp_a2, arg0);
        }
        var_t1 = spE8 - 1;
        if (spE8 != 0) {
            var_v1 = var_t1 * 0x48;
            var_v0 = var_t1 << 6;
            do {
                *(st_pchdr->unk4 + var_v0) = st_pchdr->unk8 + var_v1;
                var_v0 -= 0x40;
                var_v1 -= 0x48;
                var_t1 -= 1;
            } while (var_t1 != 0);
        }
    }
    temp_t0_2 = st_pchdr;
    temp_t3 = temp_t0_2->unk4 + (temp_t0_2->unkC << 6);
    pcfdcur = temp_t3;
    M2C_MEMCPY_ALIGNED(temp_t3, &B_1000A888, 0x40);
    temp_t0_3 = st_pchdr;
    *pcfdcur = (temp_t0_3->unkC * 0x48) + temp_t0_3->unk8;
    temp_t0_4 = st_pchdr;
    temp_t0_4->unkC = (s32) (temp_t0_4->unkC + 1);
    M2C_MEMCPY_ALIGNED(*pcfdcur, &B_1000A840, 0x48);
    temp_v1 = *pcfdcur;
    temp_v1->unk3C = (u8) ((arg1 * 8) | (temp_v1->unk3C & 0xFF07));
    temp_v1_2 = *pcfdcur;
    temp_v1_2->unk3C = (u8) (((arg2 * 4) & 4) | (temp_v1_2->unk3C & 0xFFFB));
    temp_v1_3 = *pcfdcur;
    temp_v1_3->unk3D = (u8) ((arg3 << 6) | (temp_v1_3->unk3D & 0xFF3F));
    temp_v1_4 = *pcfdcur;
    temp_v1_4->unk3C = (u8) (((gethostsex() == 0) & 1) | (temp_v1_4->unk3C & 0xFFFE));
    st_stradd("", &pcfdcur);
    (*pcfdcur)->unk4 = st_stradd((? *) arg0);
    if ((__sgi_common_dummy_file == 0) && ((arg3 == 0) || (arg3 >= 3))) {
        st_stradd("</4Debug/>", &pcfdcur);
        if (D_1000143C == 0) {
            D_1000143C = 1;
            if (gethostname(B_1000A8C8, 0x40) < 0) {
                strcpy(B_1000A8C8, ":");
            } else {
                strcat(B_1000A8C8, ":");
            }
            temp_v0_2 = pathconf(arg0, 5);
            var_v1_2 = temp_v0_2;
            if (temp_v0_2 < 5) {
                var_v1_2 = 5;
            }
            temp_v0_3 = (var_v1_2 * 0xC) + 0xA;
            sp2C = temp_v0_3;
            spE4 = var_v1_2 * 4;
            temp_v0_4 = malloc(temp_v0_3);
            B_1000A910 = temp_v0_4;
            if (temp_v0_4 == NULL) {
                st_internal("st_fdadd: could not malloc path name!! %d\n", sp2C);
            }
            temp_v0_5 = getcwd(0, sp2C);
            B_1000A914 = temp_v0_5;
            if (temp_v0_5 == NULL) {
                st_internal("st_fdadd: could not malloc path name! %d\n", sp2C);
            }
            temp_a1 = (spE4 * 4) + 0xA;
            sp2C = temp_a1;
            temp_v0_6 = malloc(temp_a1, (? **) temp_a1);
            B_1000A90C = temp_v0_6;
            if (temp_v0_6 == NULL) {
                st_internal("Cannot st_fdadd: cannot malloc %d bytes to hold file name\n", temp_a1);
            }
        }
        if (*arg0 != 0x2F) {
            strcpy((u8 *) B_1000A910, B_1000A914);
            strcat((u8 *) B_1000A910, "/");
            strcat((u8 *) B_1000A910, (? *) arg0);
        } else {
            strcpy((u8 *) B_1000A910, (? *) arg0);
        }
        strcpy((u8 *) B_1000A90C, (? *) B_1000A8C8);
        strcat((u8 *) B_1000A90C, B_1000A910);
        st_stradd(B_1000A90C);
        if (D_10001440 == 0) {
            D_10001440 = 1;
            temp_v0_7 = time(0);
            B_1000A938 = temp_v0_7;
            sprintf(B_1000A918, "%lu", temp_v0_7);
        }
        st_stradd(B_1000A918);
        if (stat(arg0, &sp38) < 0) {
            st_stradd("-1");
        } else {
            sprintf(&spC0, "%lu", sp68);
            st_stradd(&spC0);
        }
    }
}

void st_auxadd(u32 arg0) {
    s32 var_a0;
    void **temp_v1;
    void *temp_a1;

    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_v1 = pcfdcur;
    if (temp_v1 == NULL) {
        st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    if (temp_v1->unk3C & 0x400) {
        st_internal("routine: cannot add to this entry it was readin from disk\n");
    }
    var_a0 = temp_v1->unk0->unk30;
    if (var_a0 >= temp_v1->unk10) {
        pcfdcur->unkC = st_malloc(temp_v1->unkC, (s32 *) (temp_v1 + 0x10), 4, 0x40);
        var_a0 = pcfdcur->unk0->unk30;
    }
    temp_v1->unkC[var_a0] = arg0;
    temp_a1 = pcfdcur->unk0;
    temp_a1->unk30 = (s32) (temp_a1->unk30 + 1);
}

void st_pdadd(s32 arg0) {
    u16 var_a0;
    void **temp_v1;
    void *temp_a1;

    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_v1 = pcfdcur;
    if (temp_v1 == NULL) {
        st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    if (temp_v1->unk3C & 0x100) {
        st_internal("routine: cannot add to this entry it was readin from disk\n");
    }
    var_a0 = temp_v1->unk0->unk2A;
    if (var_a0 >= (u32) temp_v1->unk38) {
        pcfdcur->unk34 = st_malloc(temp_v1->unk34, (s32 *) (temp_v1 + 0x38), 0x34, 0x20);
        var_a0 = pcfdcur->unk0->unk2A;
    }
    M2C_MEMCPY_ALIGNED(temp_v1->unk34 + (var_a0 * 0x34), &B_1000A940, 0x34);
    (pcfdcur->unk34 + (pcfdcur->unk0->unk2A * 0x34))->unk4 = arg0;
    temp_a1 = pcfdcur->unk0;
    temp_a1->unk2A = (u16) (temp_a1->unk2A + 1);
}

void st_lineadd(? *arg0) {
    s32 var_a0;
    void **temp_v1;
    void *temp_a1;

    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_v1 = pcfdcur;
    if (temp_v1 == NULL) {
        st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    if (temp_v1->unk3C & 4) {
        st_internal("routine: cannot add to this entry it was readin from disk\n");
    }
    var_a0 = temp_v1->unk0->unk1C;
    if (var_a0 >= temp_v1->unk28) {
        pcfdcur->unk24 = st_malloc(temp_v1->unk24, (s32 *) (temp_v1 + 0x28), 4, 0x200);
        var_a0 = pcfdcur->unk0->unk1C;
    }
    temp_v1->unk24[var_a0] = arg0;
    temp_a1 = pcfdcur->unk0;
    temp_a1->unk1C = (s32) (temp_a1->unk1C + 1);
}

void st_stradd(? *arg0) {
    s32 temp_s2;
    s32 var_v1;
    void **temp_s0;
    void *temp_a0;

    if (arg0 == NULL) {
        st_error("st_stradd: argument is nil\n");
    }
    temp_s2 = strlen(arg0) + 1;
    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_s0 = pcfdcur;
    if (temp_s0 == NULL) {
        st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    if (temp_s0->unk3C & 0x80) {
        st_internal("routine: cannot add to this entry it was readin from disk\n");
    }
    var_v1 = temp_s0->unk0->unkC;
    if (temp_s0->unk18 < (var_v1 + temp_s2)) {
        do {
            pcfdcur->unk14 = st_malloc(temp_s0->unk14, (s32 *) (temp_s0 + 0x18), 1, 0x200);
            var_v1 = pcfdcur->unk0->unkC;
        } while (pcfdcur->unk18 < (var_v1 + temp_s2));
    }
    strcpy(temp_s0->unk14 + var_v1, arg0);
    temp_a0 = pcfdcur->unk0;
    temp_a0->unkC = (s32) (temp_a0->unkC + temp_s2);
}

? st_non_gp(void *arg0) {
    if (((u32) (arg0->unk8 << 6) >> 0x1B) == 0x1B) {
        return 1;
    }
    return 0;
}

void st_set_non_gp(void *arg0) {
    arg0->unk8 = (u16) ((arg0->unk8 & 0xFC1F) | 0x360);
}

u32 *st_paux_ifd_iaux(s32 *arg0, s32 arg1) {
    s32 sp24;
    void **var_v1;

    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n", arg1, arg0);
    }
    if (((s32) arg0 < 0) || (arg1 < 0) || ((s32) arg0 >= st_pchdr->unkC) || (var_v1 = st_pchdr->unk4 + ((s32) arg0 << 6), ((arg1 < (*var_v1)->unk30) == 0))) {
        sp24 = (s32) arg0 << 6;
        st_internal("st_paux_ifd_iaux: ifd (%d) or iaux (%d) out of range\n", (s32) arg0, (s32 *) arg1, (s32) arg0);
        var_v1 = st_pchdr->unk4 + sp24;
    }
    return var_v1->unkC + (arg1 * 4);
}

s32 st_pline_ifd_iline(s32 *arg0, s32 arg1) {
    s32 sp24;
    void **var_v1;

    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n", arg1, arg0);
    }
    if (((s32) arg0 < 0) || (arg1 < 0) || ((s32) arg0 >= st_pchdr->unkC) || (var_v1 = st_pchdr->unk4 + ((s32) arg0 << 6), ((arg1 < (*var_v1)->unk1C) == 0))) {
        sp24 = (s32) arg0 << 6;
        st_internal("st_paux_ifd_iaux: ifd (%d) or iline (%d) out of range\n", (s32) arg0, (s32 *) arg1, (s32) arg0);
        var_v1 = st_pchdr->unk4 + sp24;
    }
    return var_v1->unk24 + (arg1 * 4);
}

s32 st_str_iss(s32 arg0) {
    s32 temp_v0;
    void **temp_v1;

    if (st_pchdr->unk4 == 0) {
        st_internal("routine: you didn't initialize with st_cuinit or st_readst\n");
    }
    temp_v1 = pcfdcur;
    if (temp_v1 == NULL) {
        st_internal("routine: no current routine, see fdadd or setfd\n");
    }
    temp_v0 = temp_v1->unk0->unkC;
    if (temp_v0 != 0) {
        if (arg0 < temp_v0) {
            return temp_v1->unk14 + arg0;
        }
        /* Duplicate return node #8. Try simplifying control flow for better match */
        return 0;
    }
    return 0;
}

? *st_malloc(? *arg0, s32 *arg1, s32 arg2, s32 arg3) {
    ? *temp_v0_2;
    ? *temp_v0_3;
    ? *temp_v0_4;
    ? *var_s1;
    ? *var_v0;
    s32 temp_lo;
    s32 temp_t0;
    s32 temp_v0;

    temp_v0 = *arg1;
    if ((temp_v0 == 0) || (arg0 == NULL) || (temp_t0 = temp_v0 * 2, (arg0 == (? *)-1))) {
        *arg1 = arg3;
        if (arg3 == 0) {
            temp_v0_2 = malloc(1);
            var_s1 = temp_v0_2;
            if (temp_v0_2 == NULL) {
                st_error("st_malloc: cannot allocate item of 1 byte with malloc(3)\n");
            }
            goto block_12;
        }
        temp_v0_3 = malloc(*arg1 * arg2);
        var_s1 = temp_v0_3;
        if (temp_v0_3 == NULL) {
            temp_lo = *arg1 * arg2;
            var_v0 = var_s1;
            if (temp_lo != 0) {
                st_error("st_malloc: cannot allocate item of %ld bytes with malloc(3)\n", temp_lo);
                goto block_12;
            }
        } else {
            goto block_12;
        }
    } else {
        *arg1 = temp_t0;
        temp_v0_4 = realloc(arg0, temp_t0 * arg2);
        var_s1 = temp_v0_4;
        if (temp_v0_4 == NULL) {
            st_error("st_malloc: cannot grow item to %ld bytes with realloc(3)\n", *arg1 * arg2);
        }
block_12:
        var_v0 = var_s1;
    }
    return var_v0;
}

void st_setchdr(? *arg0) {
    st_pchdr = arg0;
}

? *st_currentpchdr(void) {
    return st_pchdr;
}

void st_free(void) {
    ? *temp_a0;
    ? *temp_a0_10;
    ? *temp_a0_11;
    ? *temp_a0_12;
    ? *temp_a0_2;
    ? *temp_a0_3;
    ? *temp_a0_4;
    ? *temp_a0_5;
    ? *temp_a0_6;
    ? *temp_a0_7;
    ? *temp_a0_8;
    ? *temp_a0_9;
    ? *temp_a2;

    temp_a2 = st_pchdr;
    if (temp_a2 != NULL) {
        temp_a0 = temp_a2->unk38;
        if ((temp_a0 != NULL) && (temp_a0 != (? *)-1) && (temp_a0 != (? *)1)) {
            free(temp_a0, temp_a2);
        }
        temp_a0_2 = temp_a2->unk18;
        if ((temp_a0_2 != NULL) && (temp_a0_2 != (? *)-1) && (temp_a0_2 != (? *)1)) {
            free(temp_a0_2);
        }
        temp_a0_3 = temp_a2->unk24;
        if ((temp_a0_3 != NULL) && (temp_a0_3 != (? *)-1) && (temp_a0_3 != (? *)1)) {
            free(temp_a0_3);
        }
        temp_a0_4 = temp_a2->unk8;
        if ((temp_a0_4 != NULL) && (temp_a0_4 != (? *)-1) && (temp_a0_4 != (? *)1)) {
            free(temp_a0_4);
        }
        temp_a0_5 = temp_a2->unk4;
        if ((temp_a0_5 != NULL) && (temp_a0_5 != (? *)-1) && (temp_a0_5 != (? *)1)) {
            free(temp_a0_5);
        }
        temp_a0_6 = temp_a2->unk14;
        if ((temp_a0_6 != NULL) && (temp_a0_6 != (? *)-1) && (temp_a0_6 != (? *)1)) {
            free(temp_a0_6);
        }
        temp_a0_7 = temp_a2->unk30;
        if ((temp_a0_7 != NULL) && (temp_a0_7 != (? *)-1) && (temp_a0_7 != (? *)1)) {
            free(temp_a0_7);
        }
        temp_a0_8 = temp_a2->unk44;
        if ((temp_a0_8 != NULL) && (temp_a0_8 != (? *)-1) && (temp_a0_8 != (? *)1)) {
            free(temp_a0_8);
        }
        temp_a0_9 = temp_a2->unk50;
        if ((temp_a0_9 != NULL) && (temp_a0_9 != (? *)-1) && (temp_a0_9 != (? *)1)) {
            free(temp_a0_9);
        }
        temp_a0_10 = temp_a2->unk48;
        if ((temp_a0_10 != NULL) && (temp_a0_10 != (? *)-1) && (temp_a0_10 != (? *)1)) {
            free(temp_a0_10);
        }
        temp_a0_11 = temp_a2->unk34;
        if ((temp_a0_11 != NULL) && (temp_a0_11 != (? *)-1) && (temp_a0_11 != (? *)1)) {
            free(temp_a0_11);
        }
        temp_a0_12 = temp_a2->unk4C;
        if ((temp_a0_12 != NULL) && (temp_a0_12 != (? *)-1) && (temp_a0_12 != (? *)1)) {
            free(temp_a0_12);
        }
        bzero(temp_a2, 0x60, temp_a2);
    }
}

void st_extstradd(? *arg0) {
    ? *temp_s0;
    s32 temp_s2;
    s32 temp_v0;
    s32 var_v1;

    if (st_pchdr == NULL) {
        st_internal("st_extstradd: you didn't initialize with cuinit or readst\n");
    }
    if (arg0 == NULL) {
        st_error("st_extstradd: argument is nil\n");
    }
    temp_v0 = strlen(arg0);
    temp_s0 = st_pchdr;
    var_v1 = temp_s0->unk28;
    temp_s2 = temp_v0 + 1;
    if ((var_v1 + temp_v0) >= temp_s0->unk2C) {
        do {
            st_pchdr->unk24 = st_malloc(temp_s0->unk24, (s32 *) (temp_s0 + 0x2C), 1, 0x200);
            var_v1 = st_pchdr->unk28;
        } while (st_pchdr->unk2C < (var_v1 + temp_s2));
    }
    strcpy(temp_s0->unk24 + var_v1, arg0);
    st_pchdr->unk28 = (s32) (st_pchdr->unk28 + temp_s2);
}

? *st_str_extiss(s32 arg0) {
    if ((arg0 >= 0) && (arg0 < st_pchdr->unk28)) {
        return st_pchdr->unk24 + arg0;
    }
    return NULL;
}

void st_idn_dn(s32 arg0, s32 arg1) {
    s32 sp24;
    ? *temp_v1;
    s32 temp_v0;
    s32 var_t0;

    temp_v1 = st_pchdr;
    if (temp_v1 == NULL) {
        st_internal("st_idn_dn: you didn't initialize with cuinit or readst\n");
    }
    temp_v0 = temp_v1->unk40;
    var_t0 = temp_v0;
    if (temp_v1->unk3C >= temp_v0) {
        sp24 = temp_v0;
        var_t0 = sp24;
        st_pchdr->unk38 = st_malloc(temp_v1->unk38, (s32 *) (temp_v1 + 0x40), 8, 0x80);
    }
    if (var_t0 == 0) {
        bzero(temp_v1->unk38, 0x10);
    }
    *(temp_v1->unk38 + (temp_v1->unk3C * 8)) = arg0;
    (st_pchdr->unk38 + (st_pchdr->unk3C * 8))->unk4 = arg1;
    st_pchdr->unk3C = (s32) (st_pchdr->unk3C + 1);
}

void st_idn_rndx(u32 arg0) {
    s32 sp24;
    ? *temp_v1;
    s32 temp_v0;
    s32 var_t0;

    temp_v1 = st_pchdr;
    if (temp_v1 == NULL) {
        st_internal("st_idn_rndx: you didn't initialize with cuinit or readst\n");
    }
    temp_v0 = temp_v1->unk40;
    var_t0 = temp_v0;
    if (temp_v1->unk3C >= temp_v0) {
        sp24 = temp_v0;
        var_t0 = sp24;
        st_pchdr->unk38 = st_malloc(temp_v1->unk38, (s32 *) (temp_v1 + 0x40), 8, 0x80);
    }
    if (var_t0 == 0) {
        bzero(temp_v1->unk38, 0x10);
    }
    *(temp_v1->unk38 + (temp_v1->unk3C * 8)) = arg0 >> 0x14;
    (st_pchdr->unk38 + (st_pchdr->unk3C * 8))->unk4 = (s32) (arg0 & 0xFFFFF);
    st_pchdr->unk3C = (s32) (st_pchdr->unk3C + 1);
}

s32 *st_rndx_idn(s32 *arg0, s32 arg1) {
    u16 sp2C;                                       /* compiler-managed */
    s32 sp24;
    ? *temp_v1;
    s32 temp_a2;
    s32 temp_a2_2;
    u32 var_a1;

    temp_v1 = st_pchdr;
    temp_a2 = temp_v1->unk3C;
    if (arg1 >= temp_a2) {
        st_internal("st_rndx_idn: idn (%d) greater than max (%d)\n", temp_a2, (s32 *) arg1);
    }
    temp_a2_2 = arg1 * 8;
    var_a1 = *(temp_v1->unk38 + temp_a2_2);
    if (var_a1 >= 0xFFFU) {
        sp24 = temp_a2_2;
        st_internal("st_rndx_idn: old interface can't put rfd(%d) into rndx, use st_pdn_idn instead\n", (s32) var_a1, (s32 *) temp_a2_2, arg1);
        var_a1 = *(st_pchdr->unk38 + temp_a2_2);
    }
    sp2C = (var_a1 * 0x10) | (sp2C & 0xF);
    sp2C = ((u32) ((((temp_v1->unk38 + temp_a2_2)->unk4 & 0xFFFFF) ^ (s32) sp2C) << 0xC) >> 0xC) ^ (s32) sp2C;
    *arg0 = sp2C;
    return arg0;
}

void st_setidn(s32 arg0, s32 arg1) {
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_t7;
    void *temp_t9;

    if ((arg0 < 0) || (arg1 < 0) || (temp_v0 = st_pchdr->unk3C, ((arg0 < temp_v0) == 0)) || (arg1 >= temp_v0)) {
        st_internal("st_setidn: idnsrc (%d) or idndest (%d) out of range\n", arg0);
    }
    temp_v0_2 = st_pchdr->unk38;
    temp_t9 = temp_v0_2 + (arg1 * 8);
    temp_t7 = temp_v0_2 + (arg0 * 8);
    temp_t7->unk0 = (s32) temp_t9->unk0;
    temp_t7->unk4 = (s32) temp_t9->unk4;
}

s32 st_pext_dn(s32 arg0, s32 arg1) {
    if (arg0 != 0x7FFFFFFF) {
        st_internal("st_pext_dn: rfd field (%d) isn't equal to ST_EXTIFD(%d)\n", arg0, (s32 *)0x7FFFFFFF);
    }
    if ((arg1 < 0) || (st_pchdr->unk1C < arg1)) {
        st_internal("st_pext_dn: index out of range (%d)\n\0\0\0\0libmld", arg1);
    }
    return st_pchdr->unk18 + (arg1 * 0x10);
}

s32 st_iextmax(void) {
    return st_pchdr->unk1C;
}

void st_setmsgname(? *arg0) {
    ? *temp_v0;
    ? *var_a0;

    temp_v0 = malloc(strlen() + 1);
    var_a0 = temp_v0;
    st_errname = (s32) temp_v0;
    if (temp_v0 == NULL) {
        fprintf(&__iob + 0x20, "libmld: Internal: cannot allocate to initialize component name for libmld errors\n");
        exit(1);
        var_a0 = (? *) st_errname;
    }
    strcpy((u8 *) var_a0, arg0);
}

s32 st_readbinary(s8 arg1) {
    s32 sp2C;
    s32 sp28;
    s32 temp_v0;
    s32 temp_v0_2;

    temp_v0_2 = open(0, 0);
    if (temp_v0_2 < 0) {
        return -2;
    }
    sp2C = temp_v0_2;
    temp_v0 = st_readst(temp_v0_2, arg1, 0, NULL, -1);
    sp28 = temp_v0;
    close(temp_v0_2);
    return temp_v0;
}

s32 st_readst(s32 arg0, s8 arg1, s32 arg2, ? *arg3, s32 arg4) {
    s16 spC0;
    s32 spA0;
    ? *sp9C;
    s32 sp68;
    s32 sp64;
    s32 sp60;
    s32 sp5C;
    s32 sp58;
    s32 sp54;
    s32 sp50;
    s32 sp4C;
    s32 sp48;
    s32 sp44;
    s32 sp40;
    ? *temp_a0;
    ? *temp_a0_10;
    ? *temp_a0_11;
    ? *temp_a0_2;
    ? *temp_a0_3;
    ? *temp_a0_4;
    ? *temp_a0_5;
    ? *temp_a0_6;
    ? *temp_a0_7;
    ? *temp_a0_8;
    ? *temp_a0_9;
    ? *temp_v0_12;
    ? *temp_v0_14;
    ? *temp_v0_15;
    ? *temp_v0_16;
    ? *temp_v0_17;
    ? *temp_v0_20;
    ? *var_s0;
    s16 temp_t8_6;
    s16 var_s2_2;
    s16 var_s2_3;
    s32 temp_a3;
    s32 temp_a3_2;
    s32 temp_t4;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_t8_3;
    s32 temp_t8_4;
    s32 temp_t8_5;
    s32 temp_t9;
    s32 temp_t9_2;
    s32 temp_t9_3;
    s32 temp_t9_4;
    s32 temp_t9_5;
    s32 temp_t9_6;
    s32 temp_t9_7;
    s32 temp_t9_8;
    s32 temp_v0;
    s32 temp_v0_10;
    s32 temp_v0_11;
    s32 temp_v0_13;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s32 temp_v0_9;
    s32 temp_v1_10;
    s32 var_a0_2;
    s32 var_a1_2;
    s32 var_a2_2;
    s32 var_at;
    s32 var_at_2;
    s32 var_s0_2;
    s32 var_s0_3;
    s32 var_s1;
    s32 var_s2;
    s32 var_t1;
    s32 var_v0;
    s32 var_v1;
    s8 *var_t0;
    s8 temp_v1_11;
    u16 temp_a2;
    u16 var_a2;
    u32 var_a1;
    u32 var_ra;
    void **temp_v0_18;
    void **temp_v0_19;
    void *temp_t2;
    void *temp_t9_9;
    void *temp_v1;
    void *temp_v1_2;
    void *temp_v1_3;
    void *temp_v1_4;
    void *temp_v1_5;
    void *temp_v1_6;
    void *temp_v1_7;
    void *temp_v1_8;
    void *temp_v1_9;
    void *var_a0;

    sp9C = NULL;
    if (arg1 == 0x72) {
        var_v0 = 0;
    } else {
        var_v0 = 1;
    }
    if (var_v0 != 0) {
        arg4 = -1;
    }
    if (arg3 == NULL) {
        st_pchdr = calloc(0xBC, 1);
    } else {
        st_pchdr = arg3;
    }
    temp_v0_12 = st_pchdr;
    temp_t8 = ~temp_v0_12->unk54 & arg4;
    arg4 = temp_t8;
    if ((arg3 == NULL) || (temp_t8 & 8)) {
        temp_v0_13 = lseek(arg0, 0, 1);
        arg4 |= 0x208;
        if (read(arg0, &spC0, 0x60) != 0x60) {
            return -3;
        }
        if ((spC0 != 0x7009) && (spC0 != 0x7109)) {
            if ((spC0 == 0x970) || (spC0 == 0x971)) {
                swap_hdr(&spC0, gethostsex());
                st_pchdr->unk58 = 1;
            } else {
                st_error("bad magic in hdr. expected 0x%x, got 0x%x\n", 0x7009, (s32 *) spC0);
            }
        }
        if ((spC2 < 0x11E) && (spD0 != 0)) {
            st_internal("st_readst: dense number incompatible from versions less than 1.30, please recompile from scratch and use compatible components\n");
        }
        var_s2 = 0;
        if (arg4 == -1) {
            var_s2 = ldfsymorder(&spC0, temp_v0_13 - arg2);
        }
        M2C_MEMCPY_ALIGNED(st_pchdr + 0x5C, &spC0, 0x60);
        goto block_26;
    }
    var_s2 = 0;
    M2C_MEMCPY_ALIGNED(&spC0, temp_v0_12 + 0x5C, 0x60);
block_26:
    temp_t8_2 = arg4 & 2;
    sp68 = temp_t8_2;
    if (temp_t8_2 != 0) {
        temp_a0 = st_pchdr->unk14;
        if (temp_a0 == NULL) {
            st_pchdr->unk14 = st_malloc(temp_a0, &spA0, 0xC, spE0);
        }
    }
    temp_t8_3 = arg4 & 0x400;
    sp64 = temp_t8_3;
    if (temp_t8_3 != 0) {
        temp_a0_2 = st_pchdr->unk30;
        if (temp_a0_2 == NULL) {
            st_pchdr->unk30 = st_malloc(temp_a0_2, &spA0, 4, spF0);
        }
    }
    temp_t8_4 = arg4 & 0x80;
    sp60 = temp_t8_4;
    if (temp_t8_4 != 0) {
        temp_a0_3 = st_pchdr->unk34;
        if (temp_a0_3 == NULL) {
            st_pchdr->unk34 = st_malloc(temp_a0_3, &spA0, 1, spF8);
        }
    }
    temp_t8_5 = arg4 & 4;
    sp5C = temp_t8_5;
    if (temp_t8_5 != 0) {
        sp9C = st_malloc(NULL, &spA0, 1, spC8);
    }
    if (sp5C != 0) {
        temp_a0_4 = st_pchdr->unk48;
        if (temp_a0_4 == NULL) {
            st_pchdr->unk48 = st_malloc(temp_a0_4, &spA0, 4, spC4);
        }
    }
    temp_t9 = arg4 & 0x20;
    sp58 = temp_t9;
    if (temp_t9 != 0) {
        temp_a0_5 = st_pchdr->unk44;
        if (temp_a0_5 == NULL) {
            st_pchdr->unk44 = st_malloc(temp_a0_5, &spA0, 0xC, spE8);
        }
    }
    temp_t9_2 = arg4 & 0x40;
    sp54 = temp_t9_2;
    if (temp_t9_2 != 0) {
        temp_a0_6 = st_pchdr->unk4C;
        if (temp_a0_6 == NULL) {
            st_pchdr->unk4C = st_malloc(temp_a0_6, &spA0, 4, sp110);
        }
    }
    temp_t9_3 = arg4 & 0x100;
    sp50 = temp_t9_3;
    if (temp_t9_3 != 0) {
        temp_a0_7 = st_pchdr->unk50;
        if (temp_a0_7 == NULL) {
            st_pchdr->unk50 = st_malloc(temp_a0_7, &spA0, 0x34, spD8);
        }
    }
    temp_t9_4 = arg4 & 1;
    sp4C = temp_t9_4;
    if (temp_t9_4 != 0) {
        temp_a0_8 = st_pchdr->unk18;
        if (temp_a0_8 == NULL) {
            st_pchdr->unk18 = st_malloc(temp_a0_8, &spA0, 0x10, sp118 + 1);
        }
    }
    temp_t9_5 = arg4 & 0x800;
    sp48 = temp_t9_5;
    if (temp_t9_5 != 0) {
        temp_a0_9 = st_pchdr->unk24;
        if (temp_a0_9 == NULL) {
            st_pchdr->unk24 = st_malloc(temp_a0_9, &spA0, 1, sp100 + 8);
        }
    }
    temp_t9_6 = arg4 & 0x10;
    sp44 = temp_t9_6;
    if (temp_t9_6 != 0) {
        temp_a0_10 = st_pchdr->unk38;
        if (temp_a0_10 == NULL) {
            st_pchdr->unk38 = st_malloc(temp_a0_10, &spA0, 8, spD0);
        }
    }
    temp_t9_7 = arg4 & 0x200;
    sp40 = temp_t9_7;
    if (temp_t9_7 != 0) {
        temp_a0_11 = st_pchdr->unk8;
        if (temp_a0_11 == NULL) {
            st_pchdr->unk8 = st_malloc(temp_a0_11, &spA0, 0x48, sp108);
        }
    }
    temp_t9_8 = sp40 != 0;
    if (temp_t9_8 != 0) {
        var_s0 = st_pchdr->unk4;
        if (var_s0 == NULL) {
            if (temp_t9_8 != 0) {
                if (var_s0 == NULL) {
                    st_pchdr->unk4 = st_malloc(var_s0, &spA0, 0x40, sp108);
                    var_s0 = st_pchdr->unk4;
                }
            }
            bzero(var_s0, sp108 << 6);
        }
    }
    if (sp4C != 0) {
        st_pchdr->unk20 = sp118;
        temp_v0_14 = st_pchdr;
        temp_v0_14->unk1C = (s32) temp_v0_14->unk20;
    }
    if (sp48 != 0) {
        st_pchdr->unk2C = sp100;
        temp_v0_15 = st_pchdr;
        temp_v0_15->unk28 = (s32) temp_v0_15->unk2C;
    }
    if (sp44 != 0) {
        st_pchdr->unk40 = spD0;
        temp_v0_16 = st_pchdr;
        temp_v0_16->unk3C = (s32) temp_v0_16->unk40;
    }
    if (sp40 != 0) {
        st_pchdr->unk10 = sp108;
        temp_v0_17 = st_pchdr;
        temp_v0_17->unkC = (s32) temp_v0_17->unk10;
    }
    if (sp5C != 0) {
        temp_v0_11 = func_00419E30(arg0, var_s2, spCC + arg2, sp9C, spC8);
        if (temp_v0_11 != 0) {
            return temp_v0_11;
        }
        goto block_90;
    }
block_90:
    if (sp50 != 0) {
        temp_v0_10 = func_00419E30(arg0, var_s2, spDC + arg2, st_pchdr->unk50, spD8 * 0x34);
        if (temp_v0_10 != 0) {
            return temp_v0_10;
        }
        goto block_94;
    }
block_94:
    if (sp68 != 0) {
        temp_v0_9 = func_00419E30(arg0, var_s2, spE4 + arg2, st_pchdr->unk14, spE0 * 0xC);
        if (temp_v0_9 != 0) {
            return temp_v0_9;
        }
    }
    if (sp58 != 0) {
        temp_v0_8 = func_00419E30(arg0, var_s2, spEC + arg2, st_pchdr->unk44, spE8 * 0xC);
        if (temp_v0_8 != 0) {
            return temp_v0_8;
        }
        goto block_101;
    }
block_101:
    if (sp64 != 0) {
        temp_v0_7 = func_00419E30(arg0, var_s2, spF4 + arg2, st_pchdr->unk30, spF0 * 4);
        if (temp_v0_7 != 0) {
            return temp_v0_7;
        }
    }
    if (sp60 != 0) {
        temp_v0_6 = func_00419E30(arg0, var_s2, spFC + arg2, st_pchdr->unk34, spF8);
        if (temp_v0_6 != 0) {
            return temp_v0_6;
        }
        goto block_108;
    }
block_108:
    if (sp48 != 0) {
        temp_v0_5 = func_00419E30(arg0, var_s2, sp104 + arg2, st_pchdr->unk24, sp100);
        if (temp_v0_5 != 0) {
            return temp_v0_5;
        }
        goto block_112;
    }
block_112:
    if (sp40 != 0) {
        temp_v0_4 = func_00419E30(arg0, var_s2, sp10C + arg2, st_pchdr->unk8, sp108 * 0x48);
        if (temp_v0_4 != 0) {
            return temp_v0_4;
        }
    }
    if (sp54 != 0) {
        temp_v0_3 = func_00419E30(arg0, var_s2, sp114 + arg2, st_pchdr->unk4C, sp110 * 4);
        if (temp_v0_3 != 0) {
            return temp_v0_3;
        }
        goto block_119;
    }
block_119:
    if (sp4C != 0) {
        temp_v0_2 = func_00419E30(arg0, var_s2, sp11C + arg2, st_pchdr->unk18, sp118 * 0x10);
        if (temp_v0_2 != 0) {
            return temp_v0_2;
        }
    }
    if (sp44 != 0) {
        temp_v0 = func_00419E30(arg0, var_s2, spD4 + arg2, st_pchdr->unk38, spD0 * 8);
        if (temp_v0 != 0) {
            return temp_v0;
        }
    }
    if (st_pchdr->unk58 != 0) {
        if (sp50 != 0) {
            swap_pd(st_pchdr->unk50, spD8, gethostsex());
        }
        if (sp68 != 0) {
            swap_sym(st_pchdr->unk14, spE0, gethostsex());
        }
        if (sp58 != 0) {
            swap_opt(st_pchdr->unk44, spE8, gethostsex());
        }
        if (sp40 != 0) {
            swap_fd(st_pchdr->unk8, sp108, gethostsex());
        }
        if (sp54 != 0) {
            swap_fi(st_pchdr->unk4C, sp110, gethostsex());
        }
        if (sp4C != 0) {
            swap_ext(st_pchdr->unk18, sp118, gethostsex());
        }
        if (sp44 != 0) {
            swap_dn(st_pchdr->unk38, spD0, gethostsex());
        }
    }
    var_s0_2 = 0;
    var_s2_2 = 0;
    if (sp108 > 0) {
        var_s1 = 0;
        do {
            temp_v0_18 = st_pcfd_ifd(var_s2_2);
            temp_t9_9 = st_pchdr->unk8 + var_s1;
            temp_v0_18->unk0 = temp_t9_9;
            if ((sp68 != 0) && (temp_t9_9->unk14 > 0)) {
                temp_v0_18->unk4 = (void *) (st_pchdr->unk14 + (temp_t9_9->unk10 * 0xC));
                temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 2);
            }
            if (sp64 != 0) {
                temp_v1 = temp_v0_18->unk0;
                if (temp_v1->unk30 > 0) {
                    temp_v0_18->unkC = &st_pchdr->unk30[temp_v1->unk2C];
                    temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 0x400);
                }
            }
            if (sp58 != 0) {
                temp_v1_2 = temp_v0_18->unk0;
                if (temp_v1_2->unk24 > 0) {
                    temp_v0_18->unk1C = (void *) (st_pchdr->unk44 + (temp_v1_2->unk20 * 0xC));
                    temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 0x20);
                }
            }
            if (sp54 != 0) {
                temp_v1_3 = temp_v0_18->unk0;
                if (temp_v1_3->unk38 > 0) {
                    temp_v0_18->unk2C = &st_pchdr->unk4C[temp_v1_3->unk34];
                    temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 0x40);
                }
            }
            if (sp60 != 0) {
                temp_v1_4 = temp_v0_18->unk0;
                if (temp_v1_4->unkC > 0) {
                    temp_v0_18->unk14 = (void *) (st_pchdr->unk34 + temp_v1_4->unk8);
                    temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 0x80);
                }
            }
            if (sp50 != 0) {
                temp_v1_5 = temp_v0_18->unk0;
                if (temp_v1_5->unk2A != 0) {
                    temp_v0_18->unk34 = (void *) (st_pchdr->unk50 + (var_s0_2 * 0x34));
                    temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 0x100);
                    var_s0_2 += temp_v1_5->unk2A;
                }
            }
            if (sp5C != 0) {
                temp_v1_6 = temp_v0_18->unk0;
                if (temp_v1_6->unk1C > 0) {
                    temp_v0_18->unk24 = &st_pchdr->unk48[temp_v1_6->unk18];
                    temp_v0_18->unk3C = (s32) (temp_v0_18->unk3C | 4);
                }
            }
            var_s2_2 += 1;
            var_s1 += 0x48;
        } while (var_s2_2 < sp108);
    }
    var_s2_3 = sp108 - 1;
    if ((sp5C != 0) && (var_s2_3 >= 0)) {
        do {
            temp_v0_19 = st_pcfd_ifd(var_s2_3);
            temp_v1_7 = temp_v0_19->unk0;
            if (temp_v1_7->unk1C != 0) {
                var_ra = 0;
                var_t0 = temp_v1_7->unk40 + sp9C;
                if (temp_v1_7->unk2A != 0) {
                    var_s0_3 = 0;
                    do {
                        temp_t2 = temp_v0_19->unk34;
                        var_ra += 1;
                        temp_v1_8 = temp_t2 + var_s0_3;
                        temp_a3 = temp_v1_8->unk8;
                        if ((temp_a3 == -1) || (temp_t4 = temp_v1_8->unk28, (temp_t4 == -1)) || (temp_v1_8->unk2C == -1)) {
                            var_a2 = temp_v0_19->unk0->unk2A;
                        } else {
                            temp_v1_9 = temp_v0_19->unk0;
                            var_a1 = 0;
                            var_t1 = temp_v1_9->unk1C;
                            var_at = temp_a3 < var_t1;
                            if (temp_v1_9->unk2A != 0) {
                                var_a0 = temp_t2;
                                temp_a2 = temp_v0_19->unk0->unk2A;
                                do {
                                    temp_v1_10 = var_a0->unk8;
                                    var_a1 += 1;
                                    var_at_2 = var_a1 < temp_a2;
                                    if (temp_a3 < temp_v1_10) {
                                        var_at_2 = var_a1 < temp_a2;
                                        if (var_a0->unk28 != -1) {
                                            if (var_a0->unk2C != -1) {
                                                var_at_2 = var_a1 < temp_a2;
                                                if (temp_v1_10 < var_t1) {
                                                    var_t1 = temp_v1_10;
                                                    goto block_182;
                                                }
                                            } else {
block_182:
                                                var_at_2 = var_a1 < temp_a2;
                                            }
                                        }
                                    }
                                    var_a0 += 0x34;
                                } while (var_at_2 != 0);
                                var_at = temp_a3 < var_t1;
                            }
                            var_a2_2 = temp_t4;
                            var_a1_2 = temp_a3;
                            if (var_at != 0) {
                                do {
                                    temp_v1_11 = *var_t0;
                                    var_t0 += 1;
                                    temp_a3_2 = temp_v1_11 >> 4;
                                    var_a0_2 = temp_v1_11 & 0xF;
                                    if ((s8) temp_a3_2 == -8) {
                                        temp_t8_6 = (var_t0->unk1 & 0xFF) | (var_t0->unk0 << 8);
                                        var_t0 += 2;
                                        var_a2_2 += temp_t8_6;
                                    } else {
                                        var_a2_2 += (s8) temp_a3_2;
                                    }
                                    var_v1 = var_a1_2 * 4;
                                    if (var_a0_2 >= 0) {
                                        do {
                                            var_a0_2 -= 1;
                                            *(temp_v0_19->unk24 + var_v1) = var_a2_2;
                                            var_v1 += 4;
                                            var_a1_2 += 1;
                                        } while (var_a0_2 >= 0);
                                    }
                                } while (var_a1_2 < var_t1);
                            }
                            var_a2 = temp_v0_19->unk0->unk2A;
                        }
                        var_s0_3 += 0x34;
                    } while (var_ra < var_a2);
                }
            }
            var_s2_3 -= 1;
        } while (var_s2_3 >= 0);
    }
    temp_v0_20 = st_pchdr;
    temp_v0_20->unk54 = (s32) (temp_v0_20->unk54 | arg4);
    if (sp9C != NULL) {
        free(sp9C);
    }
    return 0;
}

s32 func_00419E30(s32 arg0, s32 arg1, s32 arg2, s16 *arg3, s32 arg4) {
    if (arg4 == 0) {
        /* Duplicate return node #8. Try simplifying control flow for better match */
        return 0;
    }
    if ((arg1 == 0) && (lseek(arg0, arg2, 0) != arg2)) {
        st_warning("st_read: error seeking\n");
        return -5;
    }
    if (read(arg0, arg3, arg4) != arg4) {
        st_warning("st_read: error reading\n");
        return -6;
    }
    return 0;
}

void st_writebinary(s32 arg0, s32 arg1) {
    s32 sp24;
    s32 temp_v0;

    temp_v0 = open(0x102, 0x1B6);
    sp24 = temp_v0;
    if (temp_v0 < 0) {
        st_error("cannot open symbol table file %s\n", arg0);
    }
    st_writest(sp24, arg1);
    close(sp24);
}

void st_writest(s32 arg0, s32 arg1) {
    void **sp1D4;
    s32 sp1C4;
    s32 sp1C0;
    s32 sp1BC;
    s32 sp1B8;
    u16 sp1B6;
    u16 sp1B4;
    s32 sp1B0;
    s32 sp1AC;
    s32 sp1A0;
    s32 sp19C;
    s32 sp198;
    s32 sp194;
    ? *sp18C;
    void *sp188;
    s32 sp184;
    s32 sp180;
    s32 sp17C;
    s32 sp178;
    s32 sp174;
    s32 sp170;
    s32 sp16C;
    s32 sp168;
    s32 sp164;
    s32 sp160;
    s32 sp15C;
    s32 sp158;
    s32 sp154;
    s32 sp150;
    s32 sp14C;
    s32 sp148;
    s32 sp144;
    s32 sp140;
    s32 sp13C;
    s32 sp138;
    s32 sp134;
    s32 sp130;
    s32 sp12C;
    ? *sp128;
    s32 sp124;
    s32 sp120;
    s32 sp11C;
    s32 sp118;
    s32 sp114;
    s32 sp110;
    ? *sp10C;
    u32 sp108;
    void *spFC;
    ? spE8;
    ? *sp68;
    s32 sp58;
    ? **var_s0;
    ? *temp_s1_3;
    ? *temp_s2;
    ? *temp_v0;
    ? *temp_v0_14;
    ? *temp_v0_15;
    ? *temp_v0_16;
    s16 var_v1_3;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a0_4;
    s32 temp_a0_5;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a2_5;
    s32 temp_a2_6;
    s32 temp_s1;
    s32 temp_s7;
    s32 temp_t4_2;
    s32 temp_t4_3;
    s32 temp_t5_3;
    s32 temp_t5_5;
    s32 temp_t5_6;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t7_3;
    s32 temp_t7_4;
    s32 temp_t8_2;
    s32 temp_t8_4;
    s32 temp_t9_3;
    s32 temp_t9_4;
    s32 temp_t9_6;
    s32 temp_t9_7;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 var_a0_2;
    s32 var_a1;
    s32 var_at;
    s32 var_s0_2;
    s32 var_s5;
    s32 var_t2;
    s32 var_t3;
    s8 var_s2;
    s8 var_s4;
    u16 temp_s1_2;
    u16 temp_t5_2;
    u16 temp_t5_4;
    u16 temp_t9_5;
    u16 temp_v0_8;
    u16 var_s1;
    u32 temp_t9;
    u32 var_a0;
    u32 var_s3;
    u32 var_v1_2;
    void **temp_v0_10;
    void **temp_v0_11;
    void **temp_v0_12;
    void **temp_v0_13;
    void **temp_v0_3;
    void **temp_v0_7;
    void **temp_v0_9;
    void **var_t1;
    void *temp_t4;
    void *temp_t5;
    void *temp_t7;
    void *temp_t7_2;
    void *temp_t8;
    void *temp_t8_3;
    void *temp_t9_2;
    void *var_t0;
    void *var_v0;
    void *var_v1;

    sp120 = 0;
    bzero(&sp18C, 0x48);
    bzero(&sp128, 0x60);
    sp114 = st_ifdmax();
    sp110 = lseek(arg0, 0, 1);
    sp11C = lseek(arg0, 0x60, 1);
    st_pchdr->unkC = sp114;
    temp_v0 = fdopen(dup(arg0), "w");
    var_t3 = sp120;
    sp10C = temp_v0;
    if (temp_v0 == NULL) {
        st_error("st_writest: cannot write to file number %d\n", arg0);
    }
    if (arg1 & 4) {
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp124 = 0;
                sp120 = var_t3;
                temp_v0_3 = st_pcfd_ifd((s16) sp118);
                temp_t5 = temp_v0_3->unk0;
                sp188 = temp_t5;
                temp_v1 = temp_t5->unk1C;
                var_t2 = sp124;
                var_t1 = temp_v0_3;
                if ((temp_v1 != 0) && (temp_v0_3->unk24 != 0)) {
                    temp_t5->unk18 = sp12C;
                    sp12C += temp_v1;
                    temp_t5->unk40 = var_t3;
                    sp108 = 0;
                    var_s1 = temp_t5->unk2A;
                    if (var_s1 != 0) {
                        sp58 = 0;
                        do {
                            var_t0 = var_t1->unk34 + sp58;
                            if ((var_t0->unk8 != (s32) -1) && (var_t0->unk28 != (s32) -1) && (var_t0->unk2C != (s32) -1)) {
                                var_a0 = 0;
                                var_t0->unk30 = (s32) (var_t3 - sp188->unk40);
                                var_s1 = sp188->unk2A;
                                var_a1 = sp188->unk1C;
                                if (var_s1 != 0) {
                                    var_v1 = var_t1->unk34;
                                    do {
                                        temp_v0_4 = var_v1->unk8;
                                        var_a0 += 1;
                                        var_at = var_a0 < var_s1;
                                        if (var_t0->unk8 < temp_v0_4) {
                                            var_at = var_a0 < var_s1;
                                            if (var_v1->unk28 != (s32) -1) {
                                                if (var_v1->unk2C != (s32) -1) {
                                                    var_at = var_a0 < var_s1;
                                                    if (temp_v0_4 < var_a1) {
                                                        var_a1 = temp_v0_4;
                                                        goto block_19;
                                                    }
                                                } else {
block_19:
                                                    var_at = var_a0 < var_s1;
                                                }
                                            }
                                        }
                                        var_v1 += 0x34;
                                    } while (var_at != 0);
                                }
                                if (var_a1 > 0) {
                                    temp_a2 = var_t0->unk8;
                                    var_s2 = -1;
                                    if (temp_a2 >= 0) {
                                        temp_v0_5 = var_t1->unk24;
                                        temp_s7 = var_a1 * 4;
                                        var_s3 = temp_v0_5 + (temp_a2 * 4);
                                        var_v1_2 = temp_v0_5 + temp_s7;
                                        var_s5 = var_t0->unk28;
                                        var_s4 = 0;
                                        var_s0 = &sp68;
                                        if (var_v1_2 >= var_s3) {
                                            do {
                                                if (var_s3 == var_v1_2) {
                                                    var_v1_3 = 1;
                                                } else {
                                                    temp_v0_6 = *var_s3;
                                                    var_a0_2 = temp_v0_6;
                                                    if (temp_v0_6 == 0) {
                                                        var_a0_2 = var_t0->unk28;
                                                    }
                                                    var_v1_3 = var_a0_2 - var_s5;
                                                }
                                                if ((var_v1_3 != 0) || (var_v0 = var_s0 + 3, (var_s2 == 8))) {
                                                    var_s5 += var_v1_3;
                                                    if ((var_s2 != -1) && (var_s4 >= -7) && (var_s4 < 8)) {
                                                        var_s0->unk0 = (s8) ((var_s4 * 0x10) | var_s2);
                                                        var_s0 += 1;
                                                    } else if (var_s2 != -1) {
                                                        var_s0->unk0 = var_s2;
                                                        var_s0->unk1 = (s8) (var_s4 >> 8);
                                                        var_s0->unk0 = (s8) (var_s0->unk0 | 0x80);
                                                        var_s0->unk2 = var_s4;
                                                        var_s0 += 3;
                                                    }
                                                    var_s2 = 0;
                                                    var_s4 = (s8) var_v1_3;
                                                    var_v0 = var_s0 + 3;
                                                } else {
                                                    var_s2 += 1;
                                                }
                                                temp_s1 = var_s0 - &sp68;
                                                if (((u32) var_v0 >= (u32) &spE8) || ((var_v1_2 = var_t1->unk24 + temp_s7, (var_s3 == var_v1_2)) && ((var_s0 - &sp68) > 0))) {
                                                    spFC = var_t0;
                                                    sp1D4 = var_t1;
                                                    sp124 = var_t2;
                                                    sp120 = var_t3;
                                                    fwrite(&sp68, temp_s1, 1U, sp10C);
                                                    var_t1 = sp1D4;
                                                    var_t0 = spFC;
                                                    var_s0 = &sp68;
                                                    var_t2 = sp124 + temp_s1;
                                                    var_t3 = sp120 + temp_s1;
                                                    var_v1_2 = var_t1->unk24 + temp_s7;
                                                }
                                                var_s3 += 4;
                                            } while (var_v1_2 >= var_s3);
                                            var_s1 = sp188->unk2A;
                                        }
                                    }
                                }
                            }
                            temp_t9 = sp108 + 1;
                            sp58 += 0x34;
                            sp108 = temp_t9;
                        } while (temp_t9 < var_s1);
                    }
                    sp188->unk44 = var_t2;
                }
                temp_v0_2 = sp118 + 1;
                sp118 = temp_v0_2;
            } while (temp_v0_2 != sp114);
        }
        temp_t5_2 = -var_t3 & 3;
        if (sp12C != 0) {
            if (temp_t5_2 != 0) {
                sp120 = var_t3;
                if (fwrite(B_1000A980, 1, temp_t5_2, sp10C) != temp_t5_2) {
                    sp120 = var_t3;
                    st_error("cannot write round bytes for lines\n");
                }
                var_t3 = (var_t3 + 3) & ~3;
            }
            sp130 = var_t3;
            sp134 = sp11C;
        }
    }
    if (arg1 & 0x100) {
        sp11C += var_t3;
        var_t3 = 0;
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp120 = var_t3;
                temp_v0_7 = st_pcfd_ifd((s16) sp118);
                temp_t7 = temp_v0_7->unk0;
                sp188 = temp_t7;
                temp_s1_2 = temp_t7->unk2A;
                temp_t7->unk28 = (s16) (sp1B4 + sp1B6);
                var_t3 += temp_s1_2 * 0x34;
                if (temp_s1_2 != 0) {
                    sp120 = var_t3;
                    if (fwrite(temp_v0_7->unk34, 0x34, temp_s1_2, sp10C) != sp188->unk2A) {
                        sp120 = var_t3;
                        st_error("cannot write pfield");
                    }
                }
                sp1B4 += sp1B6;
                temp_v0_8 = sp188->unk2A;
                temp_v1_2 = sp118 + 1;
                sp140 += temp_v0_8;
                sp118 = temp_v1_2;
                sp1B6 = temp_v0_8;
            } while (temp_v1_2 != sp114);
        }
        if (sp140 != 0) {
            sp144 = sp11C;
        }
    }
    temp_s2 = "cannot write pfield";
    if (arg1 & 2) {
        sp11C += var_t3;
        var_t3 = 0;
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp120 = var_t3;
                temp_v0_9 = st_pcfd_ifd((s16) sp118);
                temp_t9_2 = temp_v0_9->unk0;
                sp188 = temp_t9_2;
                temp_a2_2 = temp_t9_2->unk14;
                temp_t9_2->unk10 = (s32) (sp19C + sp1A0);
                var_t3 += temp_a2_2 * 0xC;
                if (temp_a2_2 != 0) {
                    sp120 = var_t3;
                    if (fwrite(temp_v0_9->unk4, 0xC, (u16) temp_a2_2, sp10C) != sp188->unk14) {
                        sp120 = var_t3;
                        st_error(temp_s2);
                    }
                }
                sp19C += sp1A0;
                temp_a0 = sp188->unk14;
                temp_t6 = sp118 + 1;
                sp148 += temp_a0;
                sp118 = temp_t6;
                sp1A0 = temp_a0;
            } while (temp_t6 != sp114);
        }
        if (sp148 != 0) {
            sp14C = sp11C;
        }
    }
    if (arg1 & 0x20) {
        sp11C += var_t3;
        var_t3 = 0;
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp120 = var_t3;
                temp_v0_10 = st_pcfd_ifd((s16) sp118);
                temp_t4 = temp_v0_10->unk0;
                sp188 = temp_t4;
                temp_a2_3 = temp_t4->unk24;
                temp_t4->unk20 = (s32) (sp1AC + sp1B0);
                var_t3 += temp_a2_3 * 0xC;
                if (temp_a2_3 != 0) {
                    sp120 = var_t3;
                    if (fwrite(temp_v0_10->unk1C, 0xC, (u16) temp_a2_3, sp10C) != sp188->unk24) {
                        sp120 = var_t3;
                        st_error(temp_s2);
                    }
                }
                sp1AC += sp1B0;
                temp_a0_2 = sp188->unk24;
                temp_t5_3 = sp118 + 1;
                sp150 += temp_a0_2;
                sp118 = temp_t5_3;
                sp1B0 = temp_a0_2;
            } while (temp_t5_3 != sp114);
        }
        if (sp150 != 0) {
            sp154 = sp11C;
        }
    }
    if (arg1 & 0x400) {
        sp11C += var_t3;
        var_t3 = 0;
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp120 = var_t3;
                temp_v0_11 = st_pcfd_ifd((s16) sp118);
                temp_t8 = temp_v0_11->unk0;
                sp188 = temp_t8;
                temp_a2_4 = temp_t8->unk30;
                temp_t8->unk2C = (s32) (sp1B8 + sp1BC);
                var_t3 += temp_a2_4 * 4;
                if (temp_a2_4 != 0) {
                    sp120 = var_t3;
                    if (fwrite(temp_v0_11->unkC, 4, (u16) temp_a2_4, sp10C) != sp188->unk30) {
                        sp120 = var_t3;
                        st_error(temp_s2);
                    }
                }
                sp1B8 += sp1BC;
                temp_a0_3 = sp188->unk30;
                temp_t9_3 = sp118 + 1;
                sp158 += temp_a0_3;
                sp118 = temp_t9_3;
                sp1BC = temp_a0_3;
            } while (temp_t9_3 != sp114);
        }
        if (sp158 != 0) {
            sp15C = sp11C;
        }
    }
    if (arg1 & 0x80) {
        sp11C += var_t3;
        var_t3 = 0;
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp120 = var_t3;
                temp_v0_12 = st_pcfd_ifd((s16) sp118);
                temp_t7_2 = temp_v0_12->unk0;
                sp188 = temp_t7_2;
                temp_a2_5 = temp_t7_2->unkC;
                temp_t7_2->unk8 = (s32) (sp194 + sp198);
                var_t3 += temp_a2_5;
                if (temp_a2_5 != 0) {
                    sp120 = var_t3;
                    if (fwrite(temp_v0_12->unk14, 1, (u16) temp_a2_5, sp10C) != sp188->unkC) {
                        sp120 = var_t3;
                        st_error(temp_s2);
                    }
                }
                sp194 += sp198;
                temp_a0_4 = sp188->unkC;
                temp_t4_2 = sp118 + 1;
                sp160 += temp_a0_4;
                sp118 = temp_t4_2;
                sp198 = temp_a0_4;
            } while (temp_t4_2 != sp114);
        }
        temp_t5_4 = -var_t3 & 3;
        if (temp_t5_4 != 0) {
            sp120 = var_t3;
            if (fwrite(B_1000A980, 1, temp_t5_4, sp10C) != temp_t5_4) {
                sp120 = var_t3;
                st_error("cannot write round bytes for strings\n");
            }
            var_t3 = (var_t3 + 3) & ~3;
        }
        sp160 = var_t3;
        if (var_t3 != 0) {
            sp164 = sp11C;
        }
    }
    if (arg1 & 0x800) {
        temp_t6_2 = sp11C + var_t3;
        temp_t9_4 = st_pchdr->unk28;
        sp11C = temp_t6_2;
        var_t3 = 0;
        sp168 = temp_t9_4;
        if ((temp_t9_4 != 0) && (var_t3 = st_pchdr->unk28, sp16C = temp_t6_2, temp_v1_3 = st_pchdr->unk28, (temp_v1_3 != 0))) {
            sp120 = var_t3;
            var_s0_2 = -var_t3;
            if (fwrite(st_pchdr->unk24, 1, (u16) temp_v1_3, sp10C) != st_pchdr->unk28) {
                sp120 = var_t3;
                st_error("cannot write cur table\n");
                goto block_115;
            }
        } else {
block_115:
            var_s0_2 = -var_t3;
        }
        temp_t9_5 = var_s0_2 & 3;
        if (temp_t9_5 != 0) {
            sp120 = var_t3;
            if (fwrite(B_1000A980, 1, temp_t9_5, sp10C) != temp_t9_5) {
                sp120 = var_t3;
                st_error("cannot write round bytes for strings\n");
            }
            var_t3 = (var_t3 + 3) & ~3;
        }
        sp168 = var_t3;
    }
    temp_s1_3 = "cannot write cur table\n";
    if (arg1 & 0x200) {
        temp_t8_2 = st_pchdr->unkC;
        temp_t9_6 = sp11C + var_t3;
        sp11C = temp_t9_6;
        var_t3 = 0;
        sp170 = temp_t8_2;
        if (temp_t8_2 != 0) {
            sp174 = temp_t9_6;
            temp_v1_4 = st_pchdr->unkC;
            temp_t7_3 = st_pchdr->unkC * 0x48;
            var_t3 = temp_t7_3;
            if (temp_v1_4 != 0) {
                sp120 = temp_t7_3;
                var_t3 = sp120;
                if (fwrite(st_pchdr->unk8, 0x48, (u16) temp_v1_4, sp10C) != st_pchdr->unkC) {
                    st_error(temp_s1_3);
                }
            }
        }
    }
    if (arg1 & 0x40) {
        sp11C += var_t3;
        var_t3 = 0;
        if (sp114 > 0) {
            sp118 = 0;
            do {
                sp120 = var_t3;
                temp_v0_13 = st_pcfd_ifd((s16) sp118);
                temp_t8_3 = temp_v0_13->unk0;
                sp188 = temp_t8_3;
                temp_a2_6 = temp_t8_3->unk38;
                temp_t8_3->unk34 = (s32) (sp1C0 + sp1C4);
                var_t3 += temp_a2_6 * 4;
                if (temp_a2_6 != 0) {
                    sp120 = var_t3;
                    if (fwrite(temp_v0_13->unk2C, 4, (u16) temp_a2_6, sp10C) != sp188->unk38) {
                        sp120 = var_t3;
                        st_error(temp_s2);
                    }
                }
                sp1C0 += sp1C4;
                temp_a0_5 = sp188->unk38;
                temp_t5_5 = sp118 + 1;
                sp178 += temp_a0_5;
                sp118 = temp_t5_5;
                sp1C4 = temp_a0_5;
            } while (temp_t5_5 != sp114);
        }
        if (sp178 != 0) {
            sp17C = sp11C;
        }
    }
    if (arg1 & 1) {
        temp_v0_14 = st_pchdr;
        temp_t5_6 = temp_v0_14->unk1C;
        temp_t9_7 = sp11C + var_t3;
        sp11C = temp_t9_7;
        var_t3 = 0;
        sp180 = temp_t5_6;
        if (temp_t5_6 != 0) {
            sp184 = temp_t9_7;
            temp_v1_5 = temp_v0_14->unk1C;
            temp_t8_4 = temp_v0_14->unk1C * 0x10;
            var_t3 = temp_t8_4;
            if (temp_v1_5 != 0) {
                sp120 = temp_t8_4;
                var_t3 = sp120;
                if (fwrite(temp_v0_14->unk18, 0x10, (u16) temp_v1_5, sp10C) != st_pchdr->unk1C) {
                    st_error(temp_s1_3);
                }
            }
        }
    }
    if (arg1 & 0x10) {
        temp_v0_15 = st_pchdr;
        if (temp_v0_15->unk3C != 0) {
            *temp_v0_15->unk38 = NULL;
            st_pchdr->unk38->unk4 = 0;
            st_pchdr->unk38->unk8 = 0;
            st_pchdr->unk38->unkC = 0;
            temp_v0_16 = st_pchdr;
            temp_t4_3 = temp_v0_16->unk3C;
            temp_t7_4 = sp11C + var_t3;
            sp11C = temp_t7_4;
            sp138 = temp_t4_3;
            if (temp_t4_3 != 0) {
                sp13C = temp_t7_4;
                temp_v1_6 = temp_v0_16->unk3C;
                if ((temp_v1_6 != 0) && (fwrite(temp_v0_16->unk38, 8, (u16) temp_v1_6, sp10C) != st_pchdr->unk3C)) {
                    st_error(temp_s1_3);
                }
            }
        }
    }
    fflush(sp10C);
    fseek(sp10C, sp110, 0);
    unksp12A = 0x313;
    sp128 = *"p\t";
    if (fwrite(&sp128, 1, 0x60U, sp10C) != 0x60) {
        st_error("cannot write symbol header\n");
    }
    fclose(sp10C);
}

void st_setstmagic(s16 arg0) {
    *"p\t" = arg0;
}

s32 gethostsex(void) {
    s32 sp4;
    s32 var_v0;

    sp4 = 1;
    var_v0 = 0;
    if ((s8) sp4 == 1) {
        var_v0 = 1;
    }
    return var_v0;
}

void swap_filehdr(void *arg0, ? arg1) {
    s32 temp_a1;
    s32 temp_a2;
    s32 temp_a3;
    u16 temp_t8;
    u16 temp_v0;
    u16 temp_v0_2;
    u16 temp_v1;

    temp_v0 = arg0->unk0;
    temp_a1 = arg0->unk4;
    temp_v1 = arg0->unk2;
    arg0->unk0 = (u16) ((temp_v0 << 8) | (temp_v0 >> 8));
    temp_a2 = arg0->unk8;
    temp_a3 = arg0->unkC;
    arg0->unk2 = (u16) ((temp_v1 << 8) | (temp_v1 >> 8));
    arg0->unk4 = (s32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | ((u32) temp_a1 >> 0x18));
    temp_v0_2 = arg0->unk10;
    temp_t8 = arg0->unk12;
    arg0->unk8 = (s32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | ((u32) temp_a2 >> 0x18));
    arg0->unkC = (s32) ((temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00) | ((u32) temp_a3 >> 0x18));
    arg0->unk10 = (u16) (((temp_v0_2 & 0xFF) << 8) | (temp_v0_2 >> 8));
    arg0->unk12 = (u16) ((temp_t8 << 8) | (temp_t8 >> 8));
}

void swap_aouthdr(void *arg0, ? arg1) {
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a3;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk2;
    temp_a1 = arg0->unk4;
    arg0->unk0 = (s16) ((temp_v0 << 8) | ((u32) (temp_v0 & 0xFFFF) >> 8));
    temp_a2 = arg0->unk8;
    arg0->unk2 = (s16) ((temp_v1 << 8) | ((u32) (temp_v1 & 0xFFFF) >> 8));
    temp_a3 = arg0->unkC;
    arg0->unk4 = (s32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | ((u32) temp_a1 >> 0x18));
    temp_v0_2 = arg0->unk10;
    arg0->unk8 = (s32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | ((u32) temp_a2 >> 0x18));
    temp_v1_2 = arg0->unk14;
    arg0->unkC = (s32) ((temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00) | ((u32) temp_a3 >> 0x18));
    temp_a1_2 = arg0->unk18;
    arg0->unk10 = (s32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | ((u32) temp_v0_2 >> 0x18));
    temp_a2_2 = arg0->unk1C;
    arg0->unk14 = (s32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | ((u32) temp_v1_2 >> 0x18));
    temp_v0_3 = arg0->unk20;
    arg0->unk18 = (s32) ((temp_a1_2 << 0x18) | ((temp_a1_2 << 8) & 0xFF0000) | ((temp_a1_2 >> 8) & 0xFF00) | ((u32) temp_a1_2 >> 0x18));
    temp_v1_3 = arg0->unk24;
    arg0->unk1C = (s32) ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00) | ((u32) temp_a2_2 >> 0x18));
    temp_a1_3 = arg0->unk28;
    arg0->unk20 = (s32) ((temp_v0_3 << 0x18) | ((temp_v0_3 << 8) & 0xFF0000) | ((temp_v0_3 >> 8) & 0xFF00) | ((u32) temp_v0_3 >> 0x18));
    temp_a2_3 = arg0->unk2C;
    arg0->unk24 = (s32) (((u32) temp_v1_3 >> 0x18) | ((temp_v1_3 << 0x18) | ((temp_v1_3 << 8) & 0xFF0000) | ((temp_v1_3 >> 8) & 0xFF00)));
    temp_v0_4 = arg0->unk30;
    arg0->unk28 = (s32) (((u32) temp_a1_3 >> 0x18) | ((temp_a1_3 << 0x18) | ((temp_a1_3 << 8) & 0xFF0000) | ((temp_a1_3 >> 8) & 0xFF00)));
    temp_v1_4 = arg0->unk34;
    arg0->unk2C = (s32) (((u32) temp_a2_3 >> 0x18) | ((temp_a2_3 << 0x18) | ((temp_a2_3 << 8) & 0xFF0000) | ((temp_a2_3 >> 8) & 0xFF00)));
    arg0->unk30 = (s32) (((u32) temp_v0_4 >> 0x18) | ((temp_v0_4 << 0x18) | ((temp_v0_4 << 8) & 0xFF0000) | ((temp_v0_4 >> 8) & 0xFF00)));
    arg0->unk34 = (s32) ((temp_v1_4 << 0x18) | ((temp_v1_4 << 8) & 0xFF0000) | ((temp_v1_4 >> 8) & 0xFF00) | ((u32) temp_v1_4 >> 0x18));
}

void swap_scnhdr(void *arg0, ? arg1) {
    s32 temp_a1;
    s32 temp_a2;
    s32 temp_a3;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 temp_v1_2;
    u16 temp_a1_2;
    u16 temp_a2_2;

    temp_v0 = arg0->unk8;
    temp_v1 = arg0->unkC;
    temp_a1 = arg0->unk10;
    arg0->unk8 = (s32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | ((u32) temp_v0 >> 0x18));
    temp_a2 = arg0->unk14;
    arg0->unkC = (s32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | ((u32) temp_v1 >> 0x18));
    temp_v0_2 = arg0->unk18;
    arg0->unk10 = (s32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | ((u32) temp_a1 >> 0x18));
    temp_v1_2 = arg0->unk1C;
    arg0->unk14 = (s32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | ((u32) temp_a2 >> 0x18));
    temp_a1_2 = arg0->unk20;
    temp_a2_2 = arg0->unk22;
    arg0->unk18 = (s32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | ((u32) temp_v0_2 >> 0x18));
    temp_a3 = arg0->unk24;
    arg0->unk1C = (s32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | ((u32) temp_v1_2 >> 0x18));
    arg0->unk20 = (u16) ((temp_a1_2 << 8) | (temp_a1_2 >> 8));
    arg0->unk22 = (u16) ((temp_a2_2 << 8) | (temp_a2_2 >> 8));
    arg0->unk24 = (s32) ((temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00) | ((u32) temp_a3 >> 0x18));
}

void swap_libscn(void *arg0, ? arg1) {
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 temp_v1_2;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_a1 = arg0->unk8;
    arg0->unk0 = (s32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | ((u32) temp_v0 >> 0x18));
    temp_a2 = arg0->unkC;
    arg0->unk4 = (s32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | ((u32) temp_v1 >> 0x18));
    temp_v0_2 = arg0->unk10;
    arg0->unk8 = (s32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | ((u32) temp_a1 >> 0x18));
    temp_v1_2 = arg0->unk14;
    arg0->unkC = (s32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | ((u32) temp_a2 >> 0x18));
    temp_a1_2 = arg0->unk18;
    arg0->unk10 = (s32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | ((u32) temp_v0_2 >> 0x18));
    temp_a2_2 = arg0->unk1C;
    arg0->unk14 = (s32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | ((u32) temp_v1_2 >> 0x18));
    arg0->unk18 = (s32) ((temp_a1_2 << 0x18) | ((temp_a1_2 << 8) & 0xFF0000) | ((temp_a1_2 >> 8) & 0xFF00) | ((u32) temp_a1_2 >> 0x18));
    arg0->unk1C = (s32) ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00) | ((u32) temp_a2_2 >> 0x18));
}

void swap_hdr(s16 *arg0, s32 arg1) {
    s16 temp_a1;
    s16 temp_v1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a1_5;
    s32 temp_a1_6;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a2_5;
    s32 temp_a2_6;
    s32 temp_a3;
    s32 temp_a3_2;
    s32 temp_a3_3;
    s32 temp_a3_4;
    s32 temp_a3_5;
    s32 temp_a3_6;
    s32 temp_t0;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;

    temp_v1 = arg0->unk0;
    temp_a1 = arg0->unk2;
    temp_a2 = arg0->unk4;
    arg0->unk0 = (temp_v1 << 8) | ((u32) (temp_v1 & 0xFFFF) >> 8);
    temp_a3 = arg0->unk8;
    arg0->unk2 = (s16) ((temp_a1 << 8) | ((u32) (temp_a1 & 0xFFFF) >> 8));
    temp_t0 = arg0->unkC;
    arg0->unk4 = (s32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | ((u32) temp_a2 >> 0x18));
    temp_v1_2 = arg0->unk10;
    arg0->unk8 = (s32) ((temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00) | ((u32) temp_a3 >> 0x18));
    temp_a1_2 = arg0->unk14;
    arg0->unkC = (s32) ((temp_t0 << 0x18) | ((temp_t0 << 8) & 0xFF0000) | ((temp_t0 >> 8) & 0xFF00) | ((u32) temp_t0 >> 0x18));
    temp_a2_2 = arg0->unk18;
    arg0->unk10 = (s32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | ((u32) temp_v1_2 >> 0x18));
    temp_a3_2 = arg0->unk1C;
    arg0->unk14 = (s32) ((temp_a1_2 << 0x18) | ((temp_a1_2 << 8) & 0xFF0000) | ((temp_a1_2 >> 8) & 0xFF00) | ((u32) temp_a1_2 >> 0x18));
    temp_v1_3 = arg0->unk20;
    arg0->unk18 = (s32) ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00) | ((u32) temp_a2_2 >> 0x18));
    temp_a1_3 = arg0->unk24;
    arg0->unk1C = (s32) ((temp_a3_2 << 0x18) | ((temp_a3_2 << 8) & 0xFF0000) | ((temp_a3_2 >> 8) & 0xFF00) | ((u32) temp_a3_2 >> 0x18));
    temp_a2_3 = arg0->unk28;
    arg0->unk20 = (s32) ((temp_v1_3 << 0x18) | ((temp_v1_3 << 8) & 0xFF0000) | ((temp_v1_3 >> 8) & 0xFF00) | ((u32) temp_v1_3 >> 0x18));
    temp_a3_3 = arg0->unk2C;
    arg0->unk24 = (s32) ((temp_a1_3 << 0x18) | ((temp_a1_3 << 8) & 0xFF0000) | ((temp_a1_3 >> 8) & 0xFF00) | ((u32) temp_a1_3 >> 0x18));
    temp_v1_4 = arg0->unk30;
    arg0->unk28 = (s32) ((temp_a2_3 << 0x18) | ((temp_a2_3 << 8) & 0xFF0000) | ((temp_a2_3 >> 8) & 0xFF00) | ((u32) temp_a2_3 >> 0x18));
    temp_a1_4 = arg0->unk34;
    arg0->unk2C = (s32) ((temp_a3_3 << 0x18) | ((temp_a3_3 << 8) & 0xFF0000) | ((temp_a3_3 >> 8) & 0xFF00) | ((u32) temp_a3_3 >> 0x18));
    temp_a2_4 = arg0->unk38;
    arg0->unk30 = (s32) ((temp_v1_4 << 0x18) | ((temp_v1_4 << 8) & 0xFF0000) | ((temp_v1_4 >> 8) & 0xFF00) | ((u32) temp_v1_4 >> 0x18));
    temp_a3_4 = arg0->unk3C;
    arg0->unk34 = (s32) ((temp_a1_4 << 0x18) | ((temp_a1_4 << 8) & 0xFF0000) | ((temp_a1_4 >> 8) & 0xFF00) | ((u32) temp_a1_4 >> 0x18));
    temp_v1_5 = arg0->unk40;
    arg0->unk38 = (s32) ((temp_a2_4 << 0x18) | ((temp_a2_4 << 8) & 0xFF0000) | ((temp_a2_4 >> 8) & 0xFF00) | ((u32) temp_a2_4 >> 0x18));
    temp_a1_5 = arg0->unk44;
    arg0->unk3C = (s32) ((temp_a3_4 << 0x18) | ((temp_a3_4 << 8) & 0xFF0000) | ((temp_a3_4 >> 8) & 0xFF00) | ((u32) temp_a3_4 >> 0x18));
    temp_a2_5 = arg0->unk48;
    arg0->unk40 = (s32) ((temp_v1_5 << 0x18) | ((temp_v1_5 << 8) & 0xFF0000) | ((temp_v1_5 >> 8) & 0xFF00) | ((u32) temp_v1_5 >> 0x18));
    temp_a3_5 = arg0->unk4C;
    arg0->unk44 = (s32) ((temp_a1_5 << 0x18) | ((temp_a1_5 << 8) & 0xFF0000) | ((temp_a1_5 >> 8) & 0xFF00) | ((u32) temp_a1_5 >> 0x18));
    temp_v1_6 = arg0->unk50;
    arg0->unk48 = (s32) ((temp_a2_5 << 0x18) | ((temp_a2_5 << 8) & 0xFF0000) | ((temp_a2_5 >> 8) & 0xFF00) | ((u32) temp_a2_5 >> 0x18));
    temp_a1_6 = arg0->unk54;
    arg0->unk4C = (s32) ((temp_a3_5 << 0x18) | ((temp_a3_5 << 8) & 0xFF0000) | ((temp_a3_5 >> 8) & 0xFF00) | ((u32) temp_a3_5 >> 0x18));
    temp_a2_6 = arg0->unk58;
    arg0->unk50 = (s32) ((temp_v1_6 << 0x18) | ((temp_v1_6 << 8) & 0xFF0000) | ((temp_v1_6 >> 8) & 0xFF00) | ((u32) temp_v1_6 >> 0x18));
    temp_a3_6 = arg0->unk5C;
    arg0->unk54 = (s32) ((temp_a1_6 << 0x18) | ((temp_a1_6 << 8) & 0xFF0000) | ((temp_a1_6 >> 8) & 0xFF00) | ((u32) temp_a1_6 >> 0x18));
    arg0->unk58 = (s32) ((temp_a2_6 << 0x18) | ((temp_a2_6 << 8) & 0xFF0000) | ((temp_a2_6 >> 8) & 0xFF00) | ((u32) temp_a2_6 >> 0x18));
    arg0->unk5C = (s32) ((temp_a3_6 << 0x18) | ((temp_a3_6 << 8) & 0xFF0000) | ((temp_a3_6 >> 8) & 0xFF00) | ((u32) temp_a3_6 >> 0x18));
}

void swap_fd(? *arg0, s32 arg1, s32 arg2) {
    s32 sp84;
    s32 sp80;
    u32 sp7C;
    s32 sp78;
    s32 sp74;
    s32 sp70;
    s32 sp6C;
    u16 sp6A;
    u16 sp68;
    s32 sp64;
    s32 sp60;
    s32 sp5C;
    s32 sp58;
    s32 sp54;
    s32 sp50;
    s32 sp4C;
    s32 sp48;
    s32 sp44;
    u32 sp40;
    ? *var_v1;
    s32 temp_v0;
    s32 var_s3;
    s8 temp_t8;
    s8 temp_t8_2;
    s8 temp_t8_3;
    u32 temp_t9;
    u32 temp_t9_2;
    u8 temp_t7;

    temp_v0 = gethostsex();
    var_s3 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            M2C_MEMCPY_ALIGNED(&sp40, var_v1, 0x48);
            sp40 = (sp40 << 0x18) | ((sp40 << 8) & 0xFF0000) | ((sp40 >> 8) & 0xFF00) | (sp40 >> 0x18);
            sp44 = (sp44 << 0x18) | ((sp44 << 8) & 0xFF0000) | ((sp44 >> 8) & 0xFF00) | ((u32) sp44 >> 0x18);
            sp48 = (sp48 << 0x18) | ((sp48 << 8) & 0xFF0000) | ((sp48 >> 8) & 0xFF00) | ((u32) sp48 >> 0x18);
            sp4C = (sp4C << 0x18) | ((sp4C << 8) & 0xFF0000) | ((sp4C >> 8) & 0xFF00) | ((u32) sp4C >> 0x18);
            sp50 = (sp50 << 0x18) | ((sp50 << 8) & 0xFF0000) | ((sp50 >> 8) & 0xFF00) | ((u32) sp50 >> 0x18);
            sp68 = ((s16) sp68 << 8) | (sp68 >> 8);
            sp6A = ((s16) sp6A << 8) | (sp6A >> 8);
            sp84 = (sp84 << 0x18) | ((sp84 << 8) & 0xFF0000) | ((sp84 >> 8) & 0xFF00) | ((u32) sp84 >> 0x18);
            sp80 = (sp80 << 0x18) | ((sp80 << 8) & 0xFF0000) | ((sp80 >> 8) & 0xFF00) | ((u32) sp80 >> 0x18);
            sp78 = (sp78 << 0x18) | ((sp78 << 8) & 0xFF0000) | ((sp78 >> 8) & 0xFF00) | ((u32) sp78 >> 0x18);
            sp74 = (sp74 << 0x18) | ((sp74 << 8) & 0xFF0000) | ((sp74 >> 8) & 0xFF00) | ((u32) sp74 >> 0x18);
            sp70 = (sp70 << 0x18) | ((sp70 << 8) & 0xFF0000) | ((sp70 >> 8) & 0xFF00) | ((u32) sp70 >> 0x18);
            sp6C = (sp6C << 0x18) | ((sp6C << 8) & 0xFF0000) | ((sp6C >> 8) & 0xFF00) | ((u32) sp6C >> 0x18);
            sp64 = (sp64 << 0x18) | ((sp64 << 8) & 0xFF0000) | ((sp64 >> 8) & 0xFF00) | ((u32) sp64 >> 0x18);
            sp60 = (sp60 << 0x18) | ((sp60 << 8) & 0xFF0000) | ((sp60 >> 8) & 0xFF00) | ((u32) sp60 >> 0x18);
            sp5C = (sp5C << 0x18) | ((sp5C << 8) & 0xFF0000) | ((sp5C >> 8) & 0xFF00) | ((u32) sp5C >> 0x18);
            sp58 = (sp58 << 0x18) | ((sp58 << 8) & 0xFF0000) | ((sp58 >> 8) & 0xFF00) | ((u32) sp58 >> 0x18);
            sp54 = (sp54 << 0x18) | ((sp54 << 8) & 0xFF0000) | ((sp54 >> 8) & 0xFF00) | ((u32) sp54 >> 0x18);
            if (arg2 == temp_v0) {
                M2C_MEMCPY_ALIGNED(var_v1, &sp40, 0x48);
                temp_t9 = (sp7C << 0x18) | ((sp7C << 8) & 0xFF0000) | ((sp7C >> 8) & 0xFF00) | (sp7C >> 0x18);
                sp7C = temp_t9;
                var_v1->unk3C = (u8) ((temp_t9 * 8) | (var_v1->unk3C & 0xFF07));
                var_v1->unk3C = (u8) (((((u32) (sp7C << 0x1A) >> 0x1F) * 4) & 4) | (var_v1->unk3C & 0xFFFB));
                temp_t7 = ((((u32) (sp7C << 0x19) >> 0x1F) * 2) & 2) | (var_v1->unk3C & 0xFFFD);
                var_v1->unk3C = temp_t7;
                var_v1->unk3C = (u8) (((unksp7F >> 7) & 1) | (temp_t7 & 0xFE));
                var_v1->unk3D = (u8) ((unksp7E << 6) | (var_v1->unk3D & 0xFF3F));
                var_v1->unk3E = (u16) (((sp7C >> 0xA) & 0x1FFF) | (var_v1->unk3E & 0xE000));
            } else {
                temp_t8 = (((u32) var_v1->unk3C >> 0x1B) & 0x1F) | (unksp7F & 0xFFE0);
                unksp7F = temp_t8;
                temp_t8_2 = ((((u32) ((s32) var_v1->unk3C << 5) >> 0x1F) << 5) & 0x20) | (temp_t8 & 0xDF);
                unksp7F = temp_t8_2;
                temp_t8_3 = ((((u32) ((s32) var_v1->unk3C << 6) >> 0x1F) << 6) & 0x40) | (temp_t8_2 & 0xBF);
                unksp7F = temp_t8_3;
                unksp7F = (var_v1->unk3C << 7) | (temp_t8_3 & 0x7F);
                unksp7E = (((u8) var_v1->unk3D >> 6) & 3) | (unksp7E & 0xFFFC);
                temp_t9_2 = ((((s32) var_v1->unk3C & 0x1FFF) ^ (sp7C >> 0xA)) << 0xA) ^ sp7C;
                sp7C = temp_t9_2;
                sp7C = (temp_t9_2 << 0x18) | ((temp_t9_2 << 8) & 0xFF0000) | ((temp_t9_2 >> 8) & 0xFF00) | (temp_t9_2 >> 0x18);
                M2C_MEMCPY_ALIGNED(var_v1, &sp40, 0x48);
            }
            var_s3 += 1;
            var_v1 += 0x48;
        } while (var_s3 != arg1);
    }
}

void swap_fi(? *arg0, s32 arg1, s32 arg2) {
    s32 *var_v1;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a3;
    s32 temp_t8;
    s32 temp_v0;
    s32 var_v0;
    void *var_v1_2;

    var_v0 = 0;
    if (arg1 > 0) {
        temp_a2 = arg1 & 3;
        if (temp_a2 != 0) {
            var_v1 = arg0 + (0 * 4);
            do {
                temp_a2_2 = *var_v1;
                var_v0 += 1;
                *var_v1 = ((u32) temp_a2_2 >> 0x18) | ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00));
                var_v1 += 4;
            } while (temp_a2 != var_v0);
            if (var_v0 != arg1) {
                goto block_5;
            }
        } else {
block_5:
            var_v1_2 = arg0 + (var_v0 * 4);
            do {
                temp_a2_3 = var_v1_2->unk0;
                temp_v0 = var_v1_2->unk4;
                temp_a0 = var_v1_2->unk8;
                var_v1_2->unk0 = (s32) (((u32) temp_a2_3 >> 0x18) | ((temp_a2_3 << 0x18) | ((temp_a2_3 << 8) & 0xFF0000) | ((temp_a2_3 >> 8) & 0xFF00)));
                temp_a3 = var_v1_2->unkC;
                var_v1_2->unk4 = (s32) (((u32) temp_v0 >> 0x18) | ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00)));
                var_v1_2->unk8 = (s32) (((u32) temp_a0 >> 0x18) | ((temp_a0 << 0x18) | ((temp_a0 << 8) & 0xFF0000) | ((temp_a0 >> 8) & 0xFF00)));
                temp_t8 = ((u32) temp_a3 >> 0x18) | ((temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00));
                var_v1_2 += 0x10;
                var_v1_2->unk-4 = temp_t8;
            } while (var_v1_2 != ((arg1 * 4) + arg0));
        }
    }
}

void swap_sym(? *arg0, s32 arg1, s32 arg2) {
    u32 sp34;
    s32 sp30;
    s32 sp2C;
    ? *var_v1;
    s32 temp_v0;
    s32 var_a2;
    u32 temp_a0;
    u32 temp_t5;
    u32 temp_t5_2;

    temp_v0 = gethostsex();
    var_a2 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            var_a2 += 1;
            sp2C.unk0 = var_v1->unk0;
            sp2C.unk4 = (s32) var_v1->unk4;
            sp2C.unk8 = (u32) var_v1->unk8;
            sp2C = (sp2C << 0x18) | ((sp2C << 8) & 0xFF0000) | ((sp2C >> 8) & 0xFF00) | ((u32) sp2C >> 0x18);
            sp30 = (sp30 << 0x18) | ((sp30 << 8) & 0xFF0000) | ((sp30 >> 8) & 0xFF00) | ((u32) sp30 >> 0x18);
            if (arg2 == temp_v0) {
                var_v1->unk0 = sp2C.unk0;
                var_v1->unk4 = (s32) sp2C.unk4;
                var_v1->unk8 = (u32) sp2C.unk8;
                temp_t5 = (sp34 << 0x18) | ((sp34 << 8) & 0xFF0000) | ((sp34 >> 8) & 0xFF00) | (sp34 >> 0x18);
                sp34 = temp_t5;
                var_v1->unk8 = (s8) ((temp_t5 * 4) | ((u8) var_v1->unk8 & 0xFF03));
                var_v1->unk8 = (s16) (((((u32) (sp34 << 0x15) >> 0x1B) << 5) & 0x3E0) | ((u16) var_v1->unk8 & 0xFC1F));
                var_v1->unk9 = (u8) (((((u32) (sp34 << 0x14) >> 0x1F) * 0x10) & 0x10) | (var_v1->unk9 & 0xFFEF));
                temp_a0 = var_v1->unk8;
                var_v1->unk8 = (u32) (((u32) (((sp34 >> 0xC) ^ temp_a0) << 0xC) >> 0xC) ^ temp_a0);
            } else {
                unksp37 = (((u32) var_v1->unk8 >> 0x1A) & 0x3F) | (unksp37 & 0xFFC0);
                unksp36 = ((((u32) (var_v1->unk8 << 6) >> 0x1B) << 6) & 0x7C0) | (unksp36 & 0xF83F);
                unksp36 = ((((u32) (var_v1->unk8 << 0xB) >> 0x1F) * 8) & 8) | ((u8) unksp36 & 0xFFF7);
                temp_t5_2 = (((var_v1->unk8 & 0xFFFFF) ^ (sp34 >> 0xC)) << 0xC) ^ sp34;
                sp34 = temp_t5_2;
                sp34 = (temp_t5_2 << 0x18) | ((temp_t5_2 << 8) & 0xFF0000) | ((temp_t5_2 >> 8) & 0xFF00) | (temp_t5_2 >> 0x18);
                var_v1->unk0 = sp2C.unk0;
                var_v1->unk4 = (s32) sp2C.unk4;
                var_v1->unk8 = (u32) sp2C.unk8;
            }
            var_v1 += 0xC;
        } while (var_a2 != arg1);
    }
}

void swap_ext(? *arg0, s32 arg1, s32 arg2) {
    u32 sp3C;
    s32 sp38;
    s32 sp34;
    u32 sp30;                                       /* compiler-managed */
    ? *var_v1;
    s32 temp_v0;
    s32 var_a3;
    s8 temp_t4;
    s8 temp_t5_3;
    s8 temp_t7;
    s8 temp_t7_2;
    u32 temp_a0;
    u32 temp_t5;
    u32 temp_t5_2;

    temp_v0 = gethostsex();
    var_a3 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            var_a3 += 1;
            sp30.unk0 = var_v1->unk0;
            sp30.unk4 = (s32) var_v1->unk4;
            sp30.unk8 = (s32) var_v1->unk8;
            sp30.unkC = (u32) var_v1->unkC;
            sp34 = (sp34 << 0x18) | ((sp34 << 8) & 0xFF0000) | ((sp34 >> 8) & 0xFF00) | ((u32) sp34 >> 0x18);
            sp38 = (sp38 << 0x18) | ((sp38 << 8) & 0xFF0000) | ((sp38 >> 8) & 0xFF00) | ((u32) sp38 >> 0x18);
            if (arg2 == temp_v0) {
                var_v1->unk0 = sp30.unk0;
                var_v1->unk4 = (s32) sp30.unk4;
                var_v1->unk8 = (s32) sp30.unk8;
                var_v1->unkC = (u32) sp30.unkC;
                temp_t5 = (sp3C << 0x18) | ((sp3C << 8) & 0xFF0000) | ((sp3C >> 8) & 0xFF00) | (sp3C >> 0x18);
                sp3C = temp_t5;
                var_v1->unkC = (s8) ((temp_t5 * 4) | ((u8) var_v1->unkC & 0xFF03));
                var_v1->unkC = (s16) (((((u32) (sp3C << 0x15) >> 0x1B) << 5) & 0x3E0) | ((u16) var_v1->unkC & 0xFC1F));
                var_v1->unkD = (u8) (((((u32) (sp3C << 0x14) >> 0x1F) * 0x10) & 0x10) | (var_v1->unkD & 0xFFEF));
                temp_a0 = var_v1->unkC;
                var_v1->unkC = (u32) (((u32) (((sp3C >> 0xC) ^ temp_a0) << 0xC) >> 0xC) ^ temp_a0);
                sp30 = (sp30 << 0x18) | ((sp30 << 8) & 0xFF0000) | ((sp30 >> 8) & 0xFF00) | (sp30 >> 0x18);
                var_v1->unk2 = (s16) sp30;
                var_v1->unk0 = (s16) (((unksp32 >> 3) & 0x7FF) | ((u16) var_v1->unk0 & 0xF800));
                temp_t7 = (sp30 << 7) | ((u8) var_v1->unk0 & 0xFF7F);
                var_v1->unk0 = temp_t7;
                temp_t7_2 = ((((u32) (sp30 << 0x1E) >> 0x1F) << 6) & 0x40) | (temp_t7 & 0xBF);
                var_v1->unk0 = temp_t7_2;
                var_v1->unk0 = (s8) (((((u32) (sp30 << 0x1D) >> 0x1F) << 5) & 0x20) | (temp_t7_2 & 0xDF));
            } else {
                unksp3F = (((u32) var_v1->unkC >> 0x1A) & 0x3F) | (unksp3F & 0xFFC0);
                unksp3E = ((((u32) (var_v1->unkC << 6) >> 0x1B) << 6) & 0x7C0) | (unksp3E & 0xF83F);
                unksp3E = ((((u32) (var_v1->unkC << 0xB) >> 0x1F) * 8) & 8) | ((u8) unksp3E & 0xFFF7);
                temp_t5_2 = (((var_v1->unkC & 0xFFFFF) ^ (sp3C >> 0xC)) << 0xC) ^ sp3C;
                sp3C = temp_t5_2;
                sp3C = (temp_t5_2 << 0x18) | ((temp_t5_2 << 8) & 0xFF0000) | ((temp_t5_2 >> 8) & 0xFF00) | (temp_t5_2 >> 0x18);
                sp30 = var_v1->unk2;
                unksp32 = (((u16) var_v1->unk0 & 0x7FF) * 8) | (unksp32 & 7);
                temp_t5_3 = ((((u32) (var_v1->unk0 * 4) >> 0x1F) * 4) & 4) | (unksp33 & 0xFFFB);
                unksp33 = temp_t5_3;
                temp_t4 = ((((u32) (var_v1->unk0 * 2) >> 0x1F) * 2) & 2) | (temp_t5_3 & 0xFD);
                unksp33 = temp_t4;
                unksp33 = (((u32) var_v1->unk0 >> 0x1F) & 1) | (temp_t4 & 0xFE);
                sp30 = ((u32) sp30 << 0x18) | (((u32) sp30 << 8) & 0xFF0000) | (((u32) sp30 >> 8) & 0xFF00) | ((u32) sp30 >> 0x18);
                var_v1->unk0 = sp30.unk0;
                var_v1->unk4 = (s32) sp30.unk4;
                var_v1->unk8 = (s32) sp30.unk8;
                var_v1->unkC = (u32) sp30.unkC;
            }
            var_v1 += 0x10;
        } while (var_a3 != arg1);
    }
}

void swap_pd(? *arg0, s32 arg1, s32 arg2) {
    ? *var_v1;
    s16 temp_t4;
    s16 temp_t6;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a0_4;
    s32 temp_a0_5;
    s32 temp_a0_6;
    s32 temp_a0_7;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a2_5;
    s32 temp_t4_2;
    s32 var_v0;
    u32 temp_a0;

    var_v0 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            temp_a0 = var_v1->unk0;
            temp_a2 = var_v1->unk4;
            temp_a0_2 = var_v1->unk8;
            var_v1->unk0 = (temp_a0 >> 0x18) | (temp_a0 << 0x18) | ((temp_a0 << 8) & 0xFF0000) | ((temp_a0 >> 8) & 0xFF00);
            temp_a2_2 = var_v1->unkC;
            var_v1->unk4 = (s32) (((u32) temp_a2 >> 0x18) | ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00)));
            temp_a0_3 = var_v1->unk10;
            var_v1->unk8 = (s32) (((u32) temp_a0_2 >> 0x18) | ((temp_a0_2 << 0x18) | ((temp_a0_2 << 8) & 0xFF0000) | ((temp_a0_2 >> 8) & 0xFF00)));
            temp_a2_3 = var_v1->unk14;
            var_v1->unkC = (s32) (((u32) temp_a2_2 >> 0x18) | ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00)));
            temp_a0_4 = var_v1->unk18;
            var_v1->unk10 = (s32) (((u32) temp_a0_3 >> 0x18) | ((temp_a0_3 << 0x18) | ((temp_a0_3 << 8) & 0xFF0000) | ((temp_a0_3 >> 8) & 0xFF00)));
            temp_a2_4 = var_v1->unk1C;
            var_v1->unk14 = (s32) (((u32) temp_a2_3 >> 0x18) | ((temp_a2_3 << 0x18) | ((temp_a2_3 << 8) & 0xFF0000) | ((temp_a2_3 >> 8) & 0xFF00)));
            temp_a0_5 = var_v1->unk20;
            var_v1->unk18 = (s32) (((u32) temp_a0_4 >> 0x18) | ((temp_a0_4 << 0x18) | ((temp_a0_4 << 8) & 0xFF0000) | ((temp_a0_4 >> 8) & 0xFF00)));
            var_v1->unk1C = (s32) (((u32) temp_a2_4 >> 0x18) | ((temp_a2_4 << 0x18) | ((temp_a2_4 << 8) & 0xFF0000) | ((temp_a2_4 >> 8) & 0xFF00)));
            temp_t6 = var_v1->unk24;
            var_v1->unk20 = (s32) (((u32) temp_a0_5 >> 0x18) | ((temp_a0_5 << 0x18) | ((temp_a0_5 << 8) & 0xFF0000) | ((temp_a0_5 >> 8) & 0xFF00)));
            temp_t4 = var_v1->unk26;
            temp_a0_6 = var_v1->unk28;
            var_v1->unk24 = (s16) (((u32) (temp_t6 & 0xFFFF) >> 8) | (temp_t6 << 8));
            temp_a2_5 = var_v1->unk2C;
            var_v1->unk26 = (s16) (((u32) (temp_t4 & 0xFFFF) >> 8) | (temp_t4 << 8));
            temp_a0_7 = var_v1->unk30;
            var_v1->unk28 = (s32) (((u32) temp_a0_6 >> 0x18) | ((temp_a0_6 << 0x18) | ((temp_a0_6 << 8) & 0xFF0000) | ((temp_a0_6 >> 8) & 0xFF00)));
            var_v1->unk2C = (s32) (((u32) temp_a2_5 >> 0x18) | ((temp_a2_5 << 0x18) | ((temp_a2_5 << 8) & 0xFF0000) | ((temp_a2_5 >> 8) & 0xFF00)));
            var_v0 += 1;
            temp_t4_2 = ((u32) temp_a0_7 >> 0x18) | ((temp_a0_7 << 0x18) | ((temp_a0_7 << 8) & 0xFF0000) | ((temp_a0_7 >> 8) & 0xFF00));
            var_v1 += 0x34;
            var_v1->unk-4 = temp_t4_2;
        } while (var_v0 != arg1);
    }
}

void swap_dn(? *arg0, s32 arg1, s32 arg2) {
    s32 temp_t6;
    s32 var_v0;
    u32 temp_a0;
    u32 temp_a2;
    u32 temp_a2_2;
    u32 temp_a3;
    u32 temp_a3_2;
    u32 temp_v0;
    void *var_v1;

    var_v0 = 0;
    if ((arg1 > 0) && (!(arg1 & 1) || (temp_a2 = arg0->unk0, temp_a3 = arg0->unk4, arg0->unk0 = (temp_a2 >> 0x18) | (temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00), var_v0 = 1, arg0->unk4 = (u32) ((temp_a3 >> 0x18) | (temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00)), (arg1 != 1)))) {
        var_v1 = arg0 + (var_v0 * 8);
        do {
            temp_v0 = var_v1->unk0;
            temp_a0 = var_v1->unk4;
            temp_a2_2 = var_v1->unk8;
            var_v1->unk0 = (u32) ((temp_v0 >> 0x18) | (temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00));
            temp_a3_2 = var_v1->unkC;
            var_v1->unk4 = (u32) ((temp_a0 >> 0x18) | (temp_a0 << 0x18) | ((temp_a0 << 8) & 0xFF0000) | ((temp_a0 >> 8) & 0xFF00));
            var_v1->unk8 = (u32) ((temp_a2_2 >> 0x18) | (temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00));
            temp_t6 = (temp_a3_2 >> 0x18) | (temp_a3_2 << 0x18) | ((temp_a3_2 << 8) & 0xFF0000) | ((temp_a3_2 >> 8) & 0xFF00);
            var_v1 += 0x10;
            var_v1->unk-4 = temp_t6;
        } while (var_v1 != ((arg1 * 8) + arg0));
    }
}

void swap_rpd(void *arg0, s32 arg1, ? arg2) {
    s16 temp_a0_4;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a0_5;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_t5;
    s32 var_v0;
    u32 temp_a0;
    void *var_v1;

    var_v0 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            temp_a0 = var_v1->unk0;
            temp_a2 = var_v1->unk4;
            temp_a0_2 = var_v1->unk8;
            var_v1->unk0 = (u32) ((temp_a0 >> 0x18) | (temp_a0 << 0x18) | ((temp_a0 << 8) & 0xFF0000) | ((temp_a0 >> 8) & 0xFF00));
            temp_a2_2 = var_v1->unkC;
            var_v1->unk4 = (s32) (((u32) temp_a2 >> 0x18) | ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00)));
            temp_a0_3 = var_v1->unk10;
            var_v1->unk8 = (s32) (((u32) temp_a0_2 >> 0x18) | ((temp_a0_2 << 0x18) | ((temp_a0_2 << 8) & 0xFF0000) | ((temp_a0_2 >> 8) & 0xFF00)));
            temp_a2_3 = var_v1->unk14;
            var_v1->unkC = (s32) (((u32) temp_a2_2 >> 0x18) | ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00)));
            temp_a0_4 = var_v1->unk18;
            var_v1->unk10 = (s32) (((u32) temp_a0_3 >> 0x18) | ((temp_a0_3 << 0x18) | ((temp_a0_3 << 8) & 0xFF0000) | ((temp_a0_3 >> 8) & 0xFF00)));
            temp_a2_4 = var_v1->unk1C;
            var_v1->unk14 = (s32) (((u32) temp_a2_3 >> 0x18) | ((temp_a2_3 << 0x18) | ((temp_a2_3 << 8) & 0xFF0000) | ((temp_a2_3 >> 8) & 0xFF00)));
            temp_a0_5 = var_v1->unk24;
            var_v1->unk18 = (s16) (((u32) temp_a0_4 >> 0x18) | ((temp_a0_4 << 0x18) | ((temp_a0_4 << 8) & 0xFF0000) | ((temp_a0_4 >> 8) & 0xFF00)));
            var_v1->unk1C = (s32) (((u32) temp_a2_4 >> 0x18) | ((temp_a2_4 << 0x18) | ((temp_a2_4 << 8) & 0xFF0000) | ((temp_a2_4 >> 8) & 0xFF00)));
            var_v0 += 1;
            temp_t5 = ((u32) temp_a0_5 >> 0x18) | ((temp_a0_5 << 0x18) | ((temp_a0_5 << 8) & 0xFF0000) | ((temp_a0_5 >> 8) & 0xFF00));
            var_v1 += 0x28;
            var_v1->unk-4 = temp_t5;
        } while (var_v0 != arg1);
    }
}

void swap_opt(? *arg0, s32 arg1, s32 arg2) {
    u32 sp34;
    u32 sp30;
    u32 sp2C;                                       /* compiler-managed */
    ? *var_v1;
    s32 temp_v0;
    s32 var_t0;
    u32 temp_a0;
    u32 temp_a1;
    u32 temp_t8;

    temp_v0 = gethostsex();
    var_t0 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            var_t0 += 1;
            sp2C.unk0 = var_v1->unk0;
            sp2C.unk4 = (u32) var_v1->unk4;
            sp2C.unk8 = (s32) var_v1->unk8;
            sp34 = (sp34 << 0x18) | ((sp34 << 8) & 0xFF0000) | ((sp34 >> 8) & 0xFF00) | (sp34 >> 0x18);
            if (arg2 == temp_v0) {
                var_v1->unk0 = sp2C.unk0;
                var_v1->unk4 = (u32) sp2C.unk4;
                var_v1->unk8 = (s32) sp2C.unk8;
                sp2C = (sp2C << 0x18) | ((sp2C << 8) & 0xFF0000) | ((sp2C >> 8) & 0xFF00) | (sp2C >> 0x18);
                sp30 = (sp30 << 0x18) | ((sp30 << 8) & 0xFF0000) | ((sp30 >> 8) & 0xFF00) | (sp30 >> 0x18);
                var_v1->unk0 = (u8) sp2C;
                temp_a0 = var_v1->unk0;
                var_v1->unk0 = ((u32) (((sp2C & 0xFFFFFF) ^ temp_a0) << 8) >> 8) ^ temp_a0;
                temp_a1 = var_v1->unk4;
                var_v1->unk4 = (u32) (((u32) (((sp30 >> 0xC) ^ temp_a1) << 0xC) >> 0xC) ^ temp_a1);
                var_v1->unk4 = (s16) ((sp30 * 0x10) | ((u16) var_v1->unk4 & 0xF));
            } else {
                sp2C = (u8) var_v1->unk0;
                temp_t8 = ((u32) (((var_v1->unk0 & 0xFFFFFF) ^ (s32) sp2C) << 8) >> 8) ^ (s32) sp2C;
                sp2C = temp_t8;
                sp30 ^= ((var_v1->unk4 & 0xFFFFF) ^ (sp30 >> 0xC)) << 0xC;
                unksp32 = (((u32) var_v1->unk4 >> 0x14) & 0xFFF) | (unksp32 & 0xF000);
                sp2C = (temp_t8 << 0x18) | ((temp_t8 << 8) & 0xFF0000) | ((temp_t8 >> 8) & 0xFF00) | (temp_t8 >> 0x18);
                sp30 = (sp30 << 0x18) | ((sp30 << 8) & 0xFF0000) | ((sp30 >> 8) & 0xFF00) | (sp30 >> 0x18);
                var_v1->unk0 = sp2C.unk0;
                var_v1->unk4 = (u32) sp2C.unk4;
                var_v1->unk8 = (s32) sp2C.unk8;
            }
            var_v1 += 0xC;
        } while (var_t0 != arg1);
    }
}

void swap_aux(void *arg0, u32 arg1, s32 arg2) {
    u32 sp2C;
    u32 sp24;
    s8 temp_t2;
    s8 temp_t8;
    u32 temp_t1;
    u32 temp_t4;
    u32 temp_v0;
    u32 temp_v0_2;
    u8 temp_t1_2;
    u8 temp_t3;
    u8 temp_t6;

    if (arg2 != gethostsex()) {
        fprintf(&__iob + 0x20, "swap of auxs not supported when destsex != hostsex\n");
        return;
    }
    switch (arg1) {
    case 0:
        sp2C = arg0->unk0;
        temp_t1 = (sp2C << 0x18) | ((sp2C << 8) & 0xFF0000) | ((sp2C >> 8) & 0xFF00) | (sp2C >> 0x18);
        sp2C = temp_t1;
        temp_t1_2 = ((temp_t1 >> 0x1C) & 0xF) | (arg0->unk3 & 0xFFF0);
        arg0->unk3 = temp_t1_2;
        arg0->unk3 = (u8) (((u8) sp2C * 0x10) | (temp_t1_2 & 0xF));
        temp_t3 = ((unksp2D >> 4) & 0xF) | (arg0->unk2 & 0xFFF0);
        arg0->unk2 = temp_t3;
        arg0->unk2 = (u8) (((u16) sp2C * 0x10) | (temp_t3 & 0xF));
        temp_t6 = ((unksp2E >> 0xC) & 0xF) | (arg0->unk1 & 0xFFF0);
        arg0->unk1 = temp_t6;
        arg0->unk1 = (u8) ((unksp2E * 0x10) | (temp_t6 & 0xF));
        temp_t8 = ((unksp2F >> 2) & 0x3F) | ((u8) arg0->unk0 & 0xFFC0);
        arg0->unk0 = temp_t8;
        temp_t2 = ((((u32) (sp2C << 0x1E) >> 0x1F) << 6) & 0x40) | (temp_t8 & 0xBF);
        arg0->unk0 = temp_t2;
        arg0->unk0 = (s8) ((sp2C << 7) | (temp_t2 & 0x7F));
        return;
    case 1:
        sp24 = arg0->unk0;
        temp_t4 = (sp24 << 0x18) | ((sp24 << 8) & 0xFF0000) | ((sp24 >> 8) & 0xFF00) | (sp24 >> 0x18);
        sp24 = temp_t4;
        temp_v0 = arg0->unk0;
        arg0->unk0 = (u32) (((u32) (((temp_t4 >> 0xC) ^ temp_v0) << 0xC) >> 0xC) ^ temp_v0);
        arg0->unk0 = (s16) (((sp24 * 0x10) & 0xFFF0) | ((u16) arg0->unk0 & 0xF));
        return;
    default:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        temp_v0_2 = arg0->unk0;
        arg0->unk0 = (u32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | (((s32) temp_v0_2 >> 8) & 0xFF00) | (temp_v0_2 >> 0x18));
        return;
    }
}

void swap_reloc(void *arg0, s32 arg1, s32 arg2) {
    u32 sp34;                                       /* compiler-managed */
    s32 sp30;
    s32 temp_v0;
    s32 var_a2;
    s8 temp_t2;
    s8 temp_t7;
    u32 temp_a0;
    u32 temp_t3;
    u32 temp_t5;
    u8 temp_t1;
    u8 temp_t1_2;
    void *var_v1;

    temp_v0 = gethostsex();
    var_a2 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            var_a2 += 1;
            sp30.unk0 = var_v1->unk0;
            sp30.unk4 = (u32) var_v1->unk4;
            sp30 = (sp30 << 0x18) | ((sp30 << 8) & 0xFF0000) | ((sp30 >> 8) & 0xFF00) | ((u32) sp30 >> 0x18);
            if (arg2 == temp_v0) {
                var_v1->unk0 = (s32) sp30.unk0;
                var_v1->unk4 = (u32) sp30.unk4;
                temp_t5 = (sp34 << 0x18) | ((sp34 << 8) & 0xFF0000) | ((sp34 >> 8) & 0xFF00) | (sp34 >> 0x18);
                sp34 = temp_t5;
                temp_t1 = ((temp_t5 >> 0x1F) & 1) | (var_v1->unk7 & 0xFFFE);
                var_v1->unk7 = temp_t1;
                temp_t1_2 = ((((u32) (sp34 * 2) >> 0x1C) * 2) & 0x3E) | (temp_t1 & 0xC1);
                var_v1->unk7 = temp_t1_2;
                var_v1->unk7 = (u8) (((u8) sp34 << 6) | (temp_t1_2 & 0x3F));
                temp_a0 = var_v1->unk4;
                var_v1->unk4 = (u32) ((((sp34 & 0xFFFFFF) ^ (temp_a0 >> 8)) << 8) ^ temp_a0);
            } else {
                temp_t2 = (var_v1->unk4 << 7) | ((u8) sp34 & 0xFF7F);
                sp34 = temp_t2;
                temp_t7 = ((((u32) (var_v1->unk4 << 0x1A) >> 0x1B) * 8) & 0x78) | (temp_t2 & 0x87);
                sp34 = temp_t7;
                sp34 = (((u8) var_v1->unk7 >> 6) & 7) | (temp_t7 & 0xF8);
                temp_t3 = ((u32) ((((u32) var_v1->unk4 >> 8) ^ (s32) sp34) << 8) >> 8) ^ (s32) sp34;
                sp34 = temp_t3;
                sp34 = (temp_t3 << 0x18) | ((temp_t3 << 8) & 0xFF0000) | ((temp_t3 >> 8) & 0xFF00) | (temp_t3 >> 0x18);
                var_v1->unk0 = (s32) sp30.unk0;
                var_v1->unk4 = (u32) sp30.unk4;
            }
            var_v1 += 8;
        } while (var_a2 != arg1);
    }
}

void swap_ranlib(void *arg0, s32 arg1) {
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_t2;
    s32 temp_t4;
    s32 var_v0;
    void *var_v1;

    var_v0 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            temp_a0 = var_v1->unk0;
            temp_a2 = var_v1->unk4;
            temp_t4 = ((u32) temp_a0 >> 0x18) | ((temp_a0 << 0x18) | ((temp_a0 << 8) & 0xFF0000) | ((temp_a0 >> 8) & 0xFF00));
            var_v0 += 1;
            temp_t2 = ((u32) temp_a2 >> 0x18) | ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00));
            var_v1 += 8;
            var_v1->unk-8 = temp_t4;
            var_v1->unk-4 = temp_t2;
        } while (var_v0 != arg1);
    }
}

void swap_gpt(void *arg0, s32 arg1, ? arg2) {
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_t2;
    s32 temp_t4;
    s32 var_v0;
    void *var_v1;

    var_v0 = 0;
    if (arg1 > 0) {
        var_v1 = arg0;
        do {
            temp_a0 = var_v1->unk0;
            temp_a2 = var_v1->unk4;
            temp_t4 = ((u32) temp_a0 >> 0x18) | ((temp_a0 << 0x18) | ((temp_a0 << 8) & 0xFF0000) | ((temp_a0 >> 8) & 0xFF00));
            var_v0 += 1;
            temp_t2 = ((u32) temp_a2 >> 0x18) | ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00));
            var_v1 += 8;
            var_v1->unk-8 = temp_t4;
            var_v1->unk-4 = temp_t2;
        } while (var_v0 != arg1);
    }
}

void swap_dynamic(void *arg0, ? arg1) {
    s32 temp_v0;
    u32 temp_t3;
    u32 temp_v1;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_t3 = (temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18);
    arg0->unk0 = (s32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | ((u32) temp_v0 >> 0x18));
    arg0->unk4 = temp_t3;
    arg0->unk4 = (u32) ((temp_t3 << 0x18) | ((temp_t3 << 8) & 0xFF0000) | ((temp_t3 >> 8) & 0xFF00) | (temp_t3 >> 0x18));
}

void swap_rel_dyn(void *arg0, ? arg1) {
    u32 temp_v0;
    u32 temp_v1;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    arg0->unk4 = (u32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18));
}

void swap_reginfo(void *arg0, ? arg1) {
    s32 temp_v1_2;
    u32 temp_a1;
    u32 temp_a2;
    u32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_a1 = arg0->unk8;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    temp_a2 = arg0->unkC;
    arg0->unk4 = (u32) ((temp_v1 >> 0x18) | (temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00));
    temp_v0_2 = arg0->unk10;
    arg0->unk8 = (u32) ((temp_a1 >> 0x18) | (temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00));
    temp_v1_2 = arg0->unk14;
    arg0->unkC = (u32) ((temp_a2 >> 0x18) | (temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00));
    arg0->unk10 = (u32) ((temp_v0_2 >> 0x18) | (temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00));
    arg0->unk14 = (s32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | ((u32) temp_v1_2 >> 0x18));
}

void swap_dynsym(void *arg0, ? arg1) {
    u16 temp_t3;
    u32 temp_a1;
    u32 temp_v0;
    u32 temp_v1;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_a1 = arg0->unk8;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    arg0->unk4 = (u32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18));
    temp_t3 = arg0->unkE;
    arg0->unk8 = (u32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | (temp_a1 >> 0x18));
    arg0->unkE = (u16) ((temp_t3 << 8) | (temp_t3 >> 8));
}

void swap_conflict(u32 *arg0, ? arg1) {
    u32 temp_v0;

    temp_v0 = *arg0;
    *arg0 = (temp_v0 >> 0x18) | (temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00);
}

void swap_got(u32 *arg0, ? arg1) {
    u32 temp_v0;

    temp_v0 = *arg0;
    *arg0 = (temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18);
}

void swap_liblist(void *arg0, ? arg1) {
    u32 temp_a1;
    u32 temp_a2;
    u32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_a1 = arg0->unk8;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    temp_a2 = arg0->unkC;
    arg0->unk4 = (u32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18));
    temp_v0_2 = arg0->unk10;
    arg0->unk8 = (u32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | (temp_a1 >> 0x18));
    arg0->unkC = (u32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | (temp_a2 >> 0x18));
    arg0->unk10 = (u32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | (temp_v0_2 >> 0x18));
}

void swap_msym(void *arg0, ? arg1) {
    u32 temp_v0;
    u32 temp_v1;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    arg0->unk4 = (u32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18));
}

void swap_ehdr(void *arg0) {
    u16 temp_a1_2;
    u16 temp_a2_2;
    u16 temp_a3_2;
    u16 temp_t0;
    u16 temp_t8;
    u16 temp_v0;
    u16 temp_v0_3;
    u16 temp_v1;
    u32 temp_a1;
    u32 temp_a2;
    u32 temp_a3;
    u32 temp_v0_2;
    u32 temp_v1_2;

    temp_v0 = arg0->unk10;
    temp_v1 = arg0->unk12;
    temp_a1 = arg0->unk14;
    arg0->unk10 = (u16) ((temp_v0 << 8) | (temp_v0 >> 8));
    temp_a2 = arg0->unk18;
    arg0->unk12 = (u16) ((temp_v1 << 8) | (temp_v1 >> 8));
    temp_a3 = arg0->unk1C;
    arg0->unk14 = (u32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | (temp_a1 >> 0x18));
    temp_v0_2 = arg0->unk20;
    arg0->unk18 = (u32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | (temp_a2 >> 0x18));
    temp_v1_2 = arg0->unk24;
    arg0->unk1C = (u32) ((temp_a3 << 0x18) | ((temp_a3 << 8) & 0xFF0000) | ((temp_a3 >> 8) & 0xFF00) | (temp_a3 >> 0x18));
    arg0->unk20 = (u32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | (temp_v0_2 >> 0x18));
    temp_a1_2 = arg0->unk28;
    temp_a2_2 = arg0->unk2A;
    arg0->unk24 = (u32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | (temp_v1_2 >> 0x18));
    temp_a3_2 = arg0->unk2C;
    temp_t0 = arg0->unk2E;
    arg0->unk28 = (u16) ((temp_a1_2 << 8) | (temp_a1_2 >> 8));
    arg0->unk2A = (u16) ((temp_a2_2 << 8) | (temp_a2_2 >> 8));
    temp_v0_3 = arg0->unk30;
    temp_t8 = arg0->unk32;
    arg0->unk2C = (u16) ((temp_a3_2 << 8) | (temp_a3_2 >> 8));
    arg0->unk2E = (u16) ((temp_t0 << 8) | (temp_t0 >> 8));
    arg0->unk30 = (u16) (((temp_v0_3 & 0xFF) << 8) | (temp_v0_3 >> 8));
    arg0->unk32 = (u16) ((temp_t8 << 8) | (temp_t8 >> 8));
}

void swap_phdr(void *arg0) {
    u32 temp_a1;
    u32 temp_a1_2;
    u32 temp_a2;
    u32 temp_a2_2;
    u32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v1;
    u32 temp_v1_2;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_a1 = arg0->unk8;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    temp_a2 = arg0->unkC;
    arg0->unk4 = (u32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18));
    temp_v0_2 = arg0->unk10;
    arg0->unk8 = (u32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | (temp_a1 >> 0x18));
    temp_v1_2 = arg0->unk14;
    arg0->unkC = (u32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | (temp_a2 >> 0x18));
    temp_a1_2 = arg0->unk18;
    arg0->unk10 = (u32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | (temp_v0_2 >> 0x18));
    temp_a2_2 = arg0->unk1C;
    arg0->unk14 = (u32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | (temp_v1_2 >> 0x18));
    arg0->unk18 = (u32) ((temp_a1_2 << 0x18) | ((temp_a1_2 << 8) & 0xFF0000) | ((temp_a1_2 >> 8) & 0xFF00) | (temp_a1_2 >> 0x18));
    arg0->unk1C = (u32) ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00) | (temp_a2_2 >> 0x18));
}

void swap_shdr(void *arg0) {
    u32 temp_a1;
    u32 temp_a1_2;
    u32 temp_a2;
    u32 temp_a2_2;
    u32 temp_v0;
    u32 temp_v0_2;
    u32 temp_v0_3;
    u32 temp_v1;
    u32 temp_v1_2;
    u32 temp_v1_3;

    temp_v0 = arg0->unk0;
    temp_v1 = arg0->unk4;
    temp_a1 = arg0->unk8;
    arg0->unk0 = (u32) ((temp_v0 << 0x18) | ((temp_v0 << 8) & 0xFF0000) | ((temp_v0 >> 8) & 0xFF00) | (temp_v0 >> 0x18));
    temp_a2 = arg0->unkC;
    arg0->unk4 = (u32) ((temp_v1 << 0x18) | ((temp_v1 << 8) & 0xFF0000) | ((temp_v1 >> 8) & 0xFF00) | (temp_v1 >> 0x18));
    temp_v0_2 = arg0->unk10;
    arg0->unk8 = (u32) ((temp_a1 << 0x18) | ((temp_a1 << 8) & 0xFF0000) | ((temp_a1 >> 8) & 0xFF00) | (temp_a1 >> 0x18));
    temp_v1_2 = arg0->unk14;
    arg0->unkC = (u32) ((temp_a2 << 0x18) | ((temp_a2 << 8) & 0xFF0000) | ((temp_a2 >> 8) & 0xFF00) | (temp_a2 >> 0x18));
    temp_a1_2 = arg0->unk18;
    arg0->unk10 = (u32) ((temp_v0_2 << 0x18) | ((temp_v0_2 << 8) & 0xFF0000) | ((temp_v0_2 >> 8) & 0xFF00) | (temp_v0_2 >> 0x18));
    temp_a2_2 = arg0->unk1C;
    arg0->unk14 = (u32) ((temp_v1_2 << 0x18) | ((temp_v1_2 << 8) & 0xFF0000) | ((temp_v1_2 >> 8) & 0xFF00) | (temp_v1_2 >> 0x18));
    temp_v0_3 = arg0->unk20;
    arg0->unk18 = (u32) ((temp_a1_2 << 0x18) | ((temp_a1_2 << 8) & 0xFF0000) | ((temp_a1_2 >> 8) & 0xFF00) | (temp_a1_2 >> 0x18));
    temp_v1_3 = arg0->unk24;
    arg0->unk1C = (u32) ((temp_a2_2 << 0x18) | ((temp_a2_2 << 8) & 0xFF0000) | ((temp_a2_2 >> 8) & 0xFF00) | (temp_a2_2 >> 0x18));
    arg0->unk20 = (u32) ((temp_v0_3 << 0x18) | ((temp_v0_3 << 8) & 0xFF0000) | ((temp_v0_3 >> 8) & 0xFF00) | (temp_v0_3 >> 0x18));
    arg0->unk24 = (u32) ((temp_v1_3 << 0x18) | ((temp_v1_3 << 8) & 0xFF0000) | ((temp_v1_3 >> 8) & 0xFF00) | (temp_v1_3 >> 0x18));
}

s32 ldfsymorder(s16 *arg0, s32 arg1) {
    s32 temp_a1;
    s32 temp_a1_10;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a1_5;
    s32 temp_a1_6;
    s32 temp_a1_7;
    s32 temp_a1_8;
    s32 temp_a1_9;
    s32 temp_a2;
    s32 temp_v0;
    s32 temp_v1;
    s32 temp_v1_10;
    s32 temp_v1_11;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 temp_v1_7;
    s32 temp_v1_8;
    s32 temp_v1_9;

    temp_a2 = arg0->unkC;
    temp_v0 = arg1 + 0x60;
    if ((temp_a2 != 0) && (arg0->unk8 != 0) && (temp_v0 != temp_a2)) {
        return 0;
    }
    temp_v1_2 = arg0->unk8;
    if (temp_v1_2 & 3) {
        return 0;
    }
    temp_a1 = arg0->unk1C;
    if ((temp_a1 != 0) && (arg0->unk18 != 0) && ((temp_v0 + temp_v1_2) != temp_a1)) {
        return 0;
    }
    temp_v1_3 = temp_v1_2 + (arg0->unk18 * 0x34);
    if (temp_v1_3 & 3) {
        return 0;
    }
    temp_a1_2 = arg0->unk24;
    if ((temp_a1_2 != 0) && (arg0->unk20 != 0) && ((temp_v0 + temp_v1_3) != temp_a1_2)) {
        return 0;
    }
    temp_v1_4 = temp_v1_3 + (arg0->unk20 * 0xC);
    if (temp_v1_4 & 3) {
        return 0;
    }
    temp_a1_3 = arg0->unk2C;
    if ((temp_a1_3 != 0) && (arg0->unk28 != 0) && ((temp_v0 + temp_v1_4) != temp_a1_3)) {
        return 0;
    }
    temp_v1_5 = temp_v1_4 + (arg0->unk28 * 0xC);
    if (temp_v1_5 & 3) {
        return 0;
    }
    temp_a1_4 = arg0->unk34;
    if ((temp_a1_4 != 0) && (arg0->unk30 != 0) && ((temp_v0 + temp_v1_5) != temp_a1_4)) {
        return 0;
    }
    temp_v1_6 = temp_v1_5 + (arg0->unk30 * 4);
    if (temp_v1_6 & 3) {
        return 0;
    }
    temp_a1_5 = arg0->unk3C;
    if ((temp_a1_5 != 0) && (arg0->unk38 != 0) && ((temp_v0 + temp_v1_6) != temp_a1_5)) {
        return 0;
    }
    temp_v1_7 = temp_v1_6 + arg0->unk38;
    if (temp_v1_7 & 3) {
        return 0;
    }
    temp_a1_6 = arg0->unk44;
    if ((temp_a1_6 != 0) && (arg0->unk40 != 0) && ((temp_v0 + temp_v1_7) != temp_a1_6)) {
        return 0;
    }
    temp_v1_8 = temp_v1_7 + arg0->unk40;
    if (temp_v1_8 & 3) {
        return 0;
    }
    temp_a1_7 = arg0->unk4C;
    if ((temp_a1_7 != 0) && (arg0->unk48 != 0) && ((temp_v0 + temp_v1_8) != temp_a1_7)) {
        return 0;
    }
    temp_v1_9 = temp_v1_8 + (arg0->unk48 * 0x48);
    if (temp_v1_9 & 3) {
        return 0;
    }
    temp_a1_8 = arg0->unk54;
    if ((temp_a1_8 != 0) && (arg0->unk50 != 0) && ((temp_v0 + temp_v1_9) != temp_a1_8)) {
        return 0;
    }
    temp_v1_10 = temp_v1_9 + (arg0->unk50 * 4);
    if (temp_v1_10 & 3) {
        return 0;
    }
    temp_a1_9 = arg0->unk5C;
    if ((temp_a1_9 != 0) && (arg0->unk58 != 0) && ((temp_v0 + temp_v1_10) != temp_a1_9)) {
        return 0;
    }
    temp_v1_11 = temp_v1_10 + (arg0->unk58 * 0x10);
    if (temp_v1_11 & 3) {
        return 0;
    }
    temp_a1_10 = arg0->unk14;
    if ((temp_a1_10 != 0) && (arg0->unk10 != 0) && ((temp_v0 + temp_v1_11) != temp_a1_10)) {
        return 0;
    }
    temp_v1 = temp_v1_11 + (arg0->unk10 * 8);
    if (temp_v1 & 3) {
        return 0;
    }
    return temp_v1;
}

void xrealloc(void) {
    alloc_resize(&malloc_scb);
}

void xfree(void) {

}

void alloc_dispose(? **arg0, s32 **arg1) {
    s32 *temp_t0;
    s32 *var_a3;
    s32 *var_t4;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_4;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a2;
    s32 temp_t1_2;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 var_t7;
    s32 var_t7_2;
    s32 var_t8;
    s32 var_t8_2;
    s32 var_v0;
    s32 var_v1;
    void *temp_a0_3;
    void *temp_a0_5;
    void *temp_t1;
    void *temp_t2_2;
    void *temp_t2_3;
    void *temp_t2_4;
    void *temp_t2_5;
    void *temp_t4;
    void *temp_t5;
    void *temp_t5_2;
    void *temp_t5_3;
    void *temp_t5_4;
    void *temp_t5_5;
    void *temp_t5_6;

    temp_t0 = *arg1;
    temp_a2 = arg0 - 8;
    var_a3 = temp_t0;
    if (temp_t0->unk0 != 0) {
        if (var_a3 != NULL) {
            if (temp_a2 >= (s32) var_a3) {
                temp_v1 = var_a3->unkC;
                var_t8 = temp_v1;
                if (temp_v1 < 0) {
                    var_t8 = -temp_v1;
                }
                if ((s32) (var_a3 + var_t8) < temp_a2) {
                    goto loop_6;
                }
            } else {
loop_6:
                var_a3 = var_a3->unk4;
                if (var_a3 != NULL) {
                    if (temp_a2 >= (s32) var_a3) {
                        temp_t6 = var_a3->unkC;
                        var_t7 = temp_t6;
                        if (temp_t6 < 0) {
                            var_t7 = -temp_t6;
                        }
                        if ((s32) (var_a3 + var_t7) < temp_a2) {
                            goto loop_6;
                        }
                    } else {
                        goto loop_6;
                    }
                }
            }
        }
        if (var_a3 == NULL) {
            var_a3 = temp_t0;
            if (var_a3 != NULL) {
                if (temp_a2 >= (s32) var_a3) {
                    temp_v1_2 = var_a3->unkC;
                    var_t8_2 = temp_v1_2;
                    if (temp_v1_2 < 0) {
                        var_t8_2 = -temp_v1_2;
                    }
                    if ((s32) (var_a3 + var_t8_2) < temp_a2) {
                        goto loop_17;
                    }
                } else {
loop_17:
                    var_a3 = *var_a3;
                    if (var_a3 != NULL) {
                        if (temp_a2 >= (s32) var_a3) {
                            temp_t6_2 = var_a3->unkC;
                            var_t7_2 = temp_t6_2;
                            if (temp_t6_2 < 0) {
                                var_t7_2 = -temp_t6_2;
                            }
                            if ((s32) (var_a3 + var_t7_2) < temp_a2) {
                                goto loop_17;
                            }
                        } else {
                            goto loop_17;
                        }
                    }
                }
            }
            if (var_a3 != NULL) {
                goto block_23;
            }
        } else {
block_23:
            if (var_a3->unkC < 0) {
                do {
                    var_a3 = *var_a3;
                } while (var_a3->unkC < 0);
            }
            goto block_25;
        }
    } else {
block_25:
        temp_a0 = temp_a2->unk4;
        temp_a1 = temp_a0 & ~3;
        temp_t1 = temp_a2 + temp_a1;
        temp_t2 = temp_t1->unk4;
        temp_t3 = temp_t2 & ~3;
        if (!(temp_a0 & 2)) {
            temp_t1_2 = temp_a2->unk0;
            temp_t4 = temp_a2 - temp_t1_2;
            if (!(temp_t2 & 1)) {
                temp_a0_2 = temp_t1_2 + temp_a1 + temp_t3;
                temp_t2_2 = var_a3->unk8;
                if (temp_a0_2 >= 0x100) {
                    var_v0 = temp_a0_2 + 2;
                    if (temp_t1_2 < 0x100) {
                        temp_t5 = temp_t2_2->unk8;
                        temp_t4->unkC = temp_t2_2;
                        temp_t4->unk8 = temp_t5;
                        temp_t5->unkC = temp_t4;
                        temp_t2_2->unk8 = temp_t4;
                        goto block_30;
                    }
                } else {
block_30:
                    var_v0 = temp_a0_2 + 2;
                }
                temp_t4->unk4 = var_v0;
                *(temp_t4 + temp_a0_2) = temp_a0_2;
                if (temp_t3 >= 0x100) {
                    temp_t5_2 = temp_t1->unkC;
                    temp_a0_3 = temp_t1->unk8;
                    temp_a0_3->unkC = temp_t5_2;
                    temp_t5_2->unk8 = temp_a0_3;
                    if (temp_t2_2 == temp_t1) {
                        var_a3->unk8 = temp_t5_2;
                    }
                }
            } else {
                temp_a0_4 = temp_t1_2 + temp_a1;
                if (temp_a0_4 >= 0x100) {
                    var_v1 = temp_a0_4 + 2;
                    if (temp_t1_2 < 0x100) {
                        temp_t2_3 = var_a3->unk8;
                        temp_t5_3 = temp_t2_3->unk8;
                        temp_t4->unkC = temp_t2_3;
                        temp_t4->unk8 = temp_t5_3;
                        temp_t5_3->unkC = temp_t4;
                        temp_t2_3->unk8 = temp_t4;
                        goto block_37;
                    }
                } else {
block_37:
                    var_v1 = temp_a0_4 + 2;
                }
                temp_t4->unk4 = var_v1;
                temp_t1->unk4 = (s32) (temp_t3 + 1);
                *(temp_t4 + temp_a0_4) = temp_a0_4;
            }
        } else {
            if (!(temp_t2 & 1)) {
                temp_a1_2 = temp_a1 + temp_t3;
                temp_t2_4 = var_a3->unk8;
                var_t4 = temp_a2 + temp_a1_2;
                if (temp_a1_2 >= 0x100) {
                    temp_t5_4 = temp_t2_4->unk8;
                    temp_a2->unkC = temp_t2_4;
                    temp_a2->unk8 = temp_t5_4;
                    temp_t5_4->unkC = temp_a2;
                    temp_t2_4->unk8 = (void *) temp_a2;
                    var_t4 = temp_a2 + temp_a1_2;
                }
                *var_t4 = temp_a1_2;
                temp_a2->unk4 = (s32) (temp_a1_2 + 2);
                if (temp_t3 >= 0x100) {
                    temp_t5_5 = temp_t1->unkC;
                    temp_a0_5 = temp_t1->unk8;
                    temp_a0_5->unkC = temp_t5_5;
                    temp_t5_5->unk8 = temp_a0_5;
                    if (temp_t2_4 == temp_t1) {
                        var_a3->unk8 = temp_t5_5;
                        return;
                    }
                }
                return;
            }
            if (temp_a1 >= 0x100) {
                temp_t2_5 = var_a3->unk8;
                temp_t5_6 = temp_t2_5->unk8;
                temp_a2->unkC = temp_t2_5;
                temp_a2->unk8 = temp_t5_6;
                temp_t5_6->unkC = temp_a2;
                temp_t2_5->unk8 = (void *) temp_a2;
            }
            temp_t1->unk0 = temp_a1;
            temp_a2->unk4 = (s32) (temp_a1 + 2);
            temp_t1->unk4 = (s32) (temp_t3 + 1);
        }
    }
}

/*
Decompilation failure in function xmalloc:

Unable to parse branch: label L0041E5FC does not exist in function xmalloc
*/

? *alloc_new(s32 arg0, ? **arg1) {
    ? *sp24;
    ? *var_t0;
    ? *var_v0;
    s32 temp_t2;
    s32 temp_t2_2;
    s32 temp_t2_3;
    s32 var_a0;
    s32 var_a0_2;
    s32 var_t2;
    void *temp_t3;
    void *temp_t3_2;
    void *temp_t3_3;
    void *temp_t3_4;
    void *temp_t3_5;
    void *temp_t4;
    void *var_t1;

    var_t0 = *arg1;
    var_a0 = arg0 + 0xF;
    if (var_t0 != NULL) {
        goto block_1;
    }
    arg0 = var_a0;
    var_v0 = alloc_mark(arg1);
    var_a0 = arg0;
    var_t0 = *arg1;
    if (var_v0 != NULL) {
block_1:
        var_t1 = var_t0->unk8;
        var_a0_2 = var_a0 & ~7;
        temp_t2 = var_t1->unk4;
        if (var_a0_2 < 0x10) {
            var_a0_2 = 0x10;
        }
        var_t2 = temp_t2 & ~7;
        if (temp_t2 < var_a0_2) {
            temp_t3_2 = var_t1;
loop_5:
            var_t1 = var_t1->unkC;
            temp_t2_2 = var_t1->unk4;
            if (var_t1 != temp_t3_2) {
                var_t2 = temp_t2_2 & ~7;
                if (temp_t2_2 >= var_a0_2) {
                    goto block_7;
                }
                goto loop_5;
            }
            arg0 = var_a0_2;
            sp24 = var_t0;
            var_v0 = alloc_next_scb(var_a0_2 - 4, arg1);
            var_a0_2 = arg0;
            if (var_v0 != NULL) {
                var_t1 = var_t0->unk8;
                var_t2 = var_t1->unk4 & ~7;
                goto block_7;
            }
            goto block_12;
        }
block_7:
        temp_t3_3 = var_t1 + var_t2;
        if (var_a0_2 < (var_t2 - 0x100)) {
            temp_t3_3->unk0 = var_a0_2;
            temp_t3_3->unk4 = (s32) (temp_t3_3->unk4 | 2);
            temp_t3 = temp_t3_3 - var_a0_2;
            temp_t3->unk4 = (s32) (var_a0_2 | 1);
            temp_t2_3 = var_t2 - var_a0_2;
            temp_t3->unk0 = temp_t2_3;
            var_t1->unk4 = (s32) (temp_t2_3 | 2);
            return temp_t3 + 8;
        }
        temp_t3_4 = var_t1->unk8;
        temp_t4 = var_t1->unkC;
        temp_t3_4->unkC = temp_t4;
        temp_t4->unk8 = temp_t3_4;
        var_t0->unk8 = temp_t3_4;
        temp_t3_5 = var_t1 + var_t2;
        var_t1->unk4 = (s32) (var_t1->unk4 | 1);
        temp_t3_5->unk4 = (s32) (temp_t3_5->unk4 | 2);
        return var_t1 + 8;
    }
block_12:
    return var_v0;
}

? *alloc_page(s32 arg0) {
    s32 sp28;
    ? **sp20;
    ? **temp_a0;
    ? *temp_v0;
    ? *var_v1;

    if ((*alloc_anchor == NULL) || ((*alloc_anchor)->unkC < arg0)) {
        temp_v0 = sbrk(alloc_anchor);
        var_v1 = temp_v0;
        if (temp_v0 == (? *)-1) {
            var_v1 = NULL;
        } else if (temp_v0 != ((s32) temp_v0 & ~0xFFF)) {
            temp_a0 = ((s32) (var_v1 + 0xFFF) & ~0xFFF) - var_v1;
            sp20 = temp_a0;
            sp28 = (s32) var_v1;
            sbrk(temp_a0, -0x1000);
            var_v1 += sp20;
        }
    } else {
        var_v1 = *alloc_anchor;
        *alloc_anchor = (*alloc_anchor)->unk4;
    }
    return var_v1;
}

void alloc_free(? *arg0) {
    ? *temp_t6;
    s32 temp_t7;
    s32 var_t8;

    temp_t7 = arg0->unkC;
    temp_t6 = *alloc_anchor;
    *alloc_anchor = arg0;
    var_t8 = temp_t7;
    arg0->unk4 = temp_t6;
    if (temp_t7 < 0) {
        var_t8 = -temp_t7;
    }
    arg0->unkC = var_t8;
}

void alloc_scb(? **arg0, s32 arg1) {
    ? *temp_v0;
    ? *temp_v1;
    s32 temp_a1;
    void *temp_a0;

    temp_v0 = alloc_page(arg1);
    *arg0 = temp_v0;
    if (temp_v0 != NULL) {
        temp_a0 = (temp_v0 + arg1) - 8;
        temp_a1 = temp_a0 - temp_v0;
        temp_v0->unkC = (s32) -arg1;
        temp_v0->unk0 = NULL;
        temp_v0->unk4 = 0;
        temp_v0->unk10 = 0;
        temp_v0->unk14 = (s32) (temp_a1 - 0xE);
        temp_a0->unk0 = (s32) (temp_a1 - 0x10);
        temp_a0->unk4 = 1;
        temp_v1 = temp_v0 + 0x10;
        temp_v0->unk18 = temp_v1;
        temp_v0->unk1C = temp_v1;
        temp_v0->unk8 = temp_v1;
    }
}

? *alloc_mark(? **arg0) {
    ? *sp34;
    ? *var_v0;
    ? *var_v1;
    s32 *temp_a1;
    s32 temp_a2;
    s32 temp_t9;
    s32 var_t2;
    void *temp_a0;
    void *temp_v1;

    alloc_scb(&sp34, 0x10000);
    if (sp34 == NULL) {
        return NULL;
    }
    var_v1 = *arg0;
    if (var_v1 != NULL) {
        var_v0 = var_v1->unk4;
        if (var_v0 != NULL) {
            do {
                var_v1 = var_v0;
                var_v0 = var_v0->unk4;
            } while (var_v0 != NULL);
        }
        var_v1->unk4 = sp34;
        sp34->unk0 = var_v1;
    }
    *arg0 = sp34;
    temp_t9 = sp34->unkC;
    var_t2 = temp_t9;
    if (temp_t9 < 0) {
        var_t2 = -temp_t9;
    }
    sp34->unkC = var_t2;
    temp_v1 = sp34->unk8;
    temp_a0 = temp_v1 + 0x10;
    temp_a1 = temp_v1 + (temp_v1->unk4 & ~3);
    temp_a2 = temp_a1 - temp_v1;
    temp_v1->unkC = temp_a0;
    temp_v1->unk8 = temp_a0;
    temp_v1->unk1C = temp_v1;
    temp_v1->unk18 = temp_v1;
    *temp_a1 = temp_a2 - 0x10;
    temp_v1->unk14 = (s32) (temp_a2 - 0xE);
    temp_v1->unk4 = 2;
    sp34->unk8 = temp_a0;
    return sp34;
}

void alloc_release(? **arg0, ? *arg1) {
    ? *temp_s0;
    ? *var_s0;
    ? *var_s1;
    ? *var_v0;

    var_v0 = *arg0;
    var_s1 = arg1;
    if ((var_v0 != arg1) && (var_v0 != NULL)) {
loop_2:
        var_v0 = *var_v0;
        if (var_v0 != arg1) {
            if (var_v0 != NULL) {
                goto loop_2;
            }
        }
    }
    if (var_v0 != NULL) {
        var_s0 = *arg1;
        if (var_s0 != NULL) {
            var_s0->unk4 = 0;
        }
        if ((var_s0 != NULL) && (var_s0->unkC < 0)) {
loop_9:
            var_s0 = *var_s0;
            if (var_s0 != NULL) {
                if (var_s0->unkC < 0) {
                    goto loop_9;
                }
            }
        }
        *arg0 = var_s0;
        do {
            temp_s0 = var_s1->unk4;
            alloc_free(var_s1);
            var_s1 = temp_s0;
        } while (temp_s0 != NULL);
    }
}

? *alloc_next_scb(s32 arg0, ? **arg1) {
    ? *sp2C;
    ? *temp_v1;
    ? *var_v0;
    ? *var_v1;
    s32 var_a1;
    void *temp_a0;
    void *temp_v0;

    var_a1 = (arg0 + 0x1017) & 0x7FFFF000;
    if (var_a1 < 0x10000) {
        var_a1 = 0x10000;
    }
    alloc_scb(&sp2C, var_a1, arg0);
    if (sp2C == NULL) {
        return NULL;
    }
    var_v1 = *arg1;
    var_v0 = var_v1->unk4;
    if (var_v0 != NULL) {
        do {
            var_v1 = var_v0;
            var_v0 = var_v0->unk4;
        } while (var_v0 != NULL);
    }
    var_v1->unk4 = sp2C;
    sp2C->unk0 = var_v1;
    temp_v1 = *arg1;
    temp_v0 = temp_v1->unk8;
    temp_a0 = sp2C->unk8;
    if (temp_v0 != NULL) {
        temp_a0->unkC = temp_v0;
        temp_a0->unk8 = (void *) temp_v0->unk8;
        temp_v0->unk8->unkC = temp_a0;
        temp_v0->unk8 = temp_a0;
    }
    temp_v1->unk8 = temp_a0;
    return (? *)1;
}

? **alloc_resize(? **arg0, s32 arg1, ? **arg2) {
    s32 sp24;
    ? *temp_v0;
    ? *var_v1;
    s32 temp_t8;

    if (arg0 != NULL) {
        if (!(arg0->unk-4 & 1)) {
            return NULL;
        }
        temp_t8 = (arg0 - 8)->unk4 & ~3;
        if (temp_t8 >= (arg1 + 4)) {
            return arg0;
        }
        sp24 = temp_t8;
        temp_v0 = alloc_new(arg1, arg2, temp_t8, arg0);
        if (temp_v0 == NULL) {
            return NULL;
        }
        memcpy((? **) temp_v0, arg0, temp_t8, arg0);
        alloc_dispose(arg0, (s32 **) arg2);
        var_v1 = temp_v0;
        goto block_9;
    }
    var_v1 = alloc_new(arg1, arg2, (s32) arg0);
block_9:
    return (? **) var_v1;
}
